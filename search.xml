<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hopper 一拳搞定 Interface Inspector</title>
    <url>/posts/24364/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近本打算搞定 <code>Downie 4</code>破解版，可谁知开发者用了<code>Swift</code>语言编写，导致我这个小白破解总是不得逞。忽然间听说了一个叫做<code>Interface Inspector</code>的软件，感觉还挺厉害的。接下来先给大家介绍一下（这是官方介绍，不是广告）：</p>
<a id="more"></a>
<blockquote>
<p><code>Interface Inspector</code> 使您可以在运行时研究任何<code>macOS</code>应用程序的用户界面结构和属性。</p>
<p>在程序中使用<code>Interface Inspector</code>非常容易。 您可以通过使用<code>Interface Inspector</code>中的快捷键<code>⌘⌥A</code>来使用附加菜单，然后选择要附加到的应用程序。 然后，您可以检查视图属性，或尝试使用不同的值来约束和更多。</p>
<p>将<code>Interface Inspector</code>附加到应用程序后，您可以使用快捷键⇧⌘K通过选择模式轻松标识各个组件。 只需单击您感兴趣的组件，它就会在<code>Interface Inspector</code>中被选中，然后开始分析其属性。</p>
</blockquote>
<p>总结来说<code>Interface Inspector</code>就相当于<code>iOS</code>越狱里的<code>FLEX</code>，或者相当<code>macOS</code>下的<code>Reveal</code>。不过后两者只能用于<code>iOS</code>，而<code>Interface Inspector</code>用于<code>macOS</code>。</p>
<p>这个软件的<strong>最新版本</strong>开发要追溯到2014年，算是一个很久没有更新的软件（估计以后也不会更新），不过仍然是付费的，所以<code>macOS</code>的 crakers，这一次我带你们 patch 它！你们有福利了。</p>
<h1 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h1><p>这次破解，我们的目标是：随便输入注册信息，即可使用App。</p>
<h2 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h2><p>这个软件的最后更新是2014年——如果你懂一些历史的话，你会知道那时候 Apple 的SDK非常落后，开发者的反破解方案很简陋，因此这个软件应该比较好破解。首先我们在注册 License 界面的UI中收集一些字符串（图一是要 License 主页面，图二是输错 License 的页面）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-ui1.png" alt="license 主页面"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-ui2.png" alt="license 错误界面"></p>
<p>我们得到的字符串：</p>
<ul>
<li>Enter your registration details below, exacly as you recieved in your confirmation email:</li>
<li>Invalid license code</li>
<li>Please go back and try again.</li>
</ul>
<blockquote>
<p>注：exacly 单词其实拼错了，应该是 exactly。不过，一切以程序中为准。</p>
</blockquote>
<h2 id="Hopper-分析"><a href="#Hopper-分析" class="headerlink" title="Hopper 分析"></a>Hopper 分析</h2><p>将程序二进制文件拖入 Hopper 分析，然后在<code>Str</code>一栏随便搜索一条我们得到的信息，比如第一条，之后不断按<code>X</code>，找到代码引用的源头：<code>-[SMEnterLicenseViewController loadView]</code>，地址为<code>0x10010ff3a</code>。我们再把<code>SMEnterLicenseViewController</code>作为关键词搜索。这个类就应该是图一的视图管理器。这时候，我们发现了一个很可疑的函数<code>register:</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-search-smelvc.png" alt="搜索SMVC"></p>
<p>我们在<code>register:</code>处下个断，然后运行，随便输入一个<code>Name</code>和<code>License</code>，按下<code>Register</code>键——断下来了！这就说明，<code>register:</code>函数里包含着<code>License</code>的验证流程。</p>
<p>打开伪代码模式：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class SMEnterLicenseViewController *&#x2F;
-(void)register:(void *)arg2 &#123;
    rdx &#x3D; arg2;
    r15 &#x3D; self;
    [self commitEditing];
    r14 &#x3D; [[r15 licenseName] retain];
    if ([r14 length] !&#x3D; 0x0) &#123;
            rbx &#x3D; [[r15 licenseCode] retain];
            r12 &#x3D; [rbx length];
            [rbx release];
            [r14 release];
            if (r12 !&#x3D; 0x0) &#123;
                    r14 &#x3D; [[r15 delegate] retain];
                    r12 &#x3D; [[r15 licenseName] retain];
                    rbx &#x3D; [[r15 licenseCode] retain];
                    [r14 enterLicenseViewControllerDidSelectRegister:r15 withLicenseName:r12 code:rbx];
                    rdi &#x3D; rbx;
                    [rdi release];
                    [r12 release];
                    [r14 release];
            &#125;
    &#125;
    else &#123;
            [r14 release];
    &#125;
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看见，第16行调用了方法<code>enterLicenseViewControllerDidSelectRegister:withLicenseName:code:</code>。我们双击看看这个方法：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class SMLicenseWindowController *&#x2F;
-(void)enterLicenseViewControllerDidSelectRegister:(void *)arg2 withLicenseName:(void *)arg3 code:(void *)arg4 &#123;
    r8 &#x3D; arg4;
    var_30 &#x3D; self;
    r12 &#x3D; [arg3 retain];
    r13 &#x3D; [r8 retain];
    rax &#x3D; [SMLicenseManager sharedInstance];
    rax &#x3D; [rax retain];
    var_38 &#x3D; rax;
    rcx &#x3D; r13;
    rbx &#x3D; [rax registerLicenseWithName:r12 code:rcx];
    [r13 release];
    [r12 release];
    if (rbx !&#x3D; 0x0) &#123;
            [var_30 loadView:0x2, rcx, r8];
            r14 &#x3D; [[var_30 delegate] retain];
            [r14 licenseWindowControllerDidRegister:var_30, rcx, r8];
            [r14 release];
    &#125;
    else &#123;
            [var_30 loadView:0x1];
    &#125;
    [var_38 release];
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们仔细品这段代码。第11行<code>rbx</code>右调用了另一个函数，不过不要紧，<code>rbx</code>应该是一个布尔值。因为第14行的判断说明，如果<code>rbx</code>为真，那么就会执行<code>if</code>代码。你再看看<code>if</code>里的第17行代码里调用了<code>licenseWindowControllerDidRegister</code>方法，从字面来看有“注册成功”的意思，因此<code>if</code>里的代码是我们想要执行的，而不是<code>else</code>里的代码。</p>
<p>上面一自然段完全是我的逻辑判断。如果你觉得我说得啰嗦，你可以通过<strong>下断点</strong>来一步步判断代码到底执行了<code>if</code>，还是<code>else</code>。</p>
<h2 id="修改-License-验证"><a href="#修改-License-验证" class="headerlink" title="修改 License 验证"></a>修改 License 验证</h2><p>想必这一步在坐各位都会了吧！打开<code>CFG Mode</code>，然后按照图中的方式 patch：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-cfg-patch.png" alt="CFG Patch"></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">jne loc_10010d137<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们导出二进制，然后打开应用，成……咦？</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-signerr.png" alt="签名错误"></p>
<h2 id="修复签名验证"><a href="#修复签名验证" class="headerlink" title="修复签名验证"></a>修复签名验证</h2><p>就如提示框说的一样，这个开发者也确实不是傻子，还知道验证个签名，防止程序被 Crack。不过别着急，先用提示框中的文字搜索一波 String：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-search-sign.png" alt="搜索签名 string"></p>
<p>看到了吗？红框中的 String 就是提示框中的字符串。</p>
<blockquote>
<p>这里教大家一个小常识，开发软件中怎样不让别人在逆向中搜索你的 String：你可以将必要的提示框间接写在一个<code>.html</code>中，这样字符串就不会再程序里直接出现。</p>
</blockquote>
<p>之后，我们随便点开一个字符串，不断按<code>X</code>查找引用，终于在<code>applicationWillFinishLaunching:</code>启动函数中的<code>loc_100024851</code>找到。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">loc_100024851:
    r14 &#x3D; [[NSAlert alloc] init];
    var_F8 &#x3D; r14;
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Signature of the Interface Inspector is broken&quot; value:@&quot;&quot; table:0x0] retain];
    [r14 setMessageText:rbx];
    [rbx release];
    [r13 release];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;The application has an unepected signature and seems to be broken or modified. Please re-download the application.&quot; value:@&quot;&quot; table:0x0] retain];
    [var_F8 setInformativeText:rbx];
    rdi &#x3D; rbx;
    rbx &#x3D; *_objc_release;
    [rdi release];
    [r13 release];
    r12 &#x3D; rbx;
    [var_F8 setAlertStyle:0x2];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Quit&quot; value:@&quot;&quot; table:0x0] retain];
    [[[var_F8 addButtonWithTitle:rbx] retain] release];
    [rbx release];
    [r13 release];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Visit Website&quot; value:@&quot;&quot; table:0x0] retain];
    rdx &#x3D; rbx;
    [[[var_F8 addButtonWithTitle:rdx] retain] release];
    [rbx release];
    [r13 release];
    if ([var_F8 runModal] &#x3D;&#x3D; 0x3e8) &#123;
            [**_NSApp terminate:0x0];
    &#125;
    else &#123;
            r14 &#x3D; [[NSWorkspace sharedWorkspace] retain];
            r13 &#x3D; [[[[NSBundle mainBundle] retain] localizedStringForKey:@&quot;http:&#x2F;&#x2F;www.interface-inspector.com&quot; value:@&quot;&quot; table:0x0] retain];
            rbx &#x3D; [[NSURL URLWithString:r13, @&quot;&quot;, 0x0] retain];
            [r14 openURL:rbx, @&quot;&quot;, 0x0];
            (r12)(rbx, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(r13, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(rax, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(r14, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            [**_NSApp terminate:0x0, @&quot;&quot;, 0x0];
    &#125;
    [var_F8 release];
    goto loc_100024b88;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>CFG Mode</code>里，流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-signcfg.png" alt="签名CFG流程"></p>
<p>我们只需要把主程序的最后一行<code>jne</code>改为<code>je</code>即可，也就是说，如果签名没有修改，那么就会报错；如果签名被修改，反而不会报错。</p>
<p>将<code>000000010002447e</code>的代码修改为：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">je loc_100024851<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="改头换面"><a href="#改头换面" class="headerlink" title="改头换面"></a>改头换面</h1><p>接下来，我们该修改一下程序的<code>About</code>资源了。在<code>/Applications/Interface Inspector.app/Contents/Resources/</code>目录下找到<code>Credits.rtf</code>，之后在上面加上你自己的 Credit，然后在应用程序顶栏<code>Interface Inspector</code>-&gt;<code>About Interface Inspector</code>，即可看到你的 Credit：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-credits.png" alt="你的 credit"></p>
<p>哈哈！我把我的名字加上去了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然这么一个简简单单的小程序，搞起来也不是多么容易。况且我第一次上手时，搜索关键词来来回回搞了很多次呢。就算我们这样破解下来，还有个小小的 bug：每次程序启动，你必须重新输入一遍 Name 和 License，只能算是不完美破解。但是搞下来还是很有收获的——毕竟这个软件本身也来之不易啊！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Hopper 之 CrossOver 19 破解</title>
    <url>/posts/16189/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章不仅放在了我的博客上，还是本人在<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >吾爱破解<i class="fas fa-external-link-alt"></i></a>上的第一个帖子。我在吾爱破解论坛上发布帖子后，又将语言表达顺了一遍，放在了我的博客上，文中的图片链接全部引用自吾爱破解，可以看到吾爱破解的水印。<strong>此篇文章未经允许，谢绝转载，并仅供学习研究。</strong></p>
<a id="more"></a>
<p>最近一直在鼓捣各种软件的逆向与反编译，又准备要在Mac上运行Windows程序，于是准备上手<code>CrossOver</code>。但是感觉在五花八门的破解网站上下载的东西不安全，求人不如求己，所以我就当练练手，自己破解试试看，而后就有了这篇文章。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>从<a class="link"   href="https://www.crossoverchina.com/" >CrossOver 官网<i class="fas fa-external-link-alt"></i></a>上下载最新版的 CrossOver 19 。</li>
<li><a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler v4<i class="fas fa-external-link-alt"></i></a> 一枚。</li>
</ul>
<h1 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h1><h2 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h2><p>首先打开<code>CrossOver</code>，简单的看了一下，分析出几个信息：</p>
<ul>
<li><p>打开软件后弹出了一个要钱弹窗，弹窗里提示了试用剩余天数，并提示你购买软件或者进行使用；</p>
</li>
<li><p>要钱弹窗中有两个需要关注的按钮，一个是 <code>现在试用</code>，另一个是 <code>使用购买信息解锁</code> ;</p>
</li>
<li><p>按下 <code>现在试用</code> 按钮，可以直接跳转到App里，开始14天试用；</p>
</li>
<li><p>按下 <code>使用购买信息解锁</code> 按钮，可以进行邮箱/密码激活，或者使用邮箱+密码+验证码激活；</p>
</li>
<li><p>开始试用App后，在<code>CrossOver</code>里仍然可以进行App激活操作。</p>
</li>
<li><p>嘿嘿，CrossOver竟然没有反调试。</p>
<p>于是，我们就有如下的破解思路：</p>
</li>
<li><p>Patch剩余天数；</p>
</li>
<li><p>Patch使用购买信息解锁的验证流程。</p>
</li>
</ul>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><h3 id="Patch剩余天数"><a href="#Patch剩余天数" class="headerlink" title="Patch剩余天数"></a>Patch剩余天数</h3><p>本篇文章选用第一种思路“Patch剩余天数”，因为第一种思路相对简单直接。我试过第二种思路，对新手来说相对复杂，我就不再阐述了。</p>
<p>打开 <code>Hopper</code>，将<code>CrossOver</code>拖入分析。本来想搜索UI中的字符串，字符串搜索无果后，根据“剩余天数”的英文“left”，搜索关键词：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-serach-left.png" alt="搜索left"></p>
<p>我们发现，第一个函数<code>-[CXApplication daysLeft]</code>，于是打开伪代码发现，这个函数返回的是一个<code>int</code>，极有可能是剩余的天数。我们可以尝试Patch这里，使得该函数永远返回十六进制<code>0x8ef8</code>。将汇编代码改为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x8ef8
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里我们要注意一点：十六进制<code>0x8ef8</code>对应的是十进制的<code>36600</code>（天）。我设置成36600，只是为了好看——36600天就是100多年。事实上，这个数值可以设置为任意大于0的整数，别忘了这个数值已经被我们 patch 了，是不会变动的。接着，我们动态调试运行一下，成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-36600.png" alt="剩余天数破解成功"></p>
<h3 id="Patch-激活窗口"><a href="#Patch-激活窗口" class="headerlink" title="Patch 激活窗口"></a>Patch 激活窗口</h3><p>你肯定觉得这篇文章不可能这么快结束。接下来，我要让你认识到一点：在App里面，仍然有某些按钮可以进行激活操作。比如程序顶栏上的<code>CrossOver</code> &gt; <code>解锁 CrossOver</code>按键，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-regwin.png" alt="某些解锁按钮仍然存在"></p>
<p>而这些按键恰恰是我们不需要的。为了App的简洁，我们现在要把App里所有激活相关的按键禁用。与其禁用所有按钮，不如把这些按钮弹出来的<strong>同一个</strong>激活窗口禁用掉。这怎么做到呢？其实非常简单。这里有个小技巧，在<code>macOS</code>里，弹出窗口必须通过<code>windowDidLoad:</code>函数，因此我们可以将<code>windowdidload</code>作为关键词搜索：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-search-windowdl.png" alt="windowdidload搜索"></p>
<p>这时我看中了<code>DemoRegisterController</code>，它应该是一个注册管理类，所以他的<code>windowDidLoad:</code>方法弹出来的窗口很有可能是那个激活窗口。我们再把<code>DemoRegisterController</code>作为关键词搜索，把这个类的相关函数（图中红框内的方法）都<code>ret</code>掉即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-drcret.png" alt="DemoRegisterController搜索"></p>
<p>指令为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改后，以调试的方式运行<code>CrossOver</code>，发现注册相关的按钮已经按不动了。成功！</p>
<h1 id="留下足迹"><a href="#留下足迹" class="headerlink" title="留下足迹"></a>留下足迹</h1><p>我之所以把这个步骤设置成一级内容，是因为它实际跟破解没有关系。通过这一步，我要告诉你，任何一位craker为了保证自己的破解作品不被盗用或广泛传播（真正的craker破解出来的东西不会随便发给别人），都会注明程序是自己破解的。就像这样：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-credits.png" alt="留下足迹" style="zoom:50%;" />

<blockquote>
<p>注：此窗口可以在程序顶栏<code>CrossOver</code>&gt;<code>关于</code>中调出。</p>
</blockquote>
<p>这个怎么办到呢？其实，如果你的App有着跟上图类似的界面，那么这个界面中间的电子权利信息（也就是文字部分）通常会被储存为一个<code>.html</code>、<code>.txt</code>或<code>.rtf</code>文件。你可以根据一下规则尝试找到它：</p>
<ol>
<li><p>如果程序支持<strong>多语言</strong>，那么它<strong>有可能</strong>在程序资源的多语言文件夹里，也就是：xxx.app/Contents/Resources/xxx.lproj/xxx.xxx。</p>
</li>
<li><p>如果程序只支持<strong>单语言</strong>，那么它<strong>可能</strong>在：xxx.app/Contents/Resources/xxx.xxx。</p>
</li>
</ol>
<p>在这个App里，我们可以根据第一个规则（此App是多语言的），通过下图找到电子权利信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-creditspath.png" alt="电子权利信息路径"></p>
<p>找到后，用文本编辑打开，在文件开头加上一句类似下面的话：</p>
<blockquote>
<p>这个版本的 CrossOver 已经由xxx破解。你可以放心使用。注意，请勿广泛传播……</p>
</blockquote>
<p>保存文件，再打开<code>CrossOver</code>，终于破解完成！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>“木兰”辞</title>
    <url>/posts/37946/</url>
    <content><![CDATA[<p>前几周，中科院发布国产编程语言“木兰”造假的新闻，不知大家听说没有——</p>
<a id="more"></a>
<blockquote>
<p>针对此前刘雷团队对外宣布“自主研发的‘木兰’编程语言体系“，中科院计算技术研究所1月24日在官网发布相关调查与处理意见，称刘雷在宣传活动中存在虚假陈述行为，同时在对外宣传活动中存在对单位的欺瞒行为。对刘雷的处理包括取消五年内专业技术岗位晋升的申请资格、全所通报批评、岗位等级降低等。中科院计算所1月15日对外发布该所计算机体系结构国家重点实验室编译技术团队自主研发、面向新一代人工智能和物联网应用的“木兰”编程语言体系，同时推出“木兰”开源软件包，供全球用户免费下载获取。随后“木兰”被指出就是Python语言“换了外皮”。中科院计算所随即于1月19日宣布当事人停职检查，对该问题展开深入调查。中科院计算所的最终处理意见称，“木兰”团队主要负责人刘雷在宣传活动中存在虚假陈述行为，同时在对外宣传活动中存在对单位的欺瞒行为。“刘雷交给媒体的宣传材料，与提交给我所宣传主管的审批材料存在严重的不一致，属欺瞒行为。”“木兰”语言分为前后两个版本，团队定义了语言规范，自主开发了编译器、字节码规范和虛拟机，基于开源的Blockly开发了可视化编程环境，针对中小学青少年编程教育开展了一些深入的工作，工作较为系统完整。但向媒体宣称“完全自主设计”有夸大成分；宣称“木兰”是“完全自主设计、开发和实现的编程语言”属虚假陈述；声称“木兰定位为下一代重要应用物联网应用的开发语言”缺乏应用案例的支撑；声称“木兰”语言采用了弹性actor执行模型、利用数据稀疏性提升效率技术属虚假陈述。意见决定对刘雷做出如下处理：取消五年内专业技术岗位晋升的申请资格；取消三年内科研项目的申请资格；全所范围内通报批评；岗位等级从工程师一级降低为助理工程师一级。  </p>
</blockquote>
<p>为此，余有感而发，创造了这首《木兰辞》，只有前后小部分参考了网友们的创作，其他皆为原创。</p>
<h1 id="《木兰辞》改编"><a href="#《木兰辞》改编" class="headerlink" title="《木兰辞》改编"></a>《木兰辞》改编</h1><p>无声复无声，桌前看新闻。不闻打字声，惟闻吾叹息。</p>
<p>问吾何所思，问吾何所忆。吾亦无所思，吾亦无所忆。适才见文章，美国限AI，清单十二卷，卷卷有国名。科研无自主，编程无语言，愿为<code>Python</code>改，从此当原创。</p>
<p>东市下破解，西市换衣裳，南市请砖家，北市发布会。旦辞GitHub去，暮宿中科院，不闻国人求自强，但闻科研经费打水漂。旦见利润高，暮生欺人心，不见中科求自立，但见木兰日夜吞蟒蛇。</p>
<p>狂窜排行榜，狂夺下载量。全国一起用，人人称真香。开发生百bug，运维十年归。</p>
<p>归见负责人，负责坐明堂。下千万功夫，赏千万大洋。负责问所欲，木兰不用走闭源，愿驰千里足，送儿继续闯。</p>
<p>国家内外闻，上网相保存；各语闻妹来，各个皆惊奇；网友闻姊来，逆向霍霍向木兰。开它<code>UPX</code>，撞它脆外皮。脱它假函数，著它真外衣。当窗来解码，照妖镜检查。裸奔同行前，同行皆惊忙：号称自主研，不知木兰是<code>Python</code>，<code>Matlab</code>做计算，<code>Swift</code>写UI，双语傍地走，安能辨我是雌雄！</p>
<h1 id="《木兰辞》原文"><a href="#《木兰辞》原文" class="headerlink" title="《木兰辞》原文"></a>《木兰辞》原文</h1><p>唧唧复唧唧，木兰当户织。不闻机杼声，惟闻女叹息。</p>
<p>问女何所思，问女何所忆。女亦无所思，女亦无所忆。昨夜见军帖，可汗大点兵，军书十二卷，卷卷有爷名。阿爷无大儿，木兰无长兄，愿为市鞍马，从此替爷征。</p>
<p>东市买骏马，西市买鞍鞯，南市买辔头，北市买长鞭。旦辞爷娘去，暮宿黄河边，不闻爷娘唤女声，但闻黄河流水鸣溅溅。旦辞黄河去，暮至黑山头，不闻爷娘唤女声，但闻燕山胡骑鸣啾啾。</p>
<p>万里赴戎机，关山度若飞。朔气传金柝，寒光照铁衣。将军百战死，壮士十年归。</p>
<p>归来见天子，天子坐明堂。策勋十二转，赏赐百千强。可汗问所欲，木兰不用尚书郎，愿驰千里足，送儿还故乡。</p>
<p>爷娘闻女来，出郭相扶将；阿姊闻妹来，当户理红妆；小弟闻姊来，磨刀霍霍向猪羊。开我东阁门，坐我西阁床，脱我战时袍，著我旧时裳。当窗理云鬓，对镜帖花黄。出门看火伴，火伴皆惊忙：同行十二年，不知木兰是女郎。</p>
<p>雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？</p>
<blockquote>
<p>这篇文章的版权，我还是保留吧，<strong>转载注明出处，谢谢！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>《草房子》读后感</title>
    <url>/posts/33945/</url>
    <content><![CDATA[<p>在这几天看的书中，给我印象最深刻的就是《草房子》，令我忍不住想要写些我的感想。</p>
<p>故事讲述了主人公桑桑跟随来接管油麻地小学的父亲来到油麻地期间，令他刻骨铭心、终身难忘的小学六年生活。在这里，他明白了许多发人深省的哲理，亲眼目睹甚至是经历了一连串感人肺腑、撼动人心的故事，例如：他和纸月之间心心相印的感情；不幸的杜小康与厄运作斗争的悲凉与勇敢；男孩细马的善良内心和他对尊严的执着坚持；秦大奶奶在生命的最后一瞬间所闪耀的人性光辉。桑桑在死亡的体验中，对生命深切而唯美的领悟，大人们之间充满诗情画意的情感纠葛……这一切，都在桑桑幼小而简单纯真的心灵里印下了深刻的烙印。</p>
<a id="more"></a>
<p>这本书留给我印象最深的，并非是特定一个人物，也不是某件事，而是每一个孩子的正直性格。书里每一章里写到的人物，都有一段非凡的经历，都展示了他们善良的品质、童稚的内心、顽强的意念，就像纸月怕让奶奶操心，在自己受欺负时默默无闻；红门落寞后坚强地面对孤独、饥饿、寒冷、生病、狂风暴雨等种种困难的杜小康；开始不爱学习后来又浪子回头、撑起家庭的细马；包括得了病却坚持上学的桑桑……在他们的心中永远都装满了甜蜜美好的事物，就像是纯洁的天使，在油麻地这片宁静的天空尽情飞翔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/grass-house-thumb.jpg" alt="草房子"></p>
<p>我认为，每个人都要在心里保留一座草房子，一座充满善良、温暖的草房子，一座充满勇敢、坚强的草房子。《草房子》用这些最纯真的爱告诉我们：每个人的一生都不是一帆风顺的，都充满了酸甜苦辣，困难和幸福犹如白昼和黑夜一样，永远与我们相伴，<strong>当苦难来临的时候，我们不能逃避，要满怀希望，像油麻地的孩子们，微笑着去面对。</strong></p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>一次意外的 CleanMyMac X 破解</title>
    <url>/posts/16190/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p><code>CleanMyMac X</code>应该是每个Mac用户耳熟能详的电脑清洁软件，以下简称<code>CMM</code>。我几天前用的是<code>CMM 4.5.3</code>版本，是在xx破解网站上搜索的TNT版本，结果今天一打开CMM发现，已经有了4.6.0版本的更新。与其到xx破解网站上搜破解版，不如自己再动手破解一遍，于是就有了这篇文章。我真的……一开始我也没想到这次破解会这么顺……</p>
<a id="more"></a>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><code>CMM 4.6.0</code>一枚；</li>
<li><code>Hopper Disassembler v4</code>一枚。</li>
</ul>
<h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="查找线索"><a href="#查找线索" class="headerlink" title="查找线索"></a>查找线索</h2><p>首先将CMM拖进Hopper。我先搜索了一波UI中的Strings。搜索无果后，尝试搜索<code>vip</code> <code>register</code> <code>activate</code>关键词，发现<code>activate</code>关键词有很多激活相关项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/15/hop-cmm-search-str.jpg" alt="搜索字符串"></p>
<p>我找到了四个方法，名为<code>isAppActivated</code>。我想，相比其他复杂的函数与方法，那是不是把这四个方法patch了，整个CMM就能用了呢？</p>
<p>然而我又发现了第一个方法<code> -[CMActivationManager isAppActivated]</code>的伪代码调用了一个函数<code>_mLyGsJNgru0iJKGfhK</code>，并将这个函数的返回值（是<code>int</code>类型）赋予给了<code>rax</code>，而这个函数的内部逻辑很复杂，很可能就是验证激活的过程。</p>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><p>接着上一个步骤，双击进入<code>_mLyGsJNgru0iJKGfhK</code>，打开伪代码模式，看着一长串的代码别着急，从程序入口开始，按照程序的<code>goto</code>走，顺藤摸瓜，最后<code>return</code>了一个<code>rax</code>——那简单，跳到汇编模式，直接：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再打开伪代码，你会发现这个方法的伪代码已经变成：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">int _mLyGsJNgru0iJKGfhK(int arg0) &#123;
    return 0x1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这就对了！</p>
<h1 id="留下足迹"><a href="#留下足迹" class="headerlink" title="留下足迹"></a>留下足迹</h1><p>为什么要有这一步，在我的<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >CrossOver 19<i class="fas fa-external-link-alt"></i></a>破解文章里已经说明了。在CMM中，我们要达到这样的效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/15/hop-cmm-mod-credits.png" alt="留下足迹"></p>
<blockquote>
<p>注：这个窗口可以在程序顶栏 CleanMyMac X &gt; 关于CleanMyMac里找到。</p>
</blockquote>
<p>这段文字是一个<code>.rtf</code>，在<code>/Applications/CleanMyMac X.app/Contents/Resources/zh-Hans.lproj/Credits.rtf</code>。打开这个文件，在开头按格式添加上你的Credit，注意一点，这个文件开头的几个空行要保留，否则达不到CMM的滚动效果。</p>
<p>之后，就大功告成了！</p>
<h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><ol>
<li>使用时，应用缺少权限，即使已经在设置里设置了磁盘完全访问。</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>一个故事讲懂 CPU 的工作原理</title>
    <url>/posts/15507/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章<strong>转载</strong>自知乎<a class="link"   href="https://www.zhihu.com/question/40571490/answer/718942643" >“CPU 的工作原理是什么？”<i class="fas fa-external-link-alt"></i></a>问题，由知乎<a class="link"   href="https://www.zhihu.com/people/liu-liang-cong" >@柳两丛<i class="fas fa-external-link-alt"></i></a>回答并撰写。本篇文章讲述了上二年级的小明在上课时联合同学，共同搭建出加法器，解决老师的问题的故事，以一篇故事的方式描述了CPU的ALU内部的加法器原理。CPU的工作原理远远不够一个加法器，但是它让你对加法器了如指掌。值得阅读。</p>
</blockquote>
<a id="more"></a>
<p>上二年级的小明正坐在教室里。现在是数学课，下午第一节，窗外的蝉鸣、缓缓旋转的吊扇让同学们昏昏欲睡。此时，刘老师在黑板上写下一个问题：</p>
<p>$ 6324 + 244675 = ? $</p>
<p>小明抬头看了一眼，觉得这两个数字挺眼熟。他昨天翘课去网吧了，因此错过了刘老师讲的竖式计算加法。</p>
<p>“同学们算一算这道题。”刘老师和蔼可亲地说道。</p>
<p>小明盯着黑板懵逼。</p>
<p>小学二年级的他面对这样一道世界级难题，束手无策。小明伸出了自己的左手，打算用一个古老而深邃的方法–掰手指–尝试一下。</p>
<p>小明发现他的每只手只能输入0-5中的正整数，和的范围仅限于0-10，离6324还十分遥远。</p>
<p>“慢着！”小明看向了自己的左手。他发现，事情有一点不对劲。</p>
<p>我们也来看看小明的左手。这只左手有5根手指，我们把5根手指都伸开来记为11111，5根手指握拳记为00000，手背面向我们，左手小指是第一个1/0。</p>
<p>小明紧紧地握拳，然后伸出大拇指，此时的左手为00001。</p>
<p>“如果，”小明想，“这样是1”。他缩回拇指，伸出食指，此时的左手为00010；“这样是2”。他又伸出拇指，此时的左手为00011；“那么这样是3”。他缩回拇指和食指，伸出中指，此时的左手为对着自己竖中指00100；“这样就是4！”…..小明的左手飞速运动着，直到五根手指都伸直，像是钢铁侠射了一发掌心炮11111；“这样就是31！一只手可以表示0-31中的任意正整数！”小明为自己的发现感到激动。</p>
<p>可他不知道怎么表示加法。小明的同桌，英语课代表小红，看他摆弄了半天左手，忍不住问他在干什么。小明解释了他的发现。小红听了小明的一番高论，若有所思，提笔在数学书的封底画了一个表格：</p>
<table>
<thead>
<tr>
<th>输入x</th>
<th>输入y</th>
<th>输入进位</th>
<th>输出结果</th>
<th>输出进位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>“如果我们能造一个机器，给它三个输入，它能返回两个结果，那我们就能算出这道题！”小红激动地说。“啥叫进位啊美女？”小明问道。“就是你列竖式的时候画的一小撇，”小红回答。“猎术士是什么，我知道猎魔人和古尔丹。”小红于是讲解了一下怎么列竖式计算十进制加法。</p>
<p>“我懂了。”小明说着，拿过小红的数学书，补全了表格：</p>
<table>
<thead>
<tr>
<th>输入x</th>
<th>输入y</th>
<th>输入进位</th>
<th>输出结果</th>
<th>输出进位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>“是这样吗？”小明问小红。小红拿过来看了看，说：“最后一行写错了，输出结果应该是1。你想啊，1+1+1应该等于11，左边这一位是输出进位，右边这一位是输出结果，都是1，所以输出结果应该是1。”</p>
<p>“噢。”小明又拿过书来，拿起橡皮铅笔改正：</p>
<table>
<thead>
<tr>
<th>输入x</th>
<th>输入y</th>
<th>输入进位</th>
<th>输出结果</th>
<th>输出进位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>“那为什么这个机器能算加法？我还是不懂。”小明问。</p>
<p>“假设我们已经造出来了这么个机器，长这样”小红继续在封底上画着：<br><img src="https://pic1.zhimg.com/50/v2-8ac43fa600293b3c0f542ce7a03eb21e_hd.jpg" alt="小红画的机器"></p>
<p>“等会等会，怎么变成英文了，我英语不好。”小明叫道。“hmmm看来你没读双语幼儿园。左边这三个是输入，右边是输出，C是进位，C-in是输入进位，C-out是输出进位，Sum是和的意思，明白了么？”小红解释道。</p>
<p>“噢好。”</p>
<p>“假设我们已经造出来了这么个机器，造了好几个，我们这么连起来…诶纸不够大，我写不下了。”小明一听，赶紧从书桌膛里翻出来一本草稿纸，生怕同桌变成费马。</p>
<p>“谢谢。先这么连起来：”<br><img src="https://pic3.zhimg.com/50/v2-eefb79c87d5a2b45585fb6cbb476ab1c_hd.jpg" alt="小红画图中"></p>
<p>“哦哦哦我懂了，A和B就是两只手，最右边这个one-bit-adder算得是最小位数的和！”小明说道。</p>
<p>“正确！”</p>
<p>“你这样连的话，是说最小位的输出进位就是下一位的输入进位，下一位的输出又是下下一位的输入！天啊，这跟列竖式好像。”小明惊叫。</p>
<p>“Absolutely!”小红回答道。</p>
<p>小明又拿过草稿纸，接着画起来：<br><img src="https://pic1.zhimg.com/50/v2-6f6916719595c2fb9d7dfc7472a66a8d_hd.jpg" alt="小明画图中"></p>
<p>“把对应的每一位连到每一个adder里…”小明念念有词，“…再汇总一下输出”：<br><img src="https://pic4.zhimg.com/50/v2-fb7e6de0ae437c626fac6bc19b0e65f9_hd.jpg" alt="小明画的加法器"></p>
<p>“成了！这个东西可以算两只手加法的结果！”小明高兴极了。“可是离6324和244675还是太远了，输入5位远远不够呀。”小红皱了皱眉头。</p>
<p>“不不不！你在掰手指的时候有没有发现，每多一根指头，能表示的数就会多出来一大堆，我觉得只要加那么十几个就够了！1根指头能表示2个数（0，1），2根指头四个数（0，1，2，3），3根8个…”“是2的倍数！”小红接道，“小明，我觉得你的这个记数方法很有意思，要不叫小明式吧！”小红凝望小明的目光中有了一丝羞涩。</p>
<p>“二进制。”身后忽然传来低沉的声音。两人同时回头，发现数学课代表小刚正直勾勾地盯着那张草稿纸。他好像已聆听多时了。</p>
<p>“叫二进制吧，我看蓝猫淘气三千问讲过这个，一模一样，蓝猫说这是二进制。”小刚补充道。小刚的数学成绩是班里最好的，一进学而思就上的超常班。小红只能上尖子班，小明一般去网吧。</p>
<p>“那就叫二进制吧。”小明说。他和小红转过身来，老师让小组讨论的时候他们就这么坐。</p>
<p>小刚又道：“可是，怎么造出这个one-bit-adder呢？”他的眉头皱成一团，眼镜片看起来更厚了。小明和小红也陷入了沉默，三人一筹莫展，陷入僵局。</p>
<p>这时，小刚的同桌，物理课代表小兰入局。她忽然说道：“我听物理办公室的陈老师吹牛，他当年在大学里读电子工程，GPA一直是4.3，用实验室的导线开关和小灯泡就能造一个32位的加法器，不知道是怎么做到的。他还说什么与门是and或门是or，再加一个非门not，用它们表示逻辑，就能造出世间千千万万的计算机。”</p>
<p>小明听迷糊了，“等会等会，什么门？金拱门？”另两人也露出迷茫的表情。</p>
<p>小兰从桌子里掏出一个黑盒子。“这是下节课要用的教具，陈老师让我先拿着。”她打开盒子，取出三个零件和一个说明书。</p>
<p>“喏，你们看看这个，”她拿起第一个零件，“这个叫与门，有两个输入和一个输出。如果我们把输出连上小灯泡，接上电源，两个输入分别连上开关，那么是这么个情况：”<br><img src="https://pic3.zhimg.com/50/v2-c70a0dd3d1758d19b446cdf64383c4c4_hd.jpg" alt="小兰画的表格"></p>
<p>“就是说，只有两个开关都闭合了，小灯泡才亮，有点像串联电路。”小兰补充道。</p>
<p>“诶，有意思了…”小刚扶了扶眼镜，似乎打算说什么，大家都看向他。</p>
<p>“没，没什么，我还在想，小兰你接着说。”</p>
<p>“那好。”小兰接着拿起第二块零件。“这个叫或门，有一个开关开着灯泡就会亮…”“等下！”小刚忽然打断，拿起笔在自己的白纸上画起来：<br><img src="https://pic1.zhimg.com/50/v2-5f00f7158a85626bdb59caafbc3d0bf8_hd.jpg" alt="小刚画的表格"></p>
<p>“是不是这样！”小刚激动地说，“如果0是关1是开，0是灭1是亮的话，或门的输入输出是不是这样？”小兰看了看道：“正是”。</p>
<p>她拿起第三个零件，“最后这个叫非门，只有一个输入，一个输出。它会输出一个相反的结果：输入有电流，输出就没有；输入没有电流，输出就有电流。用小刚的话来说，输入0输出则为1，输入1输出则为0。太简单了，懒得画表了。”小兰把非门放在桌上。</p>
<p>小刚说道：“这三个门可以表示三种逻辑。如果A、B是输入， <img src="https://www.zhihu.com/equation?tex=A%5Cvee+B" alt="A\vee B"> 就是经过或门的结果， <img src="https://www.zhihu.com/equation?tex=A%5Cwedge+B" alt="A\wedge B"> 就是经过与门的结果， <img src="https://www.zhihu.com/equation?tex=%5Cneg+A" alt="\neg A"> 则是A经过非门的结果。”三人纷纷点头。</p>
<p>“可是，这和加法有什么关系呢？”小明问道。四人再度陷入沉默。</p>
<p>沉默。</p>
<p>忽然，小明拿起笔，一边画一边说道：“如果我们回去看小红画的表格，”<br><img src="https://pic3.zhimg.com/50/v2-d39db1ff3791bbfced5c7f73df4f849a_hd.jpg" alt="左三列是输入，右二列是输出"></p>
<p>“Sum可以写成A、B、Cin的逻辑关系！”</p>
<p><img src="https://www.zhihu.com/equation?tex=Sum+=+%5Cbar%7BA%7D+B++%5Cbar%7BC%7D+++A%5Cbar%7BB%7D+%5Cbar%7BC%7D+++%5Cbar%7BA%7D+%5Cbar%7BB%7D+C+++ABC" alt="Sum = \bar{A} B  \bar{C} + A\bar{B} \bar{C} + \bar{A} \bar{B} C + ABC"></p>
<p>“你们看，把 A and B 记作 AB，A or B 记作 A + B，not A 记作 A bar。Sum 输出为1只出现在表格的2、3、5、8行，也就是三个输入中1的个数为奇数的时候。我们把这4种情况记下来，那么这个式子…”</p>
<p>“<strong>可以拿逻辑门实现！！！</strong>”四人异口同声的叫道。</p>
<p>小红抢过草稿纸，又看了看物理教具的说明书，边画边说了起来：“说明书上写，这个火车头形状的符号表示 and gate；这个B2轰炸机形状的是or gate；这个小人形状的是not gate…”<br><img src="https://pic3.zhimg.com/50/v2-9c6f955172baf7ca563c872b7b2159ea_hd.jpg" alt="小红画的与门，或门，非门"></p>
<p>她又看了一眼小明的式子，说道：“这个式子的第一项可以这样…”<br><img src="https://pic3.zhimg.com/50/v2-ea38a720462a6ee674540cc540718718_hd.jpg" alt="小红画的输出和的第一项"></p>
<p>&#34;你们看你们看，这不就是 <img src="https://www.zhihu.com/equation?tex=%5Cbar%7BA%7D+B++%5Cbar%7BC%7D" alt="\bar{A} B  \bar{C}"> 嘛！&#34;小红自豪地说。</p>
<p>小明补全了电路：</p>
<p><img src="https://www.zhihu.com/equation?tex=Sum+=+%5Cbar%7BA%7D+B++%5Cbar%7BC%7D+++A%5Cbar%7BB%7D+%5Cbar%7BC%7D+++%5Cbar%7BA%7D+%5Cbar%7BB%7D+C+++ABC" alt="Sum = \bar{A} B  \bar{C} + A\bar{B} \bar{C} + \bar{A} \bar{B} C + ABC"><br><img src="https://pic4.zhimg.com/50/v2-fa38582869101068980d89b9d1c8f0f4_hd.jpg"></p>
<p>“先把与门都画了”<br><img src="https://pic3.zhimg.com/50/v2-55b9d772fe15d371cbd41358c576e1ab_hd.jpg"></p>
<p>“再把或门都加上，搞定。这东西可以算出Sum了，接下来用一样的办法把C-out弄出来。”小明准备继续画。</p>
<p>“你们看，这里还有几个零件。”小兰指着说明书说道：<br><img src="https://pic1.zhimg.com/50/v2-fe432a72ded4834b19e0946d0ab85810_hd.jpg" alt="与非，或非，异或，同或"></p>
<p>“与非门：一个与门的输出和一个非门相连，英文是not and，NAND gate。那个小圈圈代表一个非门。或非门是或门 + 非门，not or，NOR gate。第三个叫异或门，只有两个输入中一个为1一个不为1时，才会输出1，exclusive-or，XOR gate。第四个是同或门，也就是一个异或门加上一个非门。”</p>
<p>“啊哈！”小刚灵机一动，抓起笔来道：“我有一个绝妙的点子。”<br><img src="https://pic4.zhimg.com/50/v2-64b6b52fa8bfb339802b35b3b2477850_hd.jpg" alt="小刚简化后的电路"></p>
<p>“小明的方案，要用17个门。我只要2个异或门就搞定了，牛逼吧？”三人瞪大了眼睛，仔细思考后纷纷点头道：“牛逼，牛逼。”</p>
<p>小刚随即画出了完整的one-bit-adder电路：<br><img src="https://pic2.zhimg.com/50/v2-f313968b2608bc5bbc35d2ffa22c2307_hd.jpg" alt="小刚的one-bit-adder"></noscript></p>
<p>小明从从教具盒里拿出电源、小灯泡、开关和逻辑门，按照设计图制作出了全加器：<a class="link"   href="https://www.zhihu.com/video/1124302170232877056" >加法器造出来啦！<i class="fas fa-external-link-alt"></i></a></p>
<p>看到小刚的设计被完整的实现，小明欣喜：“啊哈哈哈，吾有上将小刚，则霸业可成，汉室可兴啊！”他把黑盒子里的零件全拿了出来，四人忙碌地工作着。很快，他们拥有了5个全加器，基于小红的设计连了起来：<br><img src="https://pic3.zhimg.com/50/v2-b799b0b2ecda95693adabe4a7f7bdd80_hd.jpg" alt="小红设计实现"></p>
<p>“二进制的01100等于十进制的12，01010等于10，12+10=22，等于16+4+2，也就是二进制的10110…”四人人往代表输出结果的5个小灯泡望去：</p>
<p> 亮，灭，亮，亮，灭；正是10110！</p>
<p>“<strong>成了</strong>！！！”</p>
<p>大家激动地拍打课桌。</p>
<p>为了计算黑板上那道题，四人一共制作了32个一位全加器，将它们连接后，一个三十二位加法器便诞生了。他们历经艰辛，踩着自然规律和人类智慧的肩膀，把自己从枯燥的加法计算中解放出来！</p>
<p>窗外的蝉鸣渐渐平息，头顶的吊扇不再转动。</p>
<p>“刘老师，答案是250999！”小明站了起来，声若洪钟大吕，震慑天地。</p>
<p>他和小红、小刚、小兰分别对视了一眼，收获了坚定的目光——这目光，连同面前的32位加法器，如同新的转机和闪闪星斗，正在缀满没有遮拦的天空。</p>
<p>刘老师点了点头，欣慰的说道：“很好，看来四位同学对这部分知识掌握的不错！我们再来看几道题！”</p>
<p>他转过身，拿起板擦，把黑板擦了个精光，又从黑板槽里拾起半截粉笔，写了起来：</p>
<ol>
<li> $ 244675 – 6324 = ? $</li>
<li> $ 3.14159 + 5.535897 = ? $</li>
<li> $ 17 × 45 = ? $</li>
<li> $ 3 ÷ 2 = ? $</li>
</ol>
<p>一连四道题，让四人组陷入了深思：如何让自己的机器运算减法？乘法？除法？浮点数？</p>
<p>刘老师并没有停下，手中的粉笔运动得越来越快：</p>
<ol start="5">
<li><p>  Fibonacci 数列的第103项？</p>
</li>
<li><p> 一圈共有N个人，开始报数，报到M的人出列，然后重新开始报数，问最后出列的人是谁？</p>
</li>
</ol>
<p>……</p>
<p>疑惑越来越多了：如何存储？怎样实现分支？保证效率？</p>
<p>刘老师仍未停下，黑板快被写满了：</p>
<ol start="103">
<li><p> 方程$ ζ(s) = 0 $的所有有意义的解都在一条直线上吗？</p>
</li>
<li><p> 大于2的偶数都可以写成两个质数的和吗？</p>
</li>
</ol>
<p>……</p>
<ol start="134">
<li>生命，宇宙及所有事物的答案？</li>
</ol>
<p>刘老师放下了粉笔，半截粉笔已经变成硬币的厚度。</p>
<p>“这些问题，我们能造个机器回答么？”小明撑着头，喃喃自语。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title>个人介绍</title>
    <url>/posts/19608/</url>
    <content><![CDATA[<h1 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h1><a id="more"></a>
<p>或许，你不会想到坐在计算机后的，是一名小学生。他今年12岁了，开了学上六年级，再过半年就上初中。他就是我。</p>
<h1 id="我的属性"><a href="#我的属性" class="headerlink" title="我的属性"></a>我的属性</h1><ul>
<li>我性格不温不火不急不躁，老师说我不会与人产生磨擦，做事乍一看不急不慌的，但很有效率；</li>
<li>我非人高马大，却喜好灵巧的智力型的运动，如杠上运动等；</li>
<li>我有爱琢磨题外之事的“毛病”，经常燃烧脑细胞，挤出时间“不干正事”，而是看闲书、建网站、开发个性小程序、破解软件等等；</li>
<li>另外我喜欢低调过活，因为低调更有助于积蓄力量，在低调中爆发实力，比如任正非、库克先生——在我心中，是神一样的偶像。</li>
</ul>
<h1 id="我的荣誉"><a href="#我的荣誉" class="headerlink" title="我的荣誉"></a>我的荣誉</h1><p>小学六年完全没有为证书而奋斗的念头，但也在不经意中种下的“几根草”。遗憾的是，而后全国取消各种奥数比赛，导致我不能继续“种草”。</p>
<ul>
<li>2017年获第17届WMO世界奥林匹克数学竞赛中国区总决赛铜奖；</li>
<li>2017年获数学竞赛素质杯全国一等奖；</li>
<li>2018年获剑桥五级分类考试KET、PET证书；</li>
<li>2018年获年度桥西区三好学生证书，及诸多学校荣誉证书；</li>
<li>2016年获年度英皇（ABRSM）五级乐理证书&amp;五级演奏证书；</li>
<li>六年级上学期期末桥西区统考，获全年级唯一的语数英三科满分。</li>
</ul>
<h1 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h1><ul>
<li>读自己喜爱的书是最美的事，古今中外，数理文史……无论是中文经典还是英文原版，都让人上瘾；</li>
<li>假日忙中偷闲铺纸砚墨，写一幅对子好个享受；</li>
<li>与父母远游，用图片美文记录当地文化、美景与心情正是我想要的；</li>
<li>四年级的暑假，我和妈妈耗时7小时徒步30公里，从石家庄到赵州柏林禅寺，这次行脚让我重新认识了自己；</li>
<li>摆各种角度，拍各种视频，上PR/AE制作特效秀出天际；</li>
<li>化零为整挤时间研究计算机，看看讲座视频，是我不变的爱好；</li>
<li>还有，我最喜欢的反编译技术，破解、修改各种App，好不自喜……</li>
</ul>
<h1 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h1><h2 id="The-Wisdom-Of-Not-Knowing-演讲"><a href="#The-Wisdom-Of-Not-Knowing-演讲" class="headerlink" title="The Wisdom Of Not Knowing 演讲"></a><em>The Wisdom Of Not Knowing</em> 演讲</h2><p><video src="https://player.cdn.downk.cc/playlist/5e955f33c2a9a83be5a0df81.m3u8" controls="controls">您的浏览器不支持播放 HTML5 视频。</video></p>
<h2 id="Education-Under-the-Epidemic"><a href="#Education-Under-the-Epidemic" class="headerlink" title="Education Under the Epidemic"></a><em>Education Under the Epidemic</em></h2><p><video width="552" height="360" src="https://player.cdn.downk.cc/playlist/5e955f86c2a9a83be5a1287e.m3u8" controls="controls">您的浏览器不支持播放 HTML5 视频。</video></p>
<h2 id="《浣溪沙-•-山下兰芽短浸溪》微课"><a href="#《浣溪沙-•-山下兰芽短浸溪》微课" class="headerlink" title="《浣溪沙 • 山下兰芽短浸溪》微课"></a>《浣溪沙 • 山下兰芽短浸溪》微课</h2><p><video src="https://player.cdn.downk.cc/playlist/5e9562dac2a9a83be5a387e8.m3u8" controls="controls">您的浏览器不支持播放 HTML5 视频。</video> </p>
<h2 id="学习生活"><a href="#学习生活" class="headerlink" title="学习生活"></a>学习生活</h2><p><img src="https://pic.downk.cc/item/5e96b6e3c2a9a83be590446d.jpg" alt="演讲"><br><img src="https://pic.downk.cc/item/5e96b6e3c2a9a83be5904472.jpg" alt="书法"><br><img src="https://pic.downk.cc/item/5e96b6e3c2a9a83be5904475.jpg" alt="《小狗钱钱》讲课（1）"><br><img src="https://pic.downk.cc/item/5e96b6e3c2a9a83be590447a.jpg" alt="《小狗钱钱》讲课（2）"></p>
<h1 id="我想说"><a href="#我想说" class="headerlink" title="我想说"></a>我想说</h1><p>学习不能只拘泥于教科书本，还需常在书的海洋里自由穿行；学习不能只停在书的海洋中，还需再兴趣与爱好中勇于探索；学习不能只满足于个人兴趣爱好，还要看看这个世界需要什么。</p>
<p>对现在的我来说，成长需要两块重要的水土——家庭和学校，我已在幸福的家庭扎根汲取营养，还需要懂我的学校加以培育。虽然我的小学并不“大牌”，但是学校和老师帮我树立了理想，让我开阔了视野，体验着学习的美妙。也许现在的我不是最优秀的，但将来的我一定能给学校和老师带来惊喜。</p>
<p>呈现在你眼前的网站，就是我“利用时间在个人爱好里漫步行走”。欢迎来到我的世界！</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>说明文</tag>
      </tags>
  </entry>
  <entry>
    <title>从最简单的程序开始教你怎么破解（一）</title>
    <url>/posts/2615/</url>
    <content><![CDATA[<p>28号我发了一篇关于破解迅雷的文章，如果你看到了，你就会先被那上千的字数吓住。但是破解（反编译）真的有那么难吗？作为一个不太“菜”的“菜鸟”，我想告诉你，其实破解一个软件只是找到思路后，改改二进制的逻辑罢了。但是真的又有这么简单吗？也不是。</p>
<a id="more"></a>
<p>如果你刚接触反编译、破解软件，那就从自己开发的最简单的小程序开始破解。今天这篇文章所讲的，是关于如何在MacOS Catalina系统里，使用Hopper Disassembler破解二进制文件。希望我可以通过这篇文章能帮到你。</p>
<h1 id="入手程序"><a href="#入手程序" class="headerlink" title="入手程序"></a>入手程序</h1><p>我们想要破解，可以先从最简单的程序开始——<code>Crackmes</code>。<code>Crackme</code>都是一些公开给别人尝试破解的小程序，制作<code>Crackme</code>的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位<code>Cracker</code>，想挑战一下其它<code>Cracker</code>的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。<code>CrackMe</code>简称<code>CM</code>。有不少论坛的<code>CM</code>大赛就是指这个。我用<code>Swift</code>语言做了几个简单的<code>Crackme</code>，来教你们怎么破解。先看看第一个CM：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm1-thumb.png" alt="CM #1"></p>
<p>我的这个程序首先会用中文打印出说明书和破解要求，然后要求你输入一个固定的序列号，才能激活，如果错误，会提示让你再输入一遍，直到输入正确为止。而你的工作，就是把程序改成输入任意序列号都能激活。</p>
<h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>将这个二进制拖入 Hopper （关于 Hopper 的使用，《破解迅雷》那篇文章有所涉及，不过有时间我可以专门出一篇文章讲 Hopper 的使用，这里不再阐述）分析。分析完成后， Hopper 应该会跳转到<code>_main</code>函数。类似下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-mainfunc.png" alt="main函数"></p>
<p>有人说，不对啊，<code>Swift</code>语言没有<code>main</code>主函数这一说啊，为什么会有它呢？因为，<code>Swift</code>中，写法里没有主函数，但是<code>Swift</code>代码是从上往下依次执行的，因袭编译器在编译中，自然会解析到一种进程，但它不能称作主函数，只能用<strong>主进程</strong>这样的词<strong>形容</strong>。因此，所有代码都会出现在这里。</p>
<p>面对这么多复杂的汇编指令怎么办？自然是要瞧一瞧伪代码：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _main(int arg0, int arg1) &#123;
    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1);
    rsi &#x3D; *type metadata for Any;
    *Crackme__1.serial : Swift.String &#x3D; rax;
    *qword_100002050 &#x3D; 0x1;
    var_20 &#x3D; Swift._allocateUninitializedArray(0x1, rsi + 0x8);
    rax &#x3D; Swift.String.init(\xE8\xAF\xB4\xE6\x98\x8E\xEF\xBC\x9A\xE6\xAD\xA4\xE7\xA8\x8B\xE5\xBA\x8F\xE8\xA6\x81\xE6\xB1\x82\xE4\xBD\xA0\xE8\xBE\x93\xE5\x85\xA5\xE4\xB8\x80\xE4\xB8\xAA\xE5\x9B\xBA\xE5\xAE\x9A\xE7\x9A\x84\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xEF\xBC\x8C\xE6\x89\x8D\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n\xE8\xA6\x81\xE6\xB1\x82\xEF\xBC\x9A\xE6\x8A\x8A\xE7\xA8\x8B\xE5\xBA\x8F\xE6\x94\xB9\xE6\x88\x90\xE8\xBE\x93\xE5\x85\xA5\xE4\xBB\xBB\xE6\x84\x8F\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xE9\x83\xBD\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n, 0x89, 0x0, 0x0);
    *(int64_t *)0x19 &#x3D; *type metadata for Swift.String;
    *(int64_t *)0x1 &#x3D; rax;
    *(int64_t *)0x9 &#x3D; 0x0;
    var_28 &#x3D; default argument 1 of Swift.print();
    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0);
    swift_bridgeObjectRelease(0x0);
    swift_bridgeObjectRelease(0x0);
    swift_bridgeObjectRelease(var_20);
    Crackme__1.verify(var_20, var_28);
    return 0x0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然我不太懂OC，也不太懂这代码说的是什么，但是至少知道了如下几点（看代码注释）：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _main(int arg0, int arg1) &#123; &#x2F;&#x2F; main函数
    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1); &#x2F;&#x2F; Swift的字符串初始化。从字符串看，很可能是注册码：82mal9-29anyw-9msfz6
    ...
    rax &#x3D; Swift.String.init(\xE8\xAF\xB4\xE6\x98\x8E\xEF\xBC\x9A\xE6\xAD\xA4\xE7\xA8\x8B\xE5\xBA\x8F\xE8\xA6\x81\xE6\xB1\x82\xE4\xBD\xA0\xE8\xBE\x93\xE5\x85\xA5\xE4\xB8\x80\xE4\xB8\xAA\xE5\x9B\xBA\xE5\xAE\x9A\xE7\x9A\x84\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xEF\xBC\x8C\xE6\x89\x8D\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n\xE8\xA6\x81\xE6\xB1\x82\xEF\xBC\x9A\xE6\x8A\x8A\xE7\xA8\x8B\xE5\xBA\x8F\xE6\x94\xB9\xE6\x88\x90\xE8\xBE\x93\xE5\x85\xA5\xE4\xBB\xBB\xE6\x84\x8F\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xE9\x83\xBD\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n, 0x89, 0x0, 0x0); &#x2F;&#x2F; 这一大长串的东西也是字符串初始化，应该是中文，可能是“说明”和“要求”的字符串
    ...
    var_28 &#x3D; default argument 1 of Swift.print();  &#x2F;&#x2F; 打印了那一长串中文
    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0); &#x2F;&#x2F; 打印了那一长串中文
    ...
    Crackme__1.verify(var_20, var_28); &#x2F;&#x2F; 调用了一个叫verify的函数
    return 0x0; &#x2F;&#x2F; 程序结束
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最吸引人的是<code>verify()</code>函数，它有两个参数：<code>var_20</code>和<code>var_28</code>。这个函数把这两个参数做比较，最后打印出结果。因为函数后面没有打印结果的操作，所以这个打印结果的操作应该在函数里。</p>
<p>双击这个函数，就能查看。这个函数不短（其实源代码很短），我们来看关键点：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _$s10Crackme__16verifyyyF(int arg0, int arg1) &#123;
    ... &#x2F;&#x2F; 定义了一些东西，还打印了说明和要求
    if ((var_89 &amp; 0x1) &#x3D;&#x3D; 0x0) &#123; 
        &#x2F;&#x2F; 判断语句
    &#125;
    else &#123; 
        &#x2F;&#x2F; 判断语句
    &#125;
    rax &#x3D; outlined consume of Swift.String?(var_70, 0x1);
    return rax; &#x2F;&#x2F; 执行一些结束用的代码
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们只要让程序执行正确的语句就行了。但是怎么判断条件语句中<code>if</code>是正确的，还是<code>else</code>是正确的呢？经过仔细观察，我们看见了<code>if</code>中有一个代码：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">Crackme__1.verify(var_D0, rsi);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按照程序的思路，用户输错了，程序会提示你错误，然后再次调用函数，让用户重新输入序列号。函数中会嵌套一个同样的函数，不难看出这是<strong>递归</strong>，按照思路走，递归一般会使用在用户序列号错误的情况，因此：<code>if</code>中是用户输错的情况，<code>else</code>是输对的情况。只要让程序执行<code>else</code>代码块即可。</p>
<h1 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h1><p>随便在<code>else</code>中选一段代码，切回<code>CFG Mode</code>，可以看到，这段代码在<code>loc_100000ba2</code>里，因此<code>loc_100000ba2</code>是正确代码。沿着上面的箭头找，就会发现上面的主程序是<code>_$s10Crackme__16verifyyyF</code>函数，只需把函数下的<code>jne</code>做一个硬性跳转，换成<code>jmp</code>：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">jmp loc_100000ba2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-jmp.jpg" alt="换成jmp"></p>
<p>之后按回车。</p>
<h1 id="修改完成"><a href="#修改完成" class="headerlink" title="修改完成"></a>修改完成</h1><p>回车后，你的 Hopper 可能会出现这个诡异的画面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-cfgbug.png" alt="CFG bug"></p>
<p>不用怕，这只是 Hopper 的 CFG bug。之所以它显示这个画面，是因为你在CFG模式下，然而你的光标自动跳转到了白色区域的代码，这段代码已经不存在了（被<code>ret</code>了）。因此随便点击 Hopper 的任意位置（白色区域代码外），就可以回到 CFG 了。接下来，让我们在纵观一下 CFG：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-cfg.png" alt="纵观 CFG" style="zoom:50%;" />

<p>怎么样？刚才的两个分支变成了一个分支了。运行一下程序，无论输入什么，都可以成功激活。这么鼓捣下来，还是挺有趣的。</p>
<blockquote>
<p>再次声明：<strong>无论任何人使用文章中的技术破解任何软件造成的后果，请自行承担</strong>。  </p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>从最简单的程序开始教你怎么破解（二）</title>
    <url>/posts/39501/</url>
    <content><![CDATA[<p>今天，我们还讲Hopper反编译，不过用的还是昨天的<code>CM</code>。我今天准备告诉大家，怎样替换程序里的字符串，这样就可以为所欲为了。</p>
<a id="more"></a>
<blockquote>
<p>目标：把程序修改成，只有使用自己规定的注册码，才能激活成功。  </p>
</blockquote>
<h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><p>首先，程序拖入 Hopper 解析。完成后，在左边的搜索视图中选择<code>Str</code>，查看程序里的字符串。因为程序比较小，所以字符串只有5个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm2-search-str.png" alt="查看字符串"></p>
<p>这五个字符串，前面一个是激活码（怎么判断出来的上篇文章讲过），中间四个其实是中文的十六进制编码（对应的是“说明”“要求”和“输入错误”几个字符串），最后一个是定义用来处理换行的。既然要修改第一个，我们就点进去。</p>
<h1 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h1><p>修改字符串有两种方法。</p>
<h2 id="方法一：修改十六进制"><a href="#方法一：修改十六进制" class="headerlink" title="方法一：修改十六进制"></a>方法一：修改十六进制</h2><ol>
<li><p>把视图切换为<code>Hex Mode</code>，这个模式已经自动给你高亮了对应激活码的16进制码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm2-16bit.png" alt="16进制码"></p>
</li>
<li><p>例如，你要把激活码改成<code>111111-111111-111111</code>，那么，十六进制里，<code>1</code>对应<code>31</code>，而连字符<code>-</code>对应着<code>2D</code>，所以你就要把对应的十六进制改成：</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">31 31 31 31 31 31 2D 31 31 31 31 31 31 2D 31 31 31 31 31 31<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里我要说明一点，如果你的激活码比以前的激活码要短，那么你就尽管从头开始修改，最后剩下几位，你就在相应的位置上填写<code>00</code>即可。如果激活码比以前的长，那么会出现一个修改文件偏移量的问题，比较复杂，再次不阐述。</p>
<p>例如，你的激活码是：<code>helloworld!</code>，对应下来就是：<code>68 65 6c 6c 6f 77 6f 72 6c 64 21</code><br>2.  如果你嫌麻烦，可以在右边对应的字符串一个个修改成<code>1</code>和<code>-</code>， Hopper 会自动为你生成十六进制填在左边。<br>3.  <kbd>command</kbd>+<kbd>shift</kbd>+<kbd>E</kbd>，导出，完工！</p>
<h2 id="方法二：修改汇编代码"><a href="#方法二：修改汇编代码" class="headerlink" title="方法二：修改汇编代码"></a>方法二：修改汇编代码</h2><p>这个方法要比修改十六进制简单得多，我把它放在后面，是因为修改出来， Hopper 显示得有些让人迷糊，看不懂。我开始也用的这个方法，感觉错了，后来才知道这是最简单的方法。如果你用的是修改十六进制的方法，不妨撤回，然后用这个方法试试。</p>
<ol>
<li><p> 把视图切换回汇编代码，确保在激活码的地方。汇编代码应该长这样：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">                		a82mal929anyw9m:
0000000100000e80         db         &quot;82mal9-29anyw-9msfz6&quot;, 0                   ; DATA XREF&#x3D;_main+8
0000000100000e95         db         &quot;&quot;, 0
0000000100000e96         db         &quot;&quot;, 0
0000000100000e97         db         &quot;&quot;, 0
0000000100000e98         db         &quot;&quot;, 0                                       ; DATA XREF&#x3D;_$s10Crackme__16verifyyyF+118, _$s10Crackme__16verifyyyF+653
0000000100000e99         db         &quot;&quot;, 0
0000000100000e9a         db         &quot;&quot;, 0
0000000100000e9b         db         &quot;&quot;, 0
0000000100000e9c         db         &quot;&quot;, 0
0000000100000e9d         db         &quot;&quot;, 0
0000000100000e9e         db         &quot;&quot;, 0
0000000100000e9f         db         &quot;&quot;, 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>鼠标选中第一行。我的第一行是指：<br> <code>0000000100000e80         db         &amp;quot;82mal9-29anyw-9msfz6&amp;quot;, 0                   ; DATA XREF=_main+8</code><br> 如果你不是这一行，会发生不好的结果。</p>
</li>
<li><p> <kbd>option</kbd>+<kbd>A</kbd>修改，输入指令：<code>db “你想要的激活码”, 0</code></p>
</li>
<li><p> 之后，你的那行代码就会改成这样：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">0000000100000e80         db         6 dup (0x31), 0x2d, 0x31                    ; DATA XREF&#x3D;_main+8
0000000100000e88         db         5 dup (0x31), 0x2d, 2 dup (0x31)
0000000100000e90         db         4 dup (0x31), 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>很奇怪吧！这就是一个坑：这段代码看起来怪怪的。为什么呢？<br>我提醒一下大家：</p>
</li>
<li><p> <code>db</code>命令是定义字节，基本上常量和变量的定义都会出现，不必纠结。</p>
</li>
<li><p> <code>dup</code>是复制的意思，对应英文单词<code>duplicate</code>。那么<code>6 dup (...)</code>是什么意思，就可想而知了。</p>
</li>
<li><p> <code>0x31</code>和<code>0x2d</code>都是刚才说过的十六进制。<br>现在你就会明白，这段代码是没有问题的。</p>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>提醒大家注意几点：</p>
<ul>
<li>  十六进制码<strong>不区分大小写</strong>；</li>
<li>  汉字也可以转化为十六进制。如果你在程序中看到类似<code>x98\xH7\x2B\x..\x..</code>这样的东西，是中文的十六进制编码，不是乱码。你可以到<a class="link"   href="http://tools.jb51.net/tools/base64_decode-gb2312.php" >相关解码网站<i class="fas fa-external-link-alt"></i></a>解码成中文。</li>
<li>  如果你需要十六进制的加解密，可以试试<a class="link"   href="http://www.bejson.com/convert/ox2str/" >BeJson<i class="fas fa-external-link-alt"></i></a>等工具。</li>
<li>  在HDA里输入命令时，用不着纠结汇编指令与参数之间的空格，空一个格就好， Hopper 会自动给你补充的。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 PocketSphinx 进行真正的语音识别</title>
    <url>/posts/7ab4abc/</url>
    <content><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我最近一直在搞一个名叫 A. N. N. A. 的 <code>Python</code> 语音机器人项目（Anna 是什么单词的缩写我就不说了，自己猜去），需要用的强大的语音识别技术。翻看全网教程，没有一篇说的通的，要么就是教会如何购买百度AI会员，要么就是教如何翻墙使用谷歌语音……</p>
<p>我最近发现<code>PocketSphinx</code>语音识别很不错，但是全网还是没有哪篇文章会告诉你，如何从头到尾下载这个库，用这个库进行语音识别，<strong>并且不在电脑上留下任何垃圾</strong>，可以随时删除的安装方法。然后你又会抱怨<code>PocketSphinx</code>有多么垃圾。</p>
<p>在这篇文章里，我将告诉你如何安装<code>pocketsphinx</code>，并将其嵌入<code>speech_recognition</code>库，来更好地实现最终的语音转文字。</p>
<h1 id="电脑环境"><a href="#电脑环境" class="headerlink" title="电脑环境"></a>电脑环境</h1><ul>
<li>系统：<code>macOS Catalina</code> v10.15.3；</li>
<li>软件<ul>
<li><code>Xcode</code> v11（版本其实无所谓）；</li>
<li><code>Homebrew</code> （安装命令：<code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</code>）</li>
<li><code>Python 3</code></li>
</ul>
</li>
</ul>
<h1 id="安装PocketSphinx"><a href="#安装PocketSphinx" class="headerlink" title="安装PocketSphinx"></a>安装<code>PocketSphinx</code></h1><p>我们先来看一下<code>PocketSphinx</code>的依赖关系图：</p>
<pre class="line-numbers language-none"><code class="language-none">PocketSphinx
    |
    |-- SphinxBase
    |  |--libogg
    |  |--libvorbis
    |  |--flac
    |  |--libsamplerate
    |  &#96;--libsndfile
    &#96;-- Swig
         &#96;--PCRE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><p>打开终端，运行如下<code>brew</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew install pcre
$ brew install swig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中，<code>swig</code>是<code>pocketsphinx</code>的依赖，<code>pcre</code>是<code>swig</code>的依赖。别听网上瞎说什么<code>swig</code>要自己编译，根本不用，直接用<code>brew</code>安装即可</p>
</li>
<li><p>再使用<code>brew</code>安装<code>SphinxBase</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew install SphinxBase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令会将<code>SphinxBase</code>及其所有依赖安装到电脑上。现在，<code>brew list</code>应该如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">index_out_of_range@imac ~ % brew list
cmu-sphinxbase	libogg		libvorbis	portaudio
flac		libsamplerate	openssl@1.1	swig
ldid		libsndfile	pcre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：<code>portaudio</code>、<code>ldid</code>和<code>openssl</code>是我自己安装的，不用安装。</p>
</blockquote>
</li>
<li><p>克隆<code>PocketSphinx</code>仓库，我们要在之后的步骤手动安装仓库，别问我为什么：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@github.com:cmusphinx&#x2F;pocketsphinx.git
# 或者（推荐）
git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;cmusphinx&#x2F;pocketsphinx.git
# cd 到仓库
cd pocketsphinx-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：必须<code>clone</code>，直接下载仓库会有文件缺失，因为这个库引用了其它仓库代码。如果网速太慢，可以fq或者把仓库导入<code>gitee</code>。</p>
</li>
<li><p>==使用<code>vim</code>更改关键文件==（如果直接用<code>pip</code>安装，会有文件出错<a class="link"   href="https://github.com/bambocher/pocketsphinx-python/issues/28" >^1<i class="fas fa-external-link-alt"></i></a>）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim deps&#x2F;sphinxbase&#x2F;src&#x2F;libsphinxad&#x2F;ad_openal.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来用<code>vim</code>把</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#include &lt;al.h&gt;
#include &lt;alc.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>改为</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#include &lt;OpenAL&#x2F;al.h&gt;
#include &lt;OpenAL&#x2F;alc.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>使用<code>setup.py</code>安装（至关重要的一步，仔细看命令！）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意是<code>python3</code>而不是<code>python</code>。我一开始没加3，结果安装到<code>python2</code>系统目录去了。</p>
</li>
</ol>
<h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>使用如下命令测试<code>PocketSphinx</code>是否安装成功：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">index_out_of_range@imac ~ % python3
Python 3.8.2 (v3.8.2:7b3ab5921f, Feb 24 2020, 17:52:18)
[Clang 6.0 (clang-600.0.57)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pocketsphinx
&gt;&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果像我一样<code>import</code>没有报错，就是安装成功了！</p>
<h1 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h1><h2 id="英文识别"><a href="#英文识别" class="headerlink" title="英文识别"></a>英文识别</h2><p>安装完<code>PocketSphinx</code>后，就进入到我们的第二个阶段，嵌入<code>speech_recognition</code>模块进行语音识别了。你可以将<code>speech_recognition</code>模块理解为众多语音识别SDK与API的一个高层封装模块。使用<code>pip install SpeechRecognition</code>安装即可。</p>
<p>接下来，新建一个<code>.py</code>文件，输入如下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 注：安装时用的是 SpeechRecognition 这一名称，但是注意 import 时要用 speech_recognition 这一名称。
import speech_recognition as sr

r &#x3D; sr.Recognizer()
mic &#x3D; sr.Microphone()

def recognize(r, mic, lang&#x3D;&quot;en-US&quot;):
    print(&quot;Please wait...&quot;, end&#x3D;&quot;&quot;) # 在开始录音前等待
    
    with mic as source:
        r.adjust_for_ambient_noise(source)
        backspace &#x3D; &quot;\r&quot; * 14 # 退格字符
        print(f&#39;&#123;backspace&#125;Say something: &#39;, end&#x3D;&quot;&quot;)
        audio &#x3D; r.listen(source)
    
    # 调用识别函数（这个函数只有安装了 PocketSphinx 才能调用），具体方法看官方文档
    result &#x3D; r.recognize_sphinx(audio, language&#x3D;lang)
    
    # 打印并返回结果
    print(result)
    return result

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    recognize(r, mic)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用终端运行代码（我用<code>VSCode</code>不知为何打不开麦克风）：程序首先会打印<code>Please wait...</code>，等待一会<code>Please wait...</code>会变成<code>Say something:</code>，之后说一句英文（比如<code>hello</code>），程序就会打印出<code>hello</code>。</p>
<p>但是问题来了，我们是中国人啊！于是你把<code>recognize(r, mic)</code>改成了<code>recognize(r, mic, lang=&quot;zh-CN&quot;)</code>，程序报错了。</p>
<h2 id="中文识别"><a href="#中文识别" class="headerlink" title="中文识别"></a>中文识别</h2><p>说白了，程序的报错原因就是你没有中文语言模型，<code>PocketSphinx</code>是默认只有英文的。接下来我们添加中文模型：</p>
<ol>
<li>到 SourceForge 的<a class="link"   href="https://sourceforge.net/projects/cmusphinx/files/Acoustic%20and%20Language%20Models" >这个项目<i class="fas fa-external-link-alt"></i></a>里，找到 Mandarin（普通话），点进去有个<code>tar</code>包，下载下来并解压。</li>
<li>将解压出的目录改名为<code>zh-CN</code>，拖动到<code>/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/speech_recognition/pocketsphinx-data/</code>目录下。</li>
<li>按图中方式，将<code>zh-CN</code>目录里的文件按<code>en-US</code>目录里文件的命名规律改名：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-sphinx-chname.jpg" alt="改名"></li>
</ol>
<p>现在把程序里<code>recognize(r, mic)</code>改成<code>recognize(r, mic, lang=&quot;zh-CN&quot;)</code>，程序成功运行！不过通过实验发现，这个模型识别出来的中文貌似很垃圾……只能自己训练模型了……</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态库注入优雅破解 CrossOver</title>
    <url>/posts/22833/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次我写过一篇叫做<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >Hopper 之 CrossOver 19 破解<i class="fas fa-external-link-alt"></i></a>的文章，那么今天，我再写一篇 CrossOver 19 的破文。上一篇文章里，我用了“直接修改二进制文件”的方法来破解应用，而这次，我则通过动态库注入的方法来破解 CrossOver 19——这是一个巧妙、新奇的方法，说白了就是 hook，你会喜欢上它的。我还要感谢<a class="link"   href="https://www.52pojie.cn/home.php?mod=space&uid=476930" >@云在天<i class="fas fa-external-link-alt"></i></a>大神在我的<a class="link"   href="https://www.52pojie.cn/thread-1132170-1-1.html" >CleanMyMac X 破解贴<i class="fas fa-external-link-alt"></i></a>里的指导，要不是她，可能我到现在还不知道什么是动态库注入。</p>
<a id="more"></a>
<p>前言的最后，我再说一下来意。我只是想教大家“破解方法”，而不是给大家“破解软件”。就拿例子说吧，我现在用的 Hopper Disassembler 可是正版的。因此，如果你喜欢 CrossOver 19，请购买正版。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>从<a class="link"   href="https://www.crossoverchina.com/" >CrossOver 官网<i class="fas fa-external-link-alt"></i></a>上下载最新版的 CrossOver 19 。</li>
<li><a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler v4<i class="fas fa-external-link-alt"></i></a> 一枚。</li>
<li>与上篇文章不同的是，我们需要 Xcode（我的版本是11）。 </li>
</ul>
<h1 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h1><h2 id="分析-UI"><a href="#分析-UI" class="headerlink" title="分析 UI"></a>分析 UI</h2><p>首先打开<code>CrossOver</code>，简单的看了一下，分析出几个信息：</p>
<ul>
<li><p>打开软件后弹出了一个要钱弹窗，弹窗里提示了试用剩余天数，并提示你购买软件或者进行使用；</p>
</li>
<li><p>要钱弹窗中有两个需要关注的按钮，一个是 <code>现在试用</code>，另一个是 <code>使用购买信息解锁</code> ;</p>
</li>
<li><p>按下 <code>现在试用</code> 按钮，可以直接跳转到App里，开始14天试用；</p>
</li>
<li><p>开始试用App后，在<code>CrossOver</code>里仍然可以进行App激活操作。</p>
</li>
<li><p>CrossOver 没有附加反调试工具。</p>
<p>于是，我们就有如下的破解思路：</p>
</li>
</ul>
<ol>
<li>Patch 剩余天数；</li>
<li>Patch 使用购买信息解锁的验证流程。</li>
</ol>
<p>本文中只讲述第一种方法。</p>
<h2 id="使用-Hopper-分析"><a href="#使用-Hopper-分析" class="headerlink" title="使用 Hopper 分析"></a>使用 Hopper 分析</h2><p>拖进 Hopper，先分析一波，看看有什么函数。本来想搜索UI中的字符串，字符串搜索无果后，根据“剩余天数”的英文“left”，搜索关键词：</p>
<p><img src="https://i.loli.net/2020/03/27/DhqpY65tncdk3fO.png" alt="搜索left"></p>
<p>我们发现，第一个函数<code>-[CXApplication daysLeft]</code>，于是打开伪代码发现，这个函数返回的是一个<code>int</code>，极有可能是剩余的天数。我们可以尝试 Patch 这里，使得该函数永远返回十六进制<code>0x8ef8</code>（等同于 36600 天）。</p>
<p>按照上一篇文章的破解方法，我们只需要：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rax, 0x8ef8
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后试用天数就永远是 36600 天了。但是别忘了，我们今天是要讲如何使用动态库注入来 hook 函数的，接下来，咱们就开始 hook。</p>
<h1 id="构建动态库"><a href="#构建动态库" class="headerlink" title="构建动态库"></a>构建动态库</h1><h2 id="动态库注入原理"><a href="#动态库注入原理" class="headerlink" title="动态库注入原理"></a>动态库注入原理</h2><p>在<code>macOS</code>下的应用程序，绝大多数都会用<code>Objective-C</code>或<code>Swift</code>进行编译（<code>Python</code>这类的先不谈）。</p>
<p>如果程序使用了<code>Objective-C</code>编译，我们可以仗着<code>Objective-C</code>的动态消息传送机制与<code>runtime</code>，在程序运行时进行函数的调换。</p>
<p>然而我们 crakers 都面对的是已经编译好的程序，所以我们要把函数调换的过程写到一个动态库中，然后再用动态库注入工具（<code>insert_dylib</code>之类的）注入到原来的二进制文件中。</p>
<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>首先，<a class="link"   href="xcode://" >打开 Xcode<i class="fas fa-external-link-alt"></i></a>（按一下这里你会神奇地发现 Xcode 打开了），新建项目，选择<code>macOS</code> &gt; <code>Library</code>，新建动态库项目，如图：</p>
<p><img src="https://i.loli.net/2020/03/30/bsBnRwa75o4zJu8.png" alt="选择类型"></p>
<p>动态库的名称可以随便起，此处叫做<code>CrossOverPatch</code>，<code>Framework</code>选择<code>Cocoa</code>，<code>Type</code>选择<code>Dyamic</code>（动态）。随便找个地方保存项目即可。</p>
<p>现在你会得到一个动态库项目。</p>
<h2 id="编写动态库"><a href="#编写动态库" class="headerlink" title="编写动态库"></a>编写动态库</h2><p>首先打开工程文件里的<code>CrossOverPatch.m</code>文件，输入：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#import &quot;CrossOverPatch.h&quot;
#import &lt;objc&#x2F;runtime.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们用两个<code>#import</code>语句，将<code>CrossOverPatch.h</code>文件与<code>objc/runtime.h</code>库引入。<code>CrossOverPatch.h</code>文件（头文件），是每个<code>.m</code>文件里必须引用的。而<code>objc/runtime.h</code>库就是大名鼎鼎的运行时类库。</p>
<p>之后我们在下面声明一个实现<code>@implementation</code></p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">@implementation CrossOverPatch

@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们在实现里定义一个 hook 方法：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">- (int)daysLeftHook &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 36600;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>我们在下面的步骤中要用这个方法来替换原函数<code>daysLeft</code>，实现 hook。</strong>这里需要注意一点，我们定义的这个函数的返回值（<code>int</code>）和参数列表（无）<strong>需要与原函数相同</strong>。<code>NSLog</code>则是打印语句，方便我们后期检测程序。最后的<code>return</code>语句，让函数返回了36600这个值。你当然也可以把36600写作0x8ef8。</p>
<p>我们在实现里添加一个<code>+ (void) load</code>方法，如下：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">+ (void)load &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;CXApplication&quot;), NSSelectorFromString(@&quot;daysLeft&quot;));
    Method newMethod &#x3D; class_getInstanceMethod([CrossOverPatch class], @selector(orphansArray:));
    method_exchangeImplementations(origMethod, newMethod);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们一行一行地讲解代码：</p>
<ol>
<li>函数<code>load</code>定义。<code>load</code>函数会在动态库<strong>被加载时</strong>触发；</li>
<li>打印日志；</li>
<li>同上；</li>
<li>定义变量<code>origMethod</code>，它的类型是<code>Method</code>，它的值是<strong>原程序的</strong><code>daysLeft</code>方法。<ol>
<li><code>class_getInstanceMethod::</code>函数可以获取一个类（第一个参数）的一个实例方法（第二个参数）；</li>
<li><code>NSSelectorFromString:</code>可以通过一个字符串（第一个参数）来获取一个类；</li>
<li><code>NSSelectorFromString</code>可以通过一个字符串（第一个参数）获取一个<code>Selector</code>；</li>
</ol>
</li>
<li>定义变量<code>newMethod</code>，类型是<code>Method</code>，它的值是<strong>我们刚才自定义的<code>daysLeftHook</code>方法</strong>，我们要用这个方法来替换第4行的<code>daysLeft</code>方法。</li>
<li>将第四行和第五行定义的新、旧两个函数通过<code>method_exchangeImplementations::</code>交换。这样的话，原程序的<code>daysLeft</code>就成了我们自定义的<code>daysLeftHook</code>，而我们自定义的<code>daysLeftHook</code>就成了原程序的<code>daysLeft</code>，也就意味着成功 hook 了。</li>
<li>打印日志。</li>
</ol>
<p><code>CrossOverPatch.m</code>写完了。别忘了打开<code>CrossOverPatch.h</code>文件，声明函数：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">@interface CrossOverPatch : NSObject
+(void)load;
@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>按下<code>Cmd</code> + <code>B</code>编译一下，最终得到动态库文件：<code>libCrossOverPatch.dylib</code>！</p>
<h1 id="注入动态库"><a href="#注入动态库" class="headerlink" title="注入动态库"></a>注入动态库</h1><p>离破解只差一步——注入。方法有许多：运行<code>bash</code>脚本、修改<code>info.plist</code>……不过我更倾向于使用<code>insert_dylib</code>工具注入。点击<a class="link"   href="xcode://clone?repo=https%3A%2F%2Fgithub.com%2FTyilo%2Finsert_dylib" >这个链接<i class="fas fa-external-link-alt"></i></a>即可将<code>insert_dylib</code>项目克隆到<code>Xcode</code>，编译得到<code>insert_dylib</code>可执行文件。</p>
<ol>
<li>把<code>insert_dylib</code>、<code>CrossOverPatch.dylib</code>和 CrossOver 19 应用程序的<strong>原来的二进制文件</strong>的<strong>绝对</strong>路径记录下来。</li>
<li>打开终端，输入命令： <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd [insert_dylib的路径]
$ .&#x2F;insert_dylib [dylib的路径] [原来的二进制文件的路径]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
回车后，如果出现<code>LC_CODE_SIGNATURE load command found. Remove it? [y/n]</code>，那么就按下<code>y</code>，回车。</li>
</ol>
<p>如果出现<code>Added LC_LOAD_DYLIB to /Applications/CrossOver.app/Contents/MacOS/CrossOver_patched</code>，代表注入成功。</p>
<p>打开访达，进入<code>/Applications/CrossOver.app/Contents/MacOS/</code>位置，你还会发现有两个文件：<code>CrossOver</code>和<code>CrossOver_patched</code>。其中<code>CrossOver_patched</code>就是<strong>已经被我们注入的</strong>文件。将原来的<code>CrossOver</code>二进制删除或更改名称，将<code>CrossOver_patched</code>更名为<code>CrossOver</code>。</p>
<h1 id="改头换面"><a href="#改头换面" class="headerlink" title="改头换面"></a>改头换面</h1><p>通过下图找到电子权利信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-creditspath.png" alt="电子权利信息路径"></p>
<p>找到后，用文本编辑打开，在文件开头加上一句类似下面的话：</p>
<blockquote>
<p>这个版本的CrossOver已经由xxx破解。你可以放心使用。注意，请勿广泛传播……</p>
</blockquote>
<h1 id="验证破解"><a href="#验证破解" class="headerlink" title="验证破解"></a>验证破解</h1><p>双击<code>CrossOver</code>二进制文件，即可打开应用程序。可以看见试用天数已经破解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-36600.png" alt="剩余天数破解成功"></p>
<p>电子权利信息也被修改：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-credits.png" alt="留下足迹" style="zoom:50%;" />

<p>与此同时，你的电脑应该会弹出终端窗口。窗口中赫然显示着四行大字：</p>
<p><del>花果山福地</del><br><del>水帘洞洞天</del><br><del>齐天大圣到此一游</del></p>
<p>不好意思，搞错了，是这四行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>使用零宽字符对文本加密的实现</title>
    <url>/posts/a1f4eeb7/</url>
    <content><![CDATA[<blockquote>
<p>本文为 <a class="link"   href="http://www.52pojie.cn/" >www.52pojie.cn<i class="fas fa-external-link-alt"></i></a> 首发</p>
<p>《使用零宽字符对文本加密的实现》</p>
<p>@TLHorse</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说来话长。其实就是前几天我看到了一篇介绍Unicode的文章，里面介绍Unicode字符的广泛性。其中有一类字符叫做零宽字符，它们在电脑上输入，不可见，也不可打印，甚至输入都不会占空间，作用是控制文字排列或解决个别语言中的排版问题。</p>
<p>常见的零宽字符有以下六种：</p>
<table>
<thead>
<tr>
<th>中文名</th>
<th>英文名</th>
<th>U+</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>零宽度空格符</td>
<td>zero-width space</td>
<td>U+200B</td>
<td>用于较长单词的换行分隔。</td>
</tr>
<tr>
<td>零宽度非断空格符</td>
<td>zero width no-break space</td>
<td>U+FEFF</td>
<td>用于阻止特定位置的换行分隔。</td>
</tr>
<tr>
<td>零宽度连字符</td>
<td>zero-width joiner</td>
<td>U+200D</td>
<td>用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果。</td>
</tr>
<tr>
<td>零宽度断字符</td>
<td>zero-width non-joiner</td>
<td>U+200C</td>
<td>用于阿拉伯文、德文、印度语系等文字中，阻止会发生连字的字符间的连字效果。</td>
</tr>
<tr>
<td>左至右符</td>
<td>left-to-right mark</td>
<td>U+200E</td>
<td>用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右。</td>
</tr>
<tr>
<td>右至左符</td>
<td>right-to-left mark</td>
<td>U+200F</td>
<td>用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左。</td>
</tr>
</tbody></table>
<p>使用这些零宽字符可以实现发空白消息、发空白朋友圈等效果。不妨动脑筋一想，我们可以把这几种字符组合起来，就可以实现加密字符串的效果。</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>这篇文章咱们只介绍一个初步实现，说不定以后我会出后续，给应用添加更多功能。下面是加解密的流程图。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/04/zwe-graph.jpg" alt="ZWE流程图"><br>总之我认为解密过程较为繁琐。</p>
<h1 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h1><p>激动人心的时刻到啦。让我们一步步编写。<br>首先在全局定义三个常量：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">ZW_ONE &#x3D; u&quot;\u200b&quot; # 用来翻译1
ZW_ZERO &#x3D; u&quot;\u200c&quot; # 用来翻译0
ZW_SEP &#x3D; u&quot;\u200d&quot; # 用来翻译字符之间的间隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="加密函数-str2zwstr-origin"><a href="#加密函数-str2zwstr-origin" class="headerlink" title="加密函数 str2zwstr(origin)"></a>加密函数 <code>str2zwstr(origin)</code></h2><p>首先我们新建一个空数组，用来存储字符串每一项，并且遍历明文，使明文的每个字符<strong>先用<code>ord()</code>转换成十进制数字，再用<code>bin()</code>转换成二进制。再转换成字符串格式，最后去掉<code>0b</code>前缀</strong>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_text &#x3D; []
for char in origin:
    bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>再创建一个空字符串，用来存储最终的结果：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">final_str &#x3D; &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后进行两次遍历，先浅层遍历<code>bin_text</code>，然后为每一项深层遍历：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">for item in bin_text: # 遍历大数组每一项
    for binchar in item: # 遍历每一项中的0和1
        final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO # 把0、1分别翻译成两种零宽度字符串
    final_str +&#x3D; ZW_SEP # 每一项（字符）结束后，插入一个分隔符号
final_str.rstrip(ZW_SEP) # 去掉
return final_str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后返回<code>final_str</code>即可。<br>整体代码：</p>
<pre class="line-numbers language-none"><code class="language-none">def str2zwstr(origin):
    bin_text &#x3D; []
    for char in origin:
        bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))

    final_str &#x3D; &quot;&quot;
    for item in bin_text:
        for binchar in item:
            final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO
        final_str +&#x3D; ZW_SEP
    final_str.rstrip(ZW_SEP)
    return final_stry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="解密函数zwstr2str-enc-str"><a href="#解密函数zwstr2str-enc-str" class="headerlink" title="解密函数zwstr2str(enc_str)"></a>解密函数<code>zwstr2str(enc_str)</code></h2><p>首先我建议大家再看看基本思路中的流程图。解密不大相同。因为一开始我们要把翻译后的数据存储到第一个字符上，但是遇到分隔符后，我们又得新建一个字符，并把接下来的翻译后的数据存储到第二个字符串上，因此我们要编写一个函数<code>apponlast(arr, sth)</code>，每次运行，都将sth拼接到arr的最后一项中，如果arr的项数为0，即新增一个元素。</p>
<p>我这里用的代码极为简洁：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def apponlast(arr, sth):
    la &#x3D; len(arr) # la 是 arr 的长度
    if la: arr[la-1] +&#x3D; sth # 如果长度不为0，那么就把 arr 的最后一项与 sth 字符串拼接
    else: arr.append(sth) # 如果数组里没有元素，新建一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后编写解密函数：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def zwstr2str(enc_str):
    arr_oz &#x3D; [] # 由0和1构成的字符串构成的数组
    for char in enc_str: # 在密文里遍历
        if char &#x3D;&#x3D; ZW_ONE: apponlast(arr_oz, &quot;1&quot;) # 如果是\200b，翻译成1
        elif char &#x3D;&#x3D; ZW_ZERO: apponlast(arr_oz, &quot;0&quot;) # 如果是\200c，翻译成0
        elif char &#x3D;&#x3D; ZW_SEP: arr_oz.append(&quot;&quot;) # 如果是分隔符，把数组新建一项，重新开始循环
        else: print(&quot;Input contains non-ZW string. Aborted.&quot;); getinput() # 如果密文中有非零宽字符，终止解密并回到程序主函数（我们一会要编写）

    for idx in range(0, len(arr_oz)-1): # 遍历这个由0和1构成的字符串构成的数组
        arr_oz[idx] &#x3D; chr(int(arr_oz[idx], 2)) # 把每一项先转换为int（注意二进制参数），然后用chr转换为字符

    return &quot;&quot;.join(arr_oz) # 拼接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="完善程序"><a href="#完善程序" class="headerlink" title="完善程序"></a>完善程序</h1><p>接下来我们为程序添加一个主函数，并且加些花哨的功能。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pbanner()
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>pbanner()</code>用来打印banner：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">
def pbanner():
    banner &#x3D; colored(f&quot;&quot;&quot;
      ______
     &#x2F;___  &#x2F;\\  Zerowidth String Encoder | @TLHorse from 52pojie
    &#x2F;&#x2F;  &#x2F; &#x2F; \\\\ Type in then ENTER. The encoded string
    \\\\ &#x2F; &#x2F;__&#x2F;&#x2F; will be copied &amp; printed.
     \&#x2F;_____&#x2F;  Commands | ::openweb:: ::banner:: ::quit:: ::switchmode::
    &quot;&quot;&quot;, &#39;yellow&#39;)
    print(banner)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要说明一下，上面的<code>colored</code>函数需要依赖一个第三方库<code>termcolor</code>，可以打印出彩色字符串。</p>
<p>我们在全局设置两个变量：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">MODE_ENCODE &#x3D; True # 用来记录模式是加密还是解密
LAST_RESULT &#x3D; &quot;&quot; # 用来记录上次操作的结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>getinput</code>是一个递归，可以像命令行一样获取用户输入，代码比较复杂，功能很多，本来是有注释的，结果浏览器编辑的时候不小心给关了，没有恢复成功。大家自己摸索吧：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def getinput():
    global MODE_ENCODE, LAST_RESULT
    info &#x3D; &quot;&quot;
    if MODE_ENCODE: info &#x3D; colored(&quot;ENCODE&quot;, &#39;red&#39;)
    else: info &#x3D; colored(&quot;DECODE&quot;, &#39;green&#39;)
    input_str &#x3D; input(f&#39;[&#123;info&#125;] &#39;)
   
    if   input_str &#x3D;&#x3D; &#39;::openweb::&#39;:    os.system(&#39;open https:&#x2F;&#x2F;www.52pojie.cn&#39;) # 打开吾爱网页
    elif input_str &#x3D;&#x3D; &#39;::banner::&#39;:     pbanner() #打印banner
    elif input_str &#x3D;&#x3D; &#39;::quit::&#39;:       sys.exit(0) #退出程序
    elif input_str &#x3D;&#x3D; &#39;::switchmode::&#39;: MODE_ENCODE &#x3D; False if MODE_ENCODE else True #切换加解密
    elif input_str &#x3D;&#x3D; &#39;::cp::&#39;:         os.system(f&#39;echo &#123;LAST_RESULT&#125; | pbcopy&#39;) #复制结果

    if input_str.startswith(&quot;::&quot;) and input_str.endswith(&quot;::&quot;): getinput() #检测是否为命令
   
    out &#x3D; str2zwstr(input_str) if MODE_ENCODE &#x3D;&#x3D; True else zwstr2str(input_str)
    print(colored(&#39;     &gt;&gt;&gt; &quot;&#39;, &#39;green&#39;)+ out + colored(&#39;&quot;&#39;, &#39;green&#39;))
    LAST_RESULT &#x3D; out
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>别忘了import进类库：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import os, sys
from termcolor import colored<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>大功告成！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首先，想说明一点，文中的结果复制功能是基于pbcopy命令的，这个只有Linux和Unix有，Windows没有。所以Windows小伙伴们记得使用<code>pyperclip</code>库实现复制功能。</p>
<p>其次，我也不是计算机专业人士，所以代码的繁琐与不妥当之处欢迎在评论区指正。</p>
<p>所有代码长这样：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import os, sys
from termcolor import colored

ZW_ONE &#x3D; u&quot;\u200b&quot;
ZW_ZERO &#x3D; u&quot;\u200c&quot;
ZW_SEP &#x3D; u&quot;\u200d&quot;

MODE_ENCODE &#x3D; True
LAST_RESULT &#x3D; &quot;&quot;

def pbanner():
    banner &#x3D; colored(f&quot;&quot;&quot;
      ______
     &#x2F;___  &#x2F;\\  Zerowidth String Encoder | @TLHorse from 52pojie
    &#x2F;&#x2F;  &#x2F; &#x2F; \\\\ Type in then ENTER. The encoded string will be printed.
    \\\\ &#x2F; &#x2F;__&#x2F;&#x2F; Commands | ::openweb:: ::banner:: ::quit:: ::switchmode::
     \&#x2F;_____&#x2F;  ::cp::
    &quot;&quot;&quot;, &#39;yellow&#39;)
    print(banner)

def apponlast(arr, sth):
    la &#x3D; len(arr)
    if la: arr[la-1] +&#x3D; sth
    else: arr.append(sth)

def str2zwstr(origin):
    bin_text &#x3D; []
    for char in origin:
        bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))

    final_str &#x3D; &quot;&quot;
    for item in bin_text:
        for binchar in item:
            final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO
        final_str +&#x3D; ZW_SEP
    final_str.rstrip(ZW_SEP)
    return final_str

def zwstr2str(enc_str):
    arr_oz &#x3D; []
    for char in enc_str:
        if char &#x3D;&#x3D; ZW_ONE: apponlast(arr_oz, &quot;1&quot;)
        elif char &#x3D;&#x3D; ZW_ZERO: apponlast(arr_oz, &quot;0&quot;)
        elif char &#x3D;&#x3D; ZW_SEP: arr_oz.append(&quot;&quot;)
        else: print(&quot;Input contains non-ZW string. Aborted.&quot;); getinput()

    for idx in range(0, len(arr_oz)-1):
        arr_oz[idx] &#x3D; chr(int(arr_oz[idx], 2))

    return &quot;&quot;.join(arr_oz)

def getinput():
    global MODE_ENCODE, LAST_RESULT
    info &#x3D; &quot;&quot;
    if MODE_ENCODE: info &#x3D; colored(&quot;ENCODE&quot;, &#39;red&#39;)
    else: info &#x3D; colored(&quot;DECODE&quot;, &#39;green&#39;)
    input_str &#x3D; input(f&#39;[&#123;info&#125;] &#39;)
   
    if   input_str &#x3D;&#x3D; &#39;::openweb::&#39;:    os.system(&#39;open https:&#x2F;&#x2F;www.52pojie.cn&#39;)
    elif input_str &#x3D;&#x3D; &#39;::banner::&#39;:     pbanner()
    elif input_str &#x3D;&#x3D; &#39;::quit::&#39;:       sys.exit(0)
    elif input_str &#x3D;&#x3D; &#39;::switchmode::&#39;: MODE_ENCODE &#x3D; False if MODE_ENCODE else True
    elif input_str &#x3D;&#x3D; &#39;::cp::&#39;:         os.system(f&#39;echo &#123;LAST_RESULT&#125; | pbcopy&#39;)

    if input_str.startswith(&quot;::&quot;) and input_str.endswith(&quot;::&quot;): getinput()
   
    out &#x3D; str2zwstr(input_str) if MODE_ENCODE &#x3D;&#x3D; True else zwstr2str(input_str)
    print(colored(&#39;     &gt;&gt;&gt; &quot;&#39;, &#39;green&#39;)+ out + colored(&#39;&quot;&#39;, &#39;green&#39;))
    LAST_RESULT &#x3D; out
    getinput()

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pbanner()
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a class="link"   href="https://share.weiyun.com/PyUOPC6F" >下载.py格式代码｜密码：zsetlh<i class="fas fa-external-link-alt"></i></a></p>
<p>最后我先说明，当我把论坛上的文章贴到博客里，我惊奇地发现论坛阅读量少得可怜。但我写文章终究不是给别人看的。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>吃瓜</title>
    <url>/posts/46251/</url>
    <content><![CDATA[<p>为了欢送我们班将要出国定居的张同学，在这学期暑假，同学们和家长举办了盛大的欢送宴会。吃饭过程中，伙伴们进行了有趣吃西瓜比赛。</p>
<p>那天，我们热闹非凡地围坐在餐桌旁，个个手持着一块西瓜，表情激动，只等班里的“小吃货”张琛平一声令下开始比赛吃西瓜。随着一声“开始……”，同学们齐刷刷地低下头，大口大口疯狂地吃起西瓜来了。</p>
<a id="more"></a>
<p>发号施令的张同学（另一位姓张的同学），“始”字还没说完，就立即深吸一大口气，迫不及待地冲着那片西瓜的顶端咬去，几乎把整块三角形西瓜都吞进嘴里。没料到在他吞咽的那一瞬间，被削成尖的西瓜“顶角”，正好抵住了他的喉咙……这下可好了，想吐出那块西瓜不容易，而西瓜的“底边”也牢牢地撑住了他的狮子大嘴，动弹不得。只见琛平一脸囧样，“呜呜”地不停，眼中汪着泪水……“小吃货”费了九牛二虎之力，才把嘴里的西瓜含化了，导出一口气。</p>
<p>旁边的任同学不甘示弱，起劲地嚼着西瓜，腮帮鼓鼓的。左右开弓，朝着手里的一角西瓜的不同方向啃去。一口就咬下去三分之一，西瓜汁从嘴中间不停喷射出来，犹如一束喷泉⛲，溅落到洁白的桌布上。接着，第二口，他淡定了许多，并不着急咬，而是先使劲把嘴巴张到不能再张的地步，然后像榨汁机关闭填料口一般，快速地闭上嘴巴，以防果汁喷发，使劲咀嚼……结果西瓜汁还是源源不断地从嘴角渗了出来，滚落到下巴，形成道道亮丽的红色——而任同学也不顾了那么多，继续努力地啃着西瓜。西瓜汁都流到他脖子里了，才意识到自己吃西瓜太不像样了，便用衣服抹了抹钻进脖子里的瓜汁，继续消灭剩下的西瓜。大家一边带劲地吃着西瓜，一边欣赏着其他同学滑稽的吃相。吃声、笑声一片……</p>
<p>在作业多如牛毛的暑假，同学们能够欢聚一堂，还能有老师的陪伴……太开心了，以至于忘记了张同学的离开带我们的忧伤。而席间吃西瓜的游戏，让大家体验了少有的快乐。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>制作一个 Deepin Linux 启动盘</title>
    <url>/posts/ed6c4c67/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux 乃是操作系统之王，其可玩性、扩展性、操作性和美化性远远超过了 Windows、OS X（Darwin）等传统操作系统。Deepin Linux 是 Linux 发行版中较好的一个。我们来比较一下 Linux 的安装方式：</p>
<ol>
<li>安装到双系统：将 Linux 与 Windows 或 OS X 并行安装，形成双系统，不过容易毁坏电脑或系统引导；</li>
<li>安装到虚拟机：这倒是没问题，但是你总不能走哪都带个虚拟机运行软件吧？；</li>
<li>安装到可启动 U 盘：说白了就是让电脑使用 U 盘里的操作系统进行启动。</li>
</ol>
<p>第三种很酷？这次教大家用第三种方式安装（思想不限于 Deepin Linux）。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 电脑一个；</li>
<li><input checked="" disabled="" type="checkbox"> 存储介质一个（硬盘、U 盘等，空间 ≥ 16GB）；</li>
<li><input checked="" disabled="" type="checkbox"> Parallels Desktop 15；</li>
<li><input checked="" disabled="" type="checkbox"> Deepin Linux <a href="https://www.deepin.org/download/"><code>.iso</code>镜像</a>。</li>
</ul>
<h1 id="新建用于安装的操作系统"><a href="#新建用于安装的操作系统" class="headerlink" title="新建用于安装的操作系统"></a>新建用于安装的操作系统</h1><p>选择 Deepin Linux <a href="https://www.deepin.org/download/"><code>.iso</code>镜像</a>，新建一个 Parallels Desktop 虚拟机：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-choose-iso.png" alt="选择iso"></p>
<p>当虚拟机被加载出来后，直接停止虚拟机：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-quit.png" alt="停止虚拟机" style="zoom:50%;" />



<p>插上你的存储介质，使用虚拟机右上角的⚙️按钮进入设置，作出如下配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-seq.png" alt="配置启动顺序"></p>
<blockquote>
<p>注：“外部引导设备”里，要选择你的存储介质，比如我的 USB 3.0。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-ram.png" alt="配置内存"></p>
<h1 id="启动虚拟机安装"><a href="#启动虚拟机安装" class="headerlink" title="启动虚拟机安装"></a>启动虚拟机安装</h1><p>存储介质保持插入状态。启动虚拟机后，会出现命令行界面的 BIOS。按下图操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-inst-bios.png" alt="进入bios"></p>
<p><strong>为什么要在 BIOS 里“绕一圈”呢？其实这个动作相当于在拖延 Deepin 安装程序的启动，让存储介质在 BIOS 里提前被识别，这样才能让 Deepin 安装程序启动后找到识别我们的安装介质。</strong>最后一步按下3后，即可进入安装程序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-inst-start.png" alt="安装程序启动菜单"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-sel-disk.png" alt="选择安装存储介质"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-installing.png" alt="安装过程"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-install-success.png" alt="安装成功"></p>
<p>安装成功后，直接强制停止虚拟机：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-quit.png" alt="停止虚拟机" style="zoom:50%;" />

<p>到此，安装成功。安装成功后，存储介质不会被电脑识别，因为 OS X 不能读取<code>ext4</code>分区。</p>
<h1 id="安装介质的启动"><a href="#安装介质的启动" class="headerlink" title="安装介质的启动"></a>安装介质的启动</h1><p>安装成功的存储介质，可以通过 Windows 电脑中的 BIOS 进行 Legacy Boot。问题是 OS X 系统（更适合说成 Mac 电脑上）并不支持 Legacy Boot，只支持 EFI 启动。也就是说无法直接使用硬盘启动（即使在启动时按下<kbd>option</kbd>键也不行）。怎么办？这回 Parallels Desktop又派上了用场。</p>
<ol>
<li>新建（虚拟机）；</li>
<li>从 DVD 或镜像文件；</li>
<li>继续；</li>
<li>手动选择；</li>
<li>没有指定源也继续（相当于创建空白虚拟机）；</li>
<li>选择操作系统 -&gt; 更多 Linux -&gt; 其它 Linux；</li>
<li>虚拟机名称：U Machine（随便起名）。</li>
</ol>
<p>创建完成后，直接停止虚拟机，在设置里作出如下配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-ram.png" alt="配置内存"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-um-conf-seq.png" alt="配置启动顺序"></p>
<p>现在启动一下虚拟机（你的存储介质应该是插着的），虚拟机会自动检测出你的存储介质，并从中启动。这样不论是在什么电脑上，都可以从你的存储介质中启动系统了！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>系统底层</tag>
      </tags>
  </entry>
  <entry>
    <title>夏季中的一点凉</title>
    <url>/posts/40635/</url>
    <content><![CDATA[<p>烈日当空，骄阳似火，一切万物好像都已熔化，平常在树上叽叽喳喳的小鸟热的不知去向。空中、地面，到处都是刺眼的阳光，让人睁不开眼。</p>
<a id="more"></a>
<p>拎着大包小包的我和妈妈疾步往家走，想赶快逃离蒸腾的热浪，走呀走……终于到家。一进家门，舒爽清凉的空气扑面而来，我像飞鼠一般窜进屋子，直卧进沙发里。空调的凉气，依旧难以消除酷暑带来的口干舌燥，我连倒杯水的力气都没有了，瘫在沙发上使劲喘着粗气。</p>
<p>这时，妈妈从冰箱里抱出半个西瓜，我眼盯着冰凉西瓜，跟进了厨房。只见瓜皮上布满了浅黄墨绿相交的条纹，瓜瓤红红的沙沙的，漆黑油亮的西瓜籽，镶嵌在红瓤里，偶尔可见几颗褐色瓜籽和白色未成形的籽宝宝。一看就知道，这是个不错的西瓜。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/watermelon-thumb.jpg" alt="西瓜"></p>
<p>看着冒凉气，透着清香的一角角西瓜，我已经迫不及待了。嫩嫩的瓤、丝丝的甜、喷喷的凉，红红的瓜汁让我直流口水。我拿起一个叉子，对着一块最诱人的西瓜插去，放进嘴里，霎时干燥的嘴唇冒火的喉咙，冰冰地、酥酥地，像过电一样。我悠哉地嚼着，香甜清凉的汁液，渗进了每一个细胞。啊，吃西瓜真是一件美事！</p>
<p>西瓜既不像甘蔗甜得跑了调、喉住了嗓，又不像梨子甜得只有单一的味道。西瓜可以解渴，吃多少不会腻，直到肚子鼓鼓没了缝隙；西瓜可以解馋，甜得自然香得穿心；西瓜可以养目，看着就爱人儿、提神醒眼。</p>
<p>不一会，一块又一块的西瓜填进嘴中，我越吃越带劲，越吃越不讲究，瓤里的瓜籽都顾不得吐出来……终于一盘西瓜进肚。嘴里的瓜香久久不散，甜滋滋的，不管是喝酸奶、吃葡萄，都不能遮去西瓜的味道。</p>
<p>夏天，人们多爱味道各样的雪糕，殊不知不寡不腻生津止渴、香甜可口的西瓜才是大自然赐给我们的最上解暑果品——甜蜜蜜、凉滋滋，爽歪歪。烈日炎炎，我们为什么不饱尝有益健康的西瓜呢？</p>
<p>什么时候才能到2020年的夏天呢？</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>小镇的桥</title>
    <url>/posts/1372/</url>
    <content><![CDATA[<p>土门关驿道小镇是个古香古色的地方。在驿道小镇，我被一座“桥”定住了神经，它有一个动人的名字，“同情桥”。</p>
<a id="more"></a>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/yidao-town-bridge-thumb.png" alt="同情桥"></p>
<p>桥由绳索与木板搭成，像一条晃晃悠悠的长长纽带，中间微微下垂，两头分别被系在小镇两边高起的地势上。桥上系着密密麻麻的红色祈愿丝缎，远望去“同情桥”就像天空上飘着一条红丝带。小桥身材很苗条且修长，只能同时容下两三个人并行的它，从这头延伸到那边，好长！</p>
<p>当我来到桥边，正是游客最多的时候，人在桥上走，桥在空中摇。长桥上整齐地塞满了人，不见空隙；人们前胸贴后背，一步一探，缓慢移动着。看着摇摇欲坠不堪重负的长桥，我没有上前凑热闹，静静地坐在一边欣赏驿道小镇的桥。</p>
<p>各种各样的人——胖的、瘦的、高的、矮的、男的、女的、老的、少的，在桥上走。老爷爷脸上带着一丝淡定的微笑，远望着桥对岸；年轻妈妈俯身刻意与小儿谈天讲故事，驱散孩子的恐惧；小孩子们时而露齿嬉笑，时而紧张地张着大嘴；小不点的婴儿不管那一套，想哭就哭想闹就闹。人们在空中的“红布条”上，在烈日下享受着惊险和刺激。</p>
<p>此时，“桥先生”看到了自己身上有那么多勇敢的大朋友和小朋友，也许想再添点佐料和大家逗乐？只见桥身微微荡漾，一阵惊叫，桥上的行人赶忙紧握绳索，停步不前，屏住呼吸；爸爸搀扶着爷爷奶奶；妈妈紧抱着哇哇大叫的婴儿；孩子大呼爸爸妈妈，再不敢淘气调皮……</p>
<p>桥上步子慢了下来，桥身晃动也随之变轻，过桥人和我心里都松了口气。孩子们恢复了生气，大人们表情不再紧张，桥上说笑声又响起。</p>
<p>桥先生用缓慢优雅的摆幅安抚着桥上紧张的心，用桥板吱呀呀的响声合着桥上有节奏的步伐。</p>
<p>一切都是那么地和谐——危险是假的，刺激是真的；害怕是假的，快乐是真的；通过桥是假的，通过心里的挑战是真的。</p>
<p>驿道小镇的桥，我在静静地读你，如果我给你起名，会叫你“同心桥”。有人行，才有你摇曳的优雅；长桥在，才有穿行的渴望和欢乐。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>形式论</title>
    <url>/posts/912a529f/</url>
    <content><![CDATA[<blockquote>
<p>今天所要说的形式，并非对哲学的专用词汇进行高谈阔论，而是我的一点见解。文章内容不涉及敏感话题。全文用第二人称写，目的是增强代入感，但不要因为觉得作者把读者唯物主义化而生气，鄙人拙笔，敬请斧正。</p>
</blockquote>
<p>我是一个有神论者，唯心主义者。请放下你的偏见，别总觉得有神论就是迷信。</p>
<p>“万物皆形式。”这句话你无法否认，因为你们眼前的分子、原子、质子、中子、电子、光子、胶子、夸克，无时无刻不被你们触摸着；但同时你也无法证明，因为只要一个简单的数学公式就能算出来，二分之一的正无穷次幂结果为0。在唯物主义与唯心主义互相纠缠的今天，你们开始自己创造各种学科的分支，尝试支撑自己的理论。但是，扪心自问，真的有用吗？</p>
<p>尝试解释宇宙是你们的最终幻想，这是好事。这幻想好比搭积木，一直搭到宇宙的最高层。<strong>但是现在你们非但不好好搭，还开始用胶水粘，到最后你们因为一个喜欢用502胶另一个喜欢用AB胶吵起来了。</strong></p>
<p>“唯物主义认识到上述论断包含矛盾，但是不试图解决这个矛盾，而是把它承认下来，认为万事万物都是包含矛盾的，越矛盾就越真实。”当我读到这句话时，我都想笑。因为<strong>任何创造者都有对其产物的最终解释权。</strong></p>
<p>当我看见你们有人发表无神论见解，说一切神都没有科学依据，我就急，发火，后颈灼热：<strong>你把科学作为依据也不是不可以，这是大众普遍接受的想法，但是科学也是人创造的，你咋就不说科学本身没有依据呢？</strong>然后我就气冲冲地退掉浏览器，关掉电脑，笔、纸，写作业，一气呵成。</p>
<p>你振振有词：科学可是人们的实践得来的！眼见为实。我也振振有词：即使是实践也不一定对。通过你的眼球与近视1000度的眼球看，世界不一样；透过三维的角度与四维的角度看，世界不一样；透过显微镜与眼睛看，世界不一样；透过氧气与水看，世界不一样。</p>
<p>你没听错。你永远和真实世界隔着无限层滤镜。</p>
<p>你甚至连你自己是谁都不知道，负一岁的时候你和妈妈是一体，一岁的时候你又是独立的个体。你的身体到底是什么，谁也说不清楚。如果你把它定义成独立的一组个体，我从你手上刮掉一层细胞，你就不是你了。同时，意识本身是一个奇迹，不能直接出现在任何物质上，只是你自己创造的，你对你的意识有最终解释权。在人类的有限认知中，意识是通过肉体活动的，而肉体却不断变化，<strong>从手上刮掉细胞与人的死亡不都是肉体变化吗？那你怎么知道前者发生你还活着，后者发生你就没了呢？</strong></p>
<p>你：心电图是直线。我：心电图展示的是肉体。</p>
<p>…………</p>
<p>你可以使用你的思想对世界进行任何解释，无论是主观的，还是客观的；然而世界像一抹孤零零的雾，只在你身边飘着。</p>
<p>现在你可能知道为什么我是唯心主义者了。别忘了那句话：<strong>任何创造者都有对其产物的最终解释权。</strong></p>
<h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>我承认上面的大段文字确乎有些高深莫测，因为哲理都是一言难尽的。我简单在这里列举一下我的<strong>个人</strong>主要观点：</p>
<ol>
<li><p>文章最主要的线索：<strong>任何创造者都有对其产物的最终解释权。</strong>即一个人主观创造了某个事物，那么他认为事物是怎样的，事物就是怎样的。也就是说事物无论如何都是一个产物，继承创造者的理念。</p>
</li>
<li><p>从唯物主义出发，任何事物本身存在，然后构成意识，但是除了意识不能证明物质存在。所以我认为意识先存在，因为意识是个体，它对它的产物有解释权，它可以进行任何创造。这也印证了《心经》中的“色即是空，空即是色”。</p>
</li>
<li><p>在文章与前两条思想的基础上，说明了我们无法摘掉滤镜看真正的宇宙，正是因为我们站在物质的角度上，我们在自己的想象中去研究自己想象的东西，而不是想象本身。</p>
</li>
<li><p>一切都是递归，万物皆空。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>执行一个优美的并行程序</title>
    <url>/posts/42d3b274/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>我最近用<code>Python</code>的<code>print</code>，通过打印一帧帧的进度条，实现了一个进度条样式，顺便跟大家分享一下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time

AT_PROGRESS_BAR &#x3D; [
    &quot;(                    )&quot;, 
    &quot;(@                   )&quot;, 
    &quot;(@@                  )&quot;, 
    &quot;(@@@                 )&quot;, 
    &quot;(@@@@                )&quot;, 
    &quot;(@@@@@               )&quot;, 
    &quot;(@@@@@@              )&quot;, 
    &quot;(@@@@@@@             )&quot;, 
    &quot;(@@@@@@@@            )&quot;, 
    &quot;(@@@@@@@@@           )&quot;,
    &quot;(@@@@@@@@@@          )&quot;,
    &quot;(@@@@@@@@@@@         )&quot;,
    &quot;(@@@@@@@@@@@@        )&quot;,
    &quot;( @@@@@@@@@@@@       )&quot;,
    &quot;(  @@@@@@@@@@@@      )&quot;,
    &quot;(   @@@@@@@@@@@@     )&quot;,
    &quot;(    @@@@@@@@@@@@    )&quot;,
    &quot;(     @@@@@@@@@@@@   )&quot;,
    &quot;(      @@@@@@@@@@@@  )&quot;,
    &quot;(       @@@@@@@@@@@@ )&quot;,
    &quot;(        @@@@@@@@@@@@)&quot;,
    &quot;(         @@@@@@@@@@@)&quot;,
    &quot;(          @@@@@@@@@@)&quot;,
    &quot;(           @@@@@@@@@)&quot;,
    &quot;(            @@@@@@@@)&quot;,
    &quot;(             @@@@@@@)&quot;,
    &quot;(              @@@@@@)&quot;,
    &quot;(               @@@@@)&quot;,
    &quot;(                @@@@)&quot;,
    &quot;(                 @@@)&quot;,
    &quot;(                  @@)&quot;,
    &quot;(                   @)&quot;,
    &quot;(                    )&quot;,
]
def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行效果如下：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-loading.gif" alt="进度条"><br>然而，我现在有一个函数，叫做<code>long_function()</code>，用来模拟一个执行时间很长的函数：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我想让<code>long_function()</code>执行的时候，让<code>print_progress_bar()</code>也一块伴随执行。但是如果我们直接使用如下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    long_function()
    print_progress_bar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>两个函数是不会同时执行的。因此，我们就需要使用<code>multiprocessing</code>模块，使用并行程序<a class="link"   href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html" >^1<i class="fas fa-external-link-alt"></i></a>执行。</p>
<h1 id="需求一：2进程并行执行"><a href="#需求一：2进程并行执行" class="headerlink" title="需求一：2进程并行执行"></a>需求一：2进程并行执行</h1><p>代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process

AT_PROGRESS_BAR &#x3D; [
    &quot;(                    )&quot;, 
    &quot;(@                   )&quot;, 
    &quot;(@@                  )&quot;, 
    &quot;(@@@                 )&quot;, 
    &quot;(@@@@                )&quot;, 
    &quot;(@@@@@               )&quot;, 
    &quot;(@@@@@@              )&quot;, 
    &quot;(@@@@@@@             )&quot;, 
    &quot;(@@@@@@@@            )&quot;, 
    &quot;(@@@@@@@@@           )&quot;,
    &quot;(@@@@@@@@@@          )&quot;,
    &quot;(@@@@@@@@@@@         )&quot;,
    &quot;(@@@@@@@@@@@@        )&quot;,
    &quot;( @@@@@@@@@@@@       )&quot;,
    &quot;(  @@@@@@@@@@@@      )&quot;,
    &quot;(   @@@@@@@@@@@@     )&quot;,
    &quot;(    @@@@@@@@@@@@    )&quot;,
    &quot;(     @@@@@@@@@@@@   )&quot;,
    &quot;(      @@@@@@@@@@@@  )&quot;,
    &quot;(       @@@@@@@@@@@@ )&quot;,
    &quot;(        @@@@@@@@@@@@)&quot;,
    &quot;(         @@@@@@@@@@@)&quot;,
    &quot;(          @@@@@@@@@@)&quot;,
    &quot;(           @@@@@@@@@)&quot;,
    &quot;(            @@@@@@@@)&quot;,
    &quot;(             @@@@@@@)&quot;,
    &quot;(              @@@@@@)&quot;,
    &quot;(               @@@@@)&quot;,
    &quot;(                @@@@)&quot;,
    &quot;(                 @@@)&quot;,
    &quot;(                  @@)&quot;,
    &quot;(                   @)&quot;,
    &quot;(                    )&quot;,
]

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    p &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())
    p.start()
    long_function()
    p.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们首先在<code>__main__</code>（主程序）里面新建一个<code>Process</code>实例；其次，用<code>start()</code>启动这个程序；第三，运行父程序<code>long_function()</code>，最后再用<code>join()</code>函数等待到程序终止。</p>
<p>效果（因为两个<code>print</code>语句冲突，所以可能打印的效果不太好，但是是正常的）：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async.gif" alt="效果-需求一"></p>
<h1 id="需求二：2-进程并行"><a href="#需求二：2-进程并行" class="headerlink" title="需求二：2+进程并行"></a>需求二：2+进程并行</h1><p>对于2+进程的并行程序来说，我们使用进程池（<code>Pool</code>）来实现会更方便一些。代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process, Pool # 引入 Pool

AT_PROGRESS_BAR &#x3D; [...] # 为了观看方便，把这个数组省略了

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

# 我在这里新增了第三个函数：bfunc，作为第三个进程。
def bfunc():
    for i in range(30):
        time.sleep(0.5)
        print(&quot;bfunc&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pool &#x3D; Pool(2) # 新建一个含有两个进程的进程池
    pool.apply_async(print_progress_bar, args&#x3D;()) # 添加 print_progress_bar 进程
    pool.apply_async(bfunc, args&#x3D;()) # 添加 bfunc 进程
    long_function() # 执行主进程
    p.close() # 进程池不再接受新进程
    p.start() # 启动进程池
    p.join() # 进程池等待结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>三个进程并行的运行效果（<code>print</code>语句还是有些冲突，不过运行正常）：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-2.gif" alt="效果-需求一"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果你把<code>pool</code>里添加上4+个进程的话，程序的并行可能失败。这取决于你的电脑有几个 CPU（就是几核），可以通过如下<code>os.cpu_count()</code>命令查询：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">Python 3.8.2 (v3.8.2:7b3ab5921f, Feb 24 2020, 17:52:18) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import os
&gt;&gt;&gt; 
&gt;&gt;&gt; os.cpu_count()
4
&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="需求三：两进程并行中，其中一个进程停止，另外一个进程也停止"><a href="#需求三：两进程并行中，其中一个进程停止，另外一个进程也停止" class="headerlink" title="需求三：两进程并行中，其中一个进程停止，另外一个进程也停止"></a>需求三：两进程并行中，其中一个进程停止，另外一个进程也停止</h1><p>一开始我使用<code>Pool</code>进行并行，并且尝试捕捉<code>SIGCHLD</code>信号，来解决标题中的问题，但是这样好像行不太同。实际上我们可以使用两个<code>Process</code>实现，代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process

AT_PROGRESS_BAR &#x3D; [...] # 为了读者方便，省略数组内容

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    p &#x3D; Process(target&#x3D;long_function, args&#x3D;())
    p.start()
    p2 &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())
    p2.start()
    p.join()
    p2.terminate()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们希望<code>long_function()</code>执行结束后，停止<code>print_progress_bar()</code>进程。</p>
<p>代码中：首先，我创建了<code>p</code>和<code>p2</code>两个<code>Process</code>，分别代表<code>long_function</code>和<code>print_progress_bar</code>，再分别<code>start()</code>进程；其次，我通过<code>p.join()</code>等待<code>p</code>进程结束，却不等待<code>p2</code>结束；最后，我巧妙地在<code>p</code>结束（即<code>long_function()</code>结束后）后，通过<code>terminate()</code>停止<code>p2</code>进程。</p>
<p>这种方法的好处是，我们不用等待或传递任何信号，而只是通过<strong>代码的从上到下依次执行规律</strong>，解决标题中的问题。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战</title>
    <url>/posts/30893/</url>
    <content><![CDATA[<p>今天姥姥让我看了一个由『中国梦想秀 • 第十季』播出的、名为《少年挑战吉尼斯世界纪录——抛接还原魔方》的短视频。起初我不以为然，几秒种后，我惊呆了，心里充满了无限激动与惊叹。</p>
<a id="more"></a>
<p>节目一开始，首先映入眼帘的是容纳着几千名观众的挑战会场、台上主持人、两位吉尼斯认证官与12岁的“神童”阙剑宇。接着，放在桌子上的三个魔方很快被两位认证官打乱，用黑黑的布盖上。看着屏幕上写着的“倒计时5:20:00”字样，我心想，这也太离奇了吧，怎么可能在这么短的时间内复原三个魔方呢？当一切准备停当后，随着一声有力的“开始”，吉尼斯挑战赛启动了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/challenge-thumb.jpg" alt="还原魔方"></p>
<p>让人们目瞪口呆的时刻来了——挑战者阙剑宇没有只专注于一个魔方去努力地复原，而是两手抓起三个魔方，交错往高空抛掷，俨然像个杂技演员。当镜头放慢时，我被震住了，原来剑宇在每个魔方触手的瞬间转动着魔方，同时对三个魔方进行着复原！当摄像头转向观众，人们个个惊愕地张着大嘴，表情凝固，好像在说：“天呐，太神奇了。太不可思议了……这是真的吗?”</p>
<p>我紧盯屏幕，眼球随着三个魔方飞秒般地转动，担心这位神童出现闪失。阙剑宇继续小心翼翼地抛着魔方，同时快速地用另一只手接住另一个魔方，手接魔方的一刹那，飞速精准地用手指拨动色块，反复抛起反复拨动着……我几乎不敢相信眼前这一幕是真的。</p>
<p>“第一个魔方复原完成（用时2’ 01’’）”，一个大大的红色提示框出现在屏幕左下角。</p>
<p>此时，“神童”抛魔方的速度越来越快……越来越快，以至于画面都模糊了。不见魔方，只见一条条虚幻的彩色光带飘向空中，剑宇双手快速旋转的魔方像一个运动着的彩色风火轮。镜头被抬高，当看到阙同学紧锁眉头、紧咬牙关，台下的观众和我都心惊胆颤、惴惴不安。</p>
<p>3’ 39’’的字样在屏幕上闪烁着……</p>
<p>我快窒息了，还有两个魔方，阙同学能在这么短的时间内复原吗？又过了大概10秒钟，一个令人欣慰的提示框出现在屏幕下方。<br>“第二个魔方复原完成（用时1’44’’）”，我心中那块沉重的石头终于落地了。</p>
<p>“还有大约一分钟！”主持人宣布。</p>
<p>至关重要的一分钟！我紧张地盯着屏幕。阙剑宇越来越快地抛接魔方，魔方嗖嗖咔咔作响，这时魔方抛起的高度也降低了；他眼睛盯魔方越来越紧，手的转速越来越快……让人欣慰的是，到目前为止神童没有一次将魔方甩掉或者转错层。挑战者如此高超的技艺和强大的心理素质，让我佩服得五体投地。最后这60秒之内，阙剑宇究竟能不能打破吉尼斯世界记录呢？时间在一秒一秒钟过去。</p>
<p>只剩下20秒，倒计时颜色变红，红的跟血一样，让人热血沸腾。时间的闪烁疯狂了起来，我倒吸了一口凉气。</p>
<p>当阙剑宇抛、拨动作噶然停止，屏幕显示还剩下13秒钟。神童提前结束了挑战任务，到底成功与否呢？我的心已经卡在嗓子眼了。</p>
<p>“阙剑宇，你刚才挑战的是抛接还原魔方，获得了最短时间的吉尼斯世界荣誉，你的最终成绩是5分06秒61。这是一项新的吉尼斯世界纪录！”认证官当场宣布。</p>
<p>哇！全场为之欢呼沸腾，我被挑战者精彩绝技折服了，不敢相信的事情变成了现实。我相信阙剑宇的成功不仅仅来源于天赋，最重要的是背后无言的努力与付出！这是一次成功和精彩的挑战，让我难忘。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>教你过关吾爱破解游戏《圈小猫》</title>
    <url>/posts/32831/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我刚结识<a class="link"   href="https://wwww.52pojie.cn/" >吾爱破解<i class="fas fa-external-link-alt"></i></a>网站，就认识了网站的隐藏游戏《圈小猫》。我把《圈小猫》这个游戏吹爆——这个游戏确实好玩，但这是只有<strong>像我一样聪明的人</strong>才能玩得起的游戏。</p>
<p>因此，这篇文章将会教你如何篡改这个游戏，实现任何人，局局都能赢（如果说逆向这个游戏，未免有些太夸张了）。如果，你以前玩游戏的时候，小猫局局都逃掉，那么这一次你就可以痛打它了。</p>
<a id="more"></a>
<h1 id="游戏介绍"><a href="#游戏介绍" class="headerlink" title="游戏介绍"></a>游戏介绍</h1><p>如果你已经是《圈小猫》的忠实玩家，可以忽略这部分。</p>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><p>这个游戏的打开方式都知道了吧！你只要在主站的URL后面随便输入一些可以让吾爱404的东西，就可以打开这个游戏。就像这样：</p>
<ul>
<li><a class="link"   href="https://www.52pojie.cn/1234567890" >https://www.52pojie.cn/1234567890<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.52pojie.cn/awdihgfbnkd" >https://www.52pojie.cn/awdihgfbnkd<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.52pojie.cn/helloworld" >https://www.52pojie.cn/helloworld<i class="fas fa-external-link-alt"></i></a></li>
<li>…</li>
</ul>
<h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><ul>
<li>点击小圆点，围住小猫；</li>
<li>你点击一次，小猫走一次；</li>
<li>直到你把小猫围住（赢），或者小猫走到边界并逃跑（输），游戏结束。</li>
</ul>
<h1 id="了解源码"><a href="#了解源码" class="headerlink" title="了解源码"></a>了解源码</h1><p>你或许不知道，这个游戏不是吾爱破解编写的，而是GitHub上的一个开源项目：<a class="link"   href="https://github.com/ganlvtech/phaser-catch-the-cat" >phaser-catch-the-cat<i class="fas fa-external-link-alt"></i></a>，作者是<a class="link"   href="https://github.com/ganlvtech" >glanvtech<i class="fas fa-external-link-alt"></i></a>。游戏的思路和小猫的图片来源于 <a class="link"   href="https://www.gamedesign.jp/" >GameDesign<i class="fas fa-external-link-alt"></i></a>，原来的游戏名叫 Chat Noir，原作者只是尝试用 JavaScript 重写一遍。</p>
<h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>我们先进入仓库，看一下README（下文是节选）：</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>首先引入游戏框架 <code>phaser.min.js</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后引入游戏代码 <code>catch-the-cat.js</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在指定的 <code>div</code> 中新建一个游戏的 <code>canvas</code>，并开始游戏：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
    window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
        h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
        r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
        backgroundColor<span class="token operator">:</span> <span class="token number">0xeeeeee</span><span class="token punctuation">,</span>
        parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
        statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
        credit<span class="token operator">:</span> <span class="token string">'github.com/ganlvtech'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>CatchTheCatGame</code>的参数列表如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>w</code></td>
<td align="center">11</td>
<td align="left">横向格子数</td>
</tr>
<tr>
<td align="center"><code>h</code></td>
<td align="center">11</td>
<td align="left">竖向格子数</td>
</tr>
<tr>
<td align="center"><code>r</code></td>
<td align="center">20</td>
<td align="left">圆半径像素</td>
</tr>
</tbody></table>
<p>非必选参数如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>backgroundColor</code></td>
<td align="left"><code>0xeeeeee</code></td>
<td align="left">背景颜色</td>
</tr>
<tr>
<td align="left"><code>parent</code></td>
<td align="left"><code>catch-the-cat</code></td>
<td align="left">父元素的 <code>id</code> 或 <code>DOM</code> 对象</td>
</tr>
<tr>
<td align="left"><code>statusBarAlign</code></td>
<td align="left"><code>center</code></td>
<td align="left">状态栏左对齐 <code>left</code> 或居中 <code>center</code></td>
</tr>
<tr>
<td align="left"><code>credit</code></td>
<td align="left"><code>github.com/ganlvtech</code></td>
<td align="left">右下角的备注信息</td>
</tr>
</tbody></table>
<h3 id="自定义算法"><a href="#自定义算法" class="headerlink" title="自定义算法"></a>自定义算法</h3><p>参考<a href="https://github.com/ganlvtech/phaser-catch-the-cat/tree/master/src/solvers"><code>src/solvers/</code></a>中提供的例子编写算法，并使用下列代码替换。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span>solver <span class="token operator">=</span> yourSolver<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个 <code>solver</code> 的返回值即为猫要往哪个方向走一步，如果撞墙，则算玩家获胜。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-1</td>
<td align="left">猫主动弃权</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">左</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">左上</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">右上</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">右下</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">左下</td>
</tr>
</tbody></table>
<p>如果猫站在星号的位置，那么数字代表每个方向的编号：</p>
<pre class="line-numbers language-none"><code class="language-none">1 2
0 * 3
5 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>下面的例子可以让猫的每一步都向左走，直到撞墙：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p>既然知道了《圈小猫》的代码结构与自定义算法的编写，那我们就可以上代码了！</p>
<p>首先，我们要引入游戏脚本。获取脚本有如下方式：</p>
<ul>
<li>你可以在项目的<a class="link"   href="https://github.com/ganlvtech/phaser-catch-the-cat/releases" >Release 界面<i class="fas fa-external-link-alt"></i></a>下载；</li>
<li>你也可以引用吾爱的脚本链接：<a class="link"   href="https://down.52pojie.cn/.fancyindex/js/phaser.min.js" >phaser.min.js<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://down.52pojie.cn/.fancyindex/js/catch-the-cat.js" >catch-the-cat.js<i class="fas fa-external-link-alt"></i></a>。不过吾爱可能开启了防盗链，在我的<code>html</code>里无法引用。</li>
</ul>
<p>然后在文件中引入并且设置编码<code>utf-8</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其次，写一个<code>body</code>，里面添加一个<code>div</code>和一组<code>script</code>标签：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
       
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>script</code>里仿照吾爱源码的设置编写<code>JavaScript</code>：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，仿照<code>README</code>文件编写自定义走步算法。我把游戏的<code>solver</code>属性设置为-1，这样一上来猫会主动弃权：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>总的来说，你的代码应该长这样（注<code>script</code>引用有能力的也可替换为网址，我这不知为何引用不了网址）：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后，用浏览器打开，预览感受一下，猫咪不管身处何处，只要我在地图上随便点一个墙，猫咪就自动放弃了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/52-catgame.gif" alt="效果"></p>
<h1 id="修改浏览器代码"><a href="#修改浏览器代码" class="headerlink" title="修改浏览器代码"></a>修改浏览器代码</h1><p>我们先复制刚才编写的这段代码：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们进入浏览器，开一局《圈小猫》，之后我们按下F12、Ctrl + Shift + I或Cmd + Option + I打开网页审查元素（就是所谓的控制台），然后定位到图中的位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/3/28/hop-catgame-browser.jpg" alt="定位代码"></p>
<p>然后双击这行代码，或者右键 &gt; 编辑 HTML，将我们刚刚复制的代码粘贴进去。之后，就享受痛打猫咪的感觉吧——</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/52-catgame.gif" alt="效果"></p>
<p>……怎么突然感觉游戏没意思了！？</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行之美不在风景，在于人乎</title>
    <url>/posts/46252/</url>
    <content><![CDATA[<p>旅游对于小孩子来说是很开心的事，因为可以甩下一大堆让人头疼的作业，可以去那些没有去过的地方走走逛逛，甚至还可以和平日的小伙伴一路同行，一路欢歌欢闹。</p>
<p>旅游对于我们来说不在乎有没有风景，而在乎有没有玩伴，暑假我的同学辰辰就带给我一段快乐之行。</p>
<p>行程中我们俩在床上翻跟斗，还用一个电脑研究编程，路上坐在车里玩数学手指游戏，我们不仅给美景拍照，还给小动物小昆虫拍照。我们孩子旅行游记的主角很另类，是一只可爱的蜗牛和一只刚会蹦的宝宝青蛙。</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/snail-thumb.jpg" alt="snail-thumb" style="zoom:150%;" />

<p>这是一只大鸣大放在路上散步的蜗牛，虽然它穿着跟石灰地一样颜色的衣服，掉在路上就像掉个黑芝麻一样不显眼，但还是被我和辰辰敏锐的近视眼发现了，我们用手机录下了蜗牛优雅漫步的身姿。这只蜗牛的表现简直可以入选《国家地理》的封面了。</p>
<p>瞧！它昂首挺胸，威仪十足，丝毫不惧我们的闪光镜头，俨然像个见过大世面的王者。</p>
<p>宝宝青蛙是我和他发现的另外一个小可爱，它也许刚刚进化成功，只有一角硬币那么大，蹦起来特别灵活，小青蛙跳到哪我和同学就跳到哪。看到青蛙小小年纪，身手如此不凡，一个人没有爸爸妈妈和同类陪伴去闯世界，我一方面担心一方面又由衷地赞叹。</p>
<p>一路旅行，很多景色都淡忘了，我和同学在车里玩的手指游戏和小蜗牛、小青蛙却还是记忆犹新。</p>
<p>旅游之美真的不在景，因为有同学的陪伴，才有了旅行中更多的快乐。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>爆胃的开花肠</title>
    <url>/posts/11466/</url>
    <content><![CDATA[<p>土门关驿道小镇不仅古香古色，而且小镇里各种民间饭铺更是让人目不暇接，大开胃口。这些小店铺干净且有特色，虽然没有高大上的门面，却充满了浓厚的乡土气息，这里的美食吸引了众多游人。</p>
<a id="more"></a>
<p>走在驿道小镇深长的巷子里，各种香味阵阵扑来，一时我隐隐约约感觉到一股诱人的奇香，越走那股香味就越浓。大约走了50米，果然看到了一家小小的香肠店铺——那美妙的香味就是从这里飘来的。</p>
<p>只见店铺前的几张桌子，都已经坐满了品尝香肠的游客。铺外摆放着一个大铁盘，上面放满了许多让人嘴馋的香肠，它们都是手工制作而成的，不添加任何色素。这家店铺的香肠有个好听的名字，叫“开花肠”。</p>
<p>开花肠看上去和城里的香肠很不一样：城里超市卖的各类香肠就像是一个个孤零零的“光棍”，而这里卖的开花肠，不仅个头比城里普通香肠粗了两倍，特别有派头，而且开花肠不像城里香肠，表面只有单一的肉色，表皮也不是那种一贯的光滑，开花肠看上去表面稍微粗糙。成品肠裹上五花八门的调料，再配上从香肠侧面切开而成的“花瓣”，造型实在别具一格。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/sausage-thumb.png" alt="开花肠"></p>
<p>我迫不及待地挤过去，买了一根开花肠。没料到价格竟然比市里的贵出5倍，15元一根！付了钱后，厨师叔叔便在盘子里拿了一根已经做好模型的生肠，往大油锅里一丢，炸到金黄透亮、花瓣卷曲了的时候，叔叔就用大夹子将香肠拣出来，往上面撒上叫不上名的调料，再放到一个防油的特制褐色牛皮纸卷里，开花肠就做好了。</p>
<p>我接过它，手里的开花肠就像是一件艺术品。黄色的调料、赤色的肠身、焦黄的“花瓣”……各种颜色错落很有层次；出锅的味道麻醉着我的鼻腔，辣香的、油香的、肉香的、咸香的……“十三”香的，绝对称得上色味俱佳。香肠拿在手里都是一种享受！更奇妙的是它入口的感觉。</p>
<p>我大口大口地吹着腾腾热气，小心地把开花肠凑到嘴边，用门牙轻轻试探香肠入口是否烫嘴，还没吃到呢，就有了飘飘欲仙的感觉。一点一点地咬，香味在嘴里散开，有可口的咸甜味、辛辣的胡椒味、浓浓的五香味……每一丝味道都在刺激着我的味蕾，不折不扣的纯粹肉香让我陶醉。</p>
<p>皮儿酥里嫩，香得让我停不住嘴——吃完第一根想着第二根，吃完第二根想着第三根，吃完第三根想着第四根……不一会，开心肠实实在在地进到肚里，香味从嘴里也跑到了胃里。</p>
<p>真没想到小小的香肠能勾起了那么多吃惯大餐的城里人的胃口，也让我这个对肉食不屑一顾的人吃胖了胃。可见独特的美食藏在民间，不一定五星酒店的东西才是天下无敌。啊，爆胃的开花肠！</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>硬核输密码</title>
    <url>/posts/a942e651/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写文章了，今天输出一篇。首先，为了防止误判我是标题党，先解释一下在这篇文章里我要做什么。</p>
<p>以前我在<a class="link"   href="https://www.52pojie.cn/thread-1132170-1-1.html" >《【Mac】一次意外的 CleanMyMac X 破解》<i class="fas fa-external-link-alt"></i></a>里破解过CleanMyMac X（注：这篇帖子已被移动），但是最近CleanMyMac X更新，所以我便把旧版本的CMM删除了，下载了新版本4.6.7的CMM。结果不破不知道，一破吓一跳，动态库注入破解，破解倒是成功了，但是可能因为签名等问题，CMM总会在清理时不断地让我输入root密码，获取我的权限，尽管我已经赋予了CMM完全磁盘访问权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/6/29/pwd-enter-box.jpg" alt="不断要求输入密码"></p>
<p>尝试过的解决方法：</p>
<ul>
<li><del><code>codesign -f -s - --deep /Applications/CleanMyMac\ X.app</code></del></li>
<li><del><code>AppleScript</code></del></li>
<li><del>每一次都手动输一遍密码</del></li>
<li><del>更换破解框架</del></li>
</ul>
<p>都不行。所以我准备写一段<code>Python</code>脚本，模拟键盘和鼠标，每当输入密码框弹出来时，自动输入密码并确认，你可以理解为一个轻量级的按键精灵。</p>
<h1 id="0x1-编写代码"><a href="#0x1-编写代码" class="headerlink" title="0x1 编写代码"></a>0x1 编写代码</h1><p>首先使用<code>pip install pyuserinput</code>安装<code>PyUserInput</code>，然后导入。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pymouse import PyMouse
from pykeyboard import PyKeyboard

# 定义键盘和鼠标实例
m &#x3D; PyMouse()
k &#x3D; PyKeyboard()

def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)):
    &#39;&#39;&#39;
    将输入密码流程封装成函数
    &#39;&#39;&#39;
    global m, k
    m.click(pos[0], pos[1])
    k.type_string(pwd)
    m.click(enter_bt_pos[0], enter_bt_pos[1])

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    enter_pass(pwd&#x3D;&quot;password123&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中输入框位置(1322, 705)和确认键位置(1425, 759)是我通过macOS自带的截图工具<kbd>Command+Shift+5</kbd>获取的。</p>
<p>之后我们打开CMM，选择操作&gt;身份验证，然后会弹出一个“安装帮助程序”的弹窗，运行脚本——你会发现，确认键成功被点击，但是脚本却没有成功输入密码。</p>
<h1 id="0x2-绕过漏洞"><a href="#0x2-绕过漏洞" class="headerlink" title="0x2 绕过漏洞"></a>0x2 绕过漏洞</h1><p>研究了一番后，发现输入密码弹框属于系统层程序，因此无法模拟键盘输入（顺便提一下，<code>PyUserInput</code>是通过<code>pyobjc</code>调用<code>Objective-C</code>代码模拟的）。又试了试，发现密码弹窗有一个漏洞，那就是可以进行粘贴操作（不能复制）。怎么办呢？我们的新思路就是使用<code>pyperclip</code>框架先复制密码，然后点击文本框，再模拟键盘进行<kbd>Command+V</kbd>粘贴操作。</p>
<p>代码改写如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pymouse import PyMouse 
from pykeyboard import PyKeyboard 
import pyperclip as clip 
 
m &#x3D; PyMouse() 
k &#x3D; PyKeyboard() 
 
def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)): 
    global m, k 
    clip.copy(pwd) 
    m.click(pos[0], pos[1]) 
    k.press_keys([&#39;Command&#39;, &#39;V&#39;])  # 快捷键组合函数
    m.click(enter_bt_pos[0], enter_bt_pos[1]) 
 
if __name__ &#x3D;&#x3D; &#39;__main__&#39;: 
    enter_pass(pwd&#x3D;&quot;password123&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="0x3-优化速度"><a href="#0x3-优化速度" class="headerlink" title="0x3 优化速度"></a>0x3 优化速度</h1><p>上面的脚本运行后发现一切很好，但是太慢，原因是<code>pyperclip.copy()</code>占用的时间太长。怎么办呢？我便把<code>clip.copy(pwd)</code>改成了：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if not clip.paste() &#x3D;&#x3D; pwd:
    clip.copy(pwd)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>检测剪贴板和密码是否相同，如果相同，就不复制了。效果还不错呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/6/29/pwd-enter-vid.gif" alt="效果"></p>
<h1 id="0x4-检测弹窗"><a href="#0x4-检测弹窗" class="headerlink" title="0x4 检测弹窗"></a>0x4 检测弹窗</h1><blockquote>
<p><strong>你坑谁呢？难道每一次弹出密码窗口时我都要运行一遍脚本？</strong></p>
</blockquote>
<p>对于以上问题，我准备使用<code>PIL.ImageGrab</code>来不断捕捉屏幕，如果识别到弹窗，再运行<code>enter_pass:pos:enter_bt_pos:</code>函数。代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import ImageGrab
from pymouse import PyMouse 
from pykeyboard import PyKeyboard 
import pyperclip as clip 
 
m &#x3D; PyMouse() 
k &#x3D; PyKeyboard() 
 
def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)): 
    global m, k 
    if not clip.paste() &#x3D;&#x3D; pwd: 
        clip.copy(pwd) 
    m.click(pos[0], pos[1]) 
    k.press_keys([&#39;Command&#39;, &#39;V&#39;]) 
    m.click(enter_bt_pos[0], enter_bt_pos[1]) 
 
if __name__ &#x3D;&#x3D; &#39;__main__&#39;: 
    print(&quot;Start grabbing:&quot;) 
    while True: 
        screen &#x3D; ImageGrab.grab().convert(&#39;RGB&#39;) # 捕捉屏幕
        print(f&quot;Screen grabbed.&quot;) 
        colorls &#x3D; screen.load() # 加载数据
        # 判断像素
        if colorls[2222, 1478] &#x3D;&#x3D; (236, 236, 236) and colorls[2153, 1206] &#x3D;&#x3D; (236, 236, 236):
            # 输入密码
            enter_pass(pwd&#x3D;&quot;password123&quot;)
            print(&quot;Password entered.&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，我们的自动填充密码脚本便编写完了。</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import ImageGrab
from pymouse import PyMouse
from pykeyboard import PyKeyboard
import pyperclip as clip

m &#x3D; PyMouse()
k &#x3D; PyKeyboard()

def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)):
    global m, k
    if not clip.paste() &#x3D;&#x3D; pwd:
        clip.copy(pwd)
    m.click(pos[0], pos[1])
    k.press_keys([&#39;Command&#39;, &#39;V&#39;])
    m.click(enter_bt_pos[0], enter_bt_pos[1])

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    no_passbox_count &#x3D; 0
    idx &#x3D; 1
    print(&quot;Start grabbing ------&quot;)
    while True:
        if no_passbox_count &gt; 4: break
        screen &#x3D; ImageGrab.grab().convert(&#39;RGB&#39;)
        colorls &#x3D; screen.load()
        if colorls[2222, 1478] &#x3D;&#x3D; (236, 236, 236) and colorls[2153, 1206] &#x3D;&#x3D; (236, 236, 236)
            enter_pass(pwd&#x3D;&quot;password123&quot;)
            print(&quot;Password entered.&quot;)
            no_passbox_count &#x3D; 0
        else:
            no_passbox_count +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行此<code>Python</code>脚本，之后启动 CleanMyMac X 清理，你就能看到脚本自动为你输密码的壮观景象了。由于截图时延迟比较大，在1秒左右，因此清理运行下来大概需要五分钟……</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>还是<del>去下载别人家的破解</del>买正版软件更好 : )</p>
<blockquote>
<p>如果贴友们有更好的方法解决 CleanMyMac 频繁让输入密码的问题（例：<code>codesign</code>），请跟帖留言。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>网站说明书</title>
    <url>/posts/32480/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是我的个人博客网站，与2020年1月28日建成并发布。其中，我导入了一些我以前写的的优秀作文，撰写了与现在编程与反编译相关的技术文章。在这个网站中，我会给大家呈现出我的最好内容，也会分享一些好文章。博客网站是一个很有趣的东西，有了它，就有了生活感；有了它，就有了时间感；有了它，就有了幸福感；有了它，就有了存在感。</p>
<a id="more"></a>
<p>我离开了我的诸多博客，创建一个自己的网站，现在正式来到这里，发布第1篇（文章其实是第二篇，第一篇是关于自我介绍的）。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我从没有博客开始，搬家到微信朋友圈（更专注生活），再搬到<a href="zi.com">字里行间</a>软件（专注于写作），再搬到<a href="csdn.net">CSDN</a>（专注于研究技术），原本想定居于此，但是最近发布了一个关于破解（反编译）的技术文章，审核却没有通过，因为CSDN出的新规“暂时不允许发布破解、激活类的文章”。这样也有道理，毕竟要保护开发者的版权，避免一些人看了这些文章误入歧途，做起盗版。CSDN帮助我提升计算机技术水平，我感谢CSDN，但是这条规定却不能给我自由的空间——我想，我应该搬家了。</p>
<p>我想把博客搬到<a href="52pojie.cn">吾爱破解</a>，但是还需购买邀请码；我想把博客搬到<a href="jianshu.com">简书</a>，但是养一个账号太难；我想把博客搬到<a href="blog.sina.com.cn">新浪</a>，但是根本就无法与VIP竞争；我想……无论是什么网站，都与自己的心愿差那么一点点。因此，我选择了自己建一个博客。这不仅可以提高我的写作水平，还可以练一下自己的技术。</p>
<h1 id="反馈与改进"><a href="#反馈与改进" class="headerlink" title="反馈与改进"></a>反馈与改进</h1><p>人外有人，天外有天。这个博客肯定多多少少有一些缺陷，欢迎联系我，批评指正。可能是关于：</p>
<ul>
<li>  界面不美观；</li>
<li>  界面不协调，布局不恰当；</li>
<li>  界面互动不好；</li>
<li>  文章内容需要改进；</li>
<li>  图片过期、显示不清、无法显示、显示缓慢；<br>以上只是列了几条批评指正或提出建议的方面。坐在屏幕前的你，看到哪里不顺眼，也欢迎告诉我原因、吐槽一番。</li>
</ul>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><ul>
<li>无论任何人使用文章中分享的任何技术，做任何事，所造成的刑事责任，请自行承担。</li>
<li>博客中的任何文章及其内容，仅供学习、研究、参考使用，请勿商用，否则造成的刑事责任，请自行承担。</li>
<li>博客中涉及到反编译、破解的内容，尽量进行数据脱敏处理，并旨在教会读者破解方法与心得。除特殊情况，破解后的程序不提供成品下载。</li>
<li>本博客所有文章除特别声明外，均采用<a class="link"   href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" >CC BY-SA 3.0<i class="fas fa-external-link-alt"></i></a>协议。如需转载可以联系我。文章可否转载一般会在文章中标注。</li>
</ul>
<p>最后，欢迎来到我的博客。</p>
<pre class="line-numbers language-none"><code class="language-none"> _   _      _ _    __        __         _     _
| | | | ___| | | __\ \      &#x2F; &#x2F;__  _ __| | __| |
| |_| |&#x2F; _ \ | |&#x2F; _ \ \ &#x2F;\ &#x2F; &#x2F; _ \|  __| |&#x2F; _&#96; |
|  _  |  __&#x2F; | | (_) \ V  V &#x2F; (_) | |  | | (_| |
|_| |_|\___|_|_|\___&#x2F; \_&#x2F;\_&#x2F; \___&#x2F;|_|  |_|\__,_|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>PS：如果看不清楚上面写的是什么，可以在电脑观看。  </p>
</blockquote>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>说明文</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次用 Hopper 破解迅雷</title>
    <url>/posts/19263/</url>
    <content><![CDATA[<blockquote>
<p>破解目标：迅雷v3.0.9，登陆即是会员！  </p>
</blockquote>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>这也不是第一次想着进行破解二进制了。以前用过IDA、OD、010等软件，才知道，破解既困难，又有趣。</p>
<p>为什么我要用Hopper Disassembler进行破解？因为Hopper是一款针对Mac&amp;Unix类系统的破解软件；那为什么又要选择迅雷呢v3.0.9.2892？我浏览过迅雷的所有版本，只有这个版本的迅雷是一个难度适中、易破解、成就感高而又实用的App。所以，今天写一篇破解迅雷v3.0.9的详细笔记，分享给大家。</p>
<a id="more"></a>
<p>但是——也确实是这样——总有那么些人通过不法方式修改别人的东西，我就很讨厌这类人。因此，<strong>此篇文章仅供研究学习，切勿商用或者广泛传播，否则后果自负</strong>！</p>
<blockquote>
<p>注：网站里的图片点开即可查看大图。</p>
</blockquote>
<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><ol>
<li> <a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler<i class="fas fa-external-link-alt"></i></a>，逆向工程工具，可让反汇编，反编译和调试应用程序。以下Hopper Disassembler简称HDA。</li>
<li>迅雷（Thunder）v3.0.9.2892。以下迅雷简称XL。<a class="link"   href="http://down.sandai.net/mac/thunder_3.0.9.2892.dmg" >官方下载链接<i class="fas fa-external-link-alt"></i></a></li>
<li>一台Mac或iMac，能不用虚拟机就不用。最好是MacOS Catalina，为了保证HDA与XL的正常运行。（其实HDA也有Linux版本，但在虚拟机下不太好使）</li>
<li>思路清晰且冷静的大脑。</li>
</ol>
<h1 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h1><h2 id="导入分析"><a href="#导入分析" class="headerlink" title="导入分析"></a>导入分析</h2><p>首先，我们从应用程序里找到<code>Thunder</code>这个App，右键——显示包内容，之后进入目录<code>/Contents/MacOS</code>，可以找到<code>Thunder</code>这个可执行文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/find-exec.png" alt="查找可执行文件"></p>
<p>这个可执行文件包括着整个App的运行逻辑、顺序、程序等等内容，但是不包括应用的资源。这个文件就是应用运行的关键，也是我们破解的关键。</p>
<p>接下来，我们打开HDA。进入应用界面后，把可执行文件拖拽到界面的中间部分。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-drag-analysis.png" alt="拖动"></p>
<p>接下来，HDA会弹出提示，保持默认，一路OK即可。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-warning.png" alt="提示框"></p>
<p>等着进度条走完（观察窗口右下角的<code>Working</code>字样）。像迅雷这样的小软件，2秒钟就够了。接下来，一幅宏伟壮丽的景象会出现在你眼前。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-main-ui.png" alt="主页面"></p>
<p>这是HDA的主页面。分为5个部分：上面是工具条：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-toolbar-usage.png" alt="工具条用法"></p>
<p>左边是搜索区，可以搜索函数、字符串、星标代码等；中间是主要工作区域，里面包含的内容可以通过工具条中按键调整；右边是检索区，可以设置/预览中间的内容，跟Xcode的检索区差不多；下面是Python控制台，可以输入命令操作反编译。</p>
<p>就先不多讲HDA的使用了，有机会放在别的文章阐述。接下来，进入主题，开始破解！</p>
<h2 id="查找可能的函数"><a href="#查找可能的函数" class="headerlink" title="查找可能的函数"></a>查找可能的函数</h2><p>迅雷想要验证是否是会员，肯定得有函数。按照程序猿千古流传的命名习惯，不用想就猜得到函数名：<code>isVip</code></p>
<p>打开HDA左边的搜索栏，上面的选择器选<code>Proc.</code>，就是搜索函数。然后搜索<code>isVip</code>，搜索出来，完全包含这个名字的函数有三个：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/search-isvip.png" alt="搜索 isvip"></p>
<p>我们先点开第一个（汇编指令区就会出现），然后在蓝色的那一栏单击，标“星”，方便以后查找。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/choose-and-add-star.png" alt="标星"></p>
<p>接着，点开剩下两个，进行同样的标“星”操作。注意看图中的标“星”位置。<br>现在，清空搜索框，然后在选择其中选择“星”：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-star-func.png" alt="选择标星的一栏"></p>
<p>好了！查找完了！</p>
<h2 id="汇编思路"><a href="#汇编思路" class="headerlink" title="汇编思路"></a>汇编思路</h2><p>首先点开第一个（一长串的），然后参照<code>按键作用解释</code>那幅图，打开伪代码。类似OC伪代码应该如下：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class ___4X2XLXH3O3STBRATSECONDT7R3OL4L34E1R___ *&#x2F;
-(char)isVip &#123;
    rbx &#x3D; [[UserController defaultUserController] retain];
    r14 &#x3D; [rbx isVip];
    [rbx release];
    rax &#x3D; sign_extend_64(r14);
    return rax;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然我不太懂OC，但是大致可以看出是一个函数，最后返回了<code>rax</code>。那<code>rax</code>是什么？</p>
<blockquote>
<p>AX(AH、AL)：累加器。有些指令约定以AX(或AL)为源或目的寄存器。输入/输出指令必须通过AX或AL实现，例如：端口地址为43H的内容读入CPU的指令为INAL，43H或INAX，43H。目的操作数只能是AL/AX，而不能是其他的寄存器；<br>BX(BH、BL)：基址寄存器。BX可用作间接寻址的地址寄存器和基地址寄存器，BH、BL可用作8位通用数据寄存器；<br>CX(CH、CL)：计数寄存器。CX在循环和串操作中充当计数器，指令执行后CX内容自动修改，因此称为计数寄存器；<br>DX(DH、DL)：数据寄存器。除用作通用寄存器外，在1/O指令中可用作端口地址寄存器，乘除指令中用作辅助累加器；<br>EAX、ECX、EDX、EBX：ax、bx、cx、dx的延伸，各为32位元。  </p>
</blockquote>
<p>那么，这个函数最终会被<code>return rax</code>，而rax是真是假取决于账号，怎么办呢？思路：我们只需强制把<code>rax</code>换成真（代表着用户是会员），然后终止下面的进程就可以了！</p>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><ol>
<li> 把光标放在第一行（<code>push</code>的位置），按下<kbd>option</kbd>+<kbd>a</kbd>（或者到顶部Modify &gt; Assemble Instruction），输入如下代码：<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>为什么这样改：mov是数据转移指令，这个操作会把0x1这个数据转移给rax，这样rax就被我们强制设为真了。  </p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-1.png" alt="修改1"></p>
<ol>
<li> 回车，输入<code>ret</code>。<br>为什么这样改：<code>ret</code>是<code>return</code>的缩写，意为“结束子程序并返回到主程序“，因此，这下面其他的乱七八糟的没用指令都不会运行了。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-2.png" alt="修改2"></p>
<ol start="2">
<li> 点击屏幕任意地方，关掉修改弹窗。下图为修改后：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-changed.png" alt="修改后"></p>
<p>这样，这个函数就被我们修改完了！用同样的方法，把剩下两个函数也修改成这样（patch）即可。</p>
<h2 id="有自校验，但是一碰就碎"><a href="#有自校验，但是一碰就碎" class="headerlink" title="有自校验，但是一碰就碎"></a>有自校验，但是一碰就碎</h2><p>自校验，顾名思义就是自己看自己，有没有什么毛病。程序当然也会这样啊，如果看到自己的五脏六腑都移位了，就不会给你运行。当然，还有许多程序保护机制，比如防<code>hook</code>、反调试。</p>
<p>接下来我们就要关闭这个系统。首先，做过苹果开发的都知道，在程序启动将要完成时，<code>AppDelegate</code>中的<code>applicationWillFinishLaunching</code>函数会运行。也就是说，迅雷想要启动时自检，必须通过这个函数。我们只要把这个函数里的脚本禁了就行了。</p>
<p>老样子，搜索<code>appdelegate applicationWillFinishLaunching</code>（无需区分大小写）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-search-anticrack.jpg" alt="搜索校验"></p>
<p>单击打开，然后选择函数的第一行，<kbd>option</kbd>+<kbd>a</kbd>修改，直接输入<code>ret</code>禁用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-anticrack.png" alt="修改自校验"></p>
<p>修改后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-changed-anticrack.png" alt="去除自校验代码"></p>
<p>——一碰就碎！</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ol>
<li><p> 按下<kbd>control</kbd>+<kbd>shift</kbd>+<kbd>E</kbd>。</p>
</li>
<li><p> 在新弹出的窗口中，选择<code>Remove Signature</code>移除签名。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-rm-sign.png" alt="移除签名"></p>
<ol start="3">
<li> 在接下来的提示小窗中，选择保存位置，名字还是<code>Thunder</code>，如果Hopper给你加了类似<code>.exe</code>的后缀，那么一定要<strong>去掉后缀名</strong>！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-save-exec.png" alt="保存"></p>
<ol start="4">
<li> 用新的可执行文件替换掉旧的<code>Thunder</code>。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-exec-replace.png" alt="替换"></p>
<p>经过了这么多的操作，替换成功！</p>
<h1 id="破解完工"><a href="#破解完工" class="headerlink" title="破解完工"></a>破解完工</h1><p><strong>以非VIP的身份登陆迅雷</strong>，验证成果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-xl-crack-done-1.png" alt="破解成功1"><br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-xl-crack-done-2.png" alt="破解成功2"></p>
<p><strong>欢呼吧！</strong></p>
<blockquote>
<p><strong>此篇文章仅供研究学习，旨教给读者修改程序的方法，切勿商用或者广泛传播，否则后果自负！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>认识藏在石头里的村子</title>
    <url>/posts/1371/</url>
    <content><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>在太行山脉的深处，藏着一处小山村，它被绿树掩映，被山峦环抱。弯弯曲曲的山路带着我们来到村子里，哇！这是石头的世界。</p>
<a id="more"></a>
<p>石楼石阁，石房石院，石桌石凳，石磨石碾，石街石巷，石桥石栏，就连村路也是古老的石头铺成的，走在上面，既新鲜好奇又畅快淋漓。小村庄就是与众不同……</p>
<p><img src="https://i.loli.net/2020/01/29/xt6QNTCAsISXd8v.jpg" alt="石头村留念"></p>
<p>石头巷子，幽深宁静，一株柿子树从院子探出头来。斑驳的石缝里镶嵌着一撮撮青苔，深绿的、浅绿的、茂盛的、干枯的。不太规整的石头，一块块垒砌便成了墙，高高的，不知道什么年代啦，反正时间离我很远很远了。</p>
<p>石碑，石阶，石桌随处可见。对联、牌匾上烙着时间的印记。大门上灰瓦搭成的飞檐顶很漂亮，特别有乡土气息，拱形门洞即可通行，又可躲在那里乘凉，不同形状和大小的石头堆在一起，那么的严丝合缝和坚固，上面的石阁历经久远，风吹雨打巍然矗立。</p>
<p>一座座石屋石院亲切而古朴，不会因为石头坚硬的质地让人感觉冰冷。于家石头村3700多米的六街七巷十八胡同，4000多间街巷串连的房屋全部都是石头的呈现。脚下踩的、屁股坐的、开荒农具、炊饮餐具、满眼看到的，都是石头做的。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>于氏石头村之行，还让我对石头有了广泛和新鲜的认识：</p>
<ol>
<li> 石头不仅可以铺路，还可以建造出独具特色的房子、院落、小桥……原以为石头必须切割才可以用做建筑，然而到了石头村才知道，用无需加工、形状不一、大小不同、颜色各异，或圆滑或棱角的石头们竟然可以造出这么坚固、历经几百年不倒的房子。</li>
<li> 石头可以谱写历史，流传文化。500年前明代重臣于谦的后人裔用朴实坚贞的石头，在荒野深山抒写下不朽的生存史诗。于家石头村，穿越岁月沧桑、代代相传，存活至今，用朴素的石头谱写了一部古村落史。</li>
<li> 石头有值得我们学习的品格和精神石——不加装饰，朴实无华；坚硬无比，历经风雨，不失本色。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过这次的行走，我认识到真正的价值往往蕴藏在平常和朴素之中，就像石头村。虽然石头遍山都是，寻常不稀有，虽然石头没有大理石漂亮的花纹，没有建筑木材的奢华，不被建筑师宠爱，但是石头村却因为石头而闻名，因石头其村落文化才得以传承。<strong>旅行真不必死死抓住风景名胜，只要留意，身边就有许多值得走访的地方。</strong></p>
<p>于氏石头村不愧是建立在石头上的历史文化村。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态库优雅破解 AppDelete</title>
    <url>/posts/22340/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我最近一直在寻找如何使用动态库注入的方法完美 Hook <code>macOS</code> 应用程序的方法。像<code>MonkeyAppMac</code>、<code>EasySIMBL</code>这样的框架都找遍了，可就是找不到真正的香格里拉——要么就是版本太低，要么就是缺少文档。</p>
<a id="more"></a>
<p>我刷飘云阁论坛时偶然看到了 tree_fly 大神原创的<a class="link"   href="https://www.chinapyg.com/forum.php?mod=viewthread&tid=82610&highlight=mac" >这篇帖子<i class="fas fa-external-link-alt"></i></a>，介绍了如何破解<code>AppDelete</code>。它真正让我明白了 <code>macOS</code> 动态库注入的工作原理与注入方法，然而文章有些地方写的却过于跳步、不尽人意。我<del>有感而发</del>，把原帖的某些地方改了改，将不容易理解的地方进一步解释，然后改编成这篇文章。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><a class="link"   href="http://www.reggieashworth.com/" >AppDelete<i class="fas fa-external-link-alt"></i></a>：<code>AppDelete</code>是Mac的卸载程序，不仅可以删除应用程序，还可以删除小部件，首选项窗格，插件和屏幕保护程序及其关联文件。 如果没有<code>AppDelete</code>，这些关联的项目将被留下来占用空间并可能引起问题。 下载完软件后没你可以先打开软件熟悉一下，</li>
<li>Hopper Disassembler v4</li>
<li>Xcode：此处用的版本是<code>Version 11.3.1 (11C504)</code>。</li>
</ul>
<h1 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h1><p>因为软件支持中文，所以我们可以通过字符串本地化文件来判断中文对应的英文。打开软件的资源目录中的中文目录：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;Applications&#x2F;AppDelete.app&#x2F;Contents&#x2F;Resources&#x2F;zh_CN.lproj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>找到本地中文资源文件 <code>Localizable.strings</code>，注意到如下信息：</p>
<pre class="line-numbers language-none"><code class="language-none">&quot;AppDelete Registration&quot; &#x3D; &quot;AppDelete 注册&quot;;
&quot;Registration Accepted&quot; &#x3D; &quot;接受注册&quot;;
&quot;Registration Rejected&quot; &#x3D; &quot;拒绝注册&quot;;
&quot;Register&quot; &#x3D; &quot;注册&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将软件载入Hopper，查找上面的英文字符串。通过寻找引用的方法（X），找到程序验证的核心：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class ADController *&#x2F;
&#x2F;* Address: 0x1000118add *&#x2F;
-(void)deletePaths:(void *)arg2 &#123;
    r14 &#x3D; [[self-&gt;plistOne stringValue] retain];
    r15 &#x3D; [[r14 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
    var_30 &#x3D; [r15 isEqualTo:@&quot;&quot;];
    [r15 release];
    [r14 release];
    var_38 &#x3D; self;
    r15 &#x3D; [[self-&gt;extensionMaster stringValue] retain];
    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
    rdx &#x3D; @&quot;&quot;;
    r14 &#x3D; [rbx isEqualTo:rdx];
    [rbx release];
    [r15 release];
    if (var_30 !&#x3D; 0x1) &#123;
            rdx &#x3D; @&quot;&quot;;
            if (r14 !&#x3D; 0x1) &#123;
                    r14 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                    rbx &#x3D; [[r14 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    rdx &#x3D; rbx;
                    r15 &#x3D; [var_38 orphansArray:rdx]; &#x2F;&#x2F; 1
                    [rbx release];
                    [r14 release];
                    if (r15 !&#x3D; 0x0) &#123;
                            &#x2F;&#x2F; 2
                            rbx &#x3D; [[NSBundle mainBundle] retain];
                            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Accepted&quot; value:@&quot;&quot; table:0x0] retain];
                            var_48 &#x3D; r15;
                            [rbx release];
                            intrinsic_movsd(xmm1, *double_value_0_607843);
                            intrinsic_movsd(xmm3, *double_value_1);
                            intrinsic_xorpd(xmm0, xmm0);
                            rax &#x3D; [NSColor colorWithCalibratedRed:@&quot;Registration Accepted&quot; green:@&quot;&quot; blue:r8 alpha:r9];
                            rax &#x3D; [rax retain];
                            rbx &#x3D; *ivar_offset(zipFiles);
                            [*(var_38 + rbx) setTextColor:rax, @&quot;&quot;];
                            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                            [var_38-&gt;zButton setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;qButton setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;plistOne setEnabled:0x0, @&quot;&quot;];
                            r15 &#x3D; *ivar_offset(extensionMaster);
                            [*(var_38 + r15) setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;helpP setEnabled:0x0, @&quot;&quot;];
                            r13 &#x3D; [[*(var_38 + r15) stringValue] retain];
                            rbx &#x3D; [[r13 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            var_40 &#x3D; [[rbx dataUsingEncoding:0x4, @&quot;&quot;] retain];
                            [rbx release];
                            [r13 release];
                            rbx &#x3D; [[NSUserDefaults standardUserDefaults] retain];
                            r12 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                            [rbx setObject:r12 forKey:@&quot;ADFieldOne&quot;];
                            [r12 release];
                            [rbx release];
                            rbx &#x3D; [[NSUserDefaults standardUserDefaults] retain];
                            [rbx setObject:var_40 forKey:@&quot;ADFieldTwo&quot;];
                            [rbx release];
                            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x1;
                            *(int8_t *)&amp;var_38-&gt;undoList &#x3D; 0x0;
                            [var_40 release];
                            [rax release];
                            rdi &#x3D; var_48;
                    &#125;
                    else &#123;
                            &#x2F;&#x2F; 3
                            r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
                            [rbx release];
                            [r15 release];
                            r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
                            [rbx release];
                            [r15 release];
                            rbx &#x3D; [[NSBundle mainBundle] retain];
                            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
                            [rbx release];
                            intrinsic_movsd(xmm0, *double_value_0_921569);
                            intrinsic_movsd(xmm3, *double_value_1);
                            intrinsic_xorpd(xmm1, xmm1);
                            r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
                            rbx &#x3D; *ivar_offset(zipFiles);
                            [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
                            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                            [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
                            [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
                            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
                            [r14 release];
                            rdi &#x3D; r15;
                    &#125;
            &#125;
            else &#123;
                    r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
                    [rbx release];
                    [r15 release];
                    r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
                    [rbx release];
                    [r15 release];
                    rbx &#x3D; [[NSBundle mainBundle] retain];
                    r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
                    [rbx release];
                    intrinsic_movsd(xmm0, *double_value_0_921569);
                    intrinsic_movsd(xmm3, *double_value_1);
                    intrinsic_xorpd(xmm1, xmm1);
                    r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
                    rbx &#x3D; *ivar_offset(zipFiles);
                    [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
                    [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                    [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                    [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
                    [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
                    *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
                    [r14 release];
                    rdi &#x3D; r15;
            &#125;
    &#125;
    else &#123;
            r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
            NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
            [rbx release];
            [r15 release];
            r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
            NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
            [rbx release];
            [r15 release];
            rbx &#x3D; [[NSBundle mainBundle] retain];
            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
            [rbx release];
            intrinsic_movsd(xmm0, *double_value_0_921569);
            intrinsic_movsd(xmm3, *double_value_1);
            intrinsic_xorpd(xmm1, xmm1);
            r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
            rbx &#x3D; *ivar_offset(zipFiles);
            [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
            [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
            [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
            [r14 release];
            rdi &#x3D; r15;
    &#125;
    [rdi release];
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><code>orphansArray:</code>函数应该是一个判断函数。如果你点进去，你可以看到函数声明中有严谨的判断流程；</li>
<li>如果代码执行到这里，那么就代表验证成功，可以使用App；</li>
<li>执行到这里，就是验证失败。</li>
</ol>
<p>此时如果你把<code>orphansArray:</code>的返回值修改为0x1：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那么你会发现软件运行、重启后，注册验证都通过了，同时注册按钮已经变灰，注册成功！你也可以根据<code>orphansArray:</code>的验证流程来写注册机。当然这些不是本篇文章的重点，接下来为大家介绍如何使用动态库注入来修改函数返回值。</p>
<h1 id="代码劫持"><a href="#代码劫持" class="headerlink" title="代码劫持"></a>代码劫持</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，在<code>Windows</code>下，很多时候我们在软件<code>.exe</code>同一目录下放置<code>version.dll</code>、<code>lpk.dll</code>等劫持文件，依照规则<code>.exe</code>优先加载了当前目录下<code>.dll</code>，可以偷偷摸摸做很多想做的事。</p>
<p>同理，在<code>macOS</code>下，思路是相同的，你可以想尽一切办法让App加载我们的动态库。加载完自定义的动态库，破解即成功。</p>
<h2 id="动态库编写"><a href="#动态库编写" class="headerlink" title="动态库编写"></a>动态库编写</h2><ol>
<li><p>首先，<a class="link"   href="xcode://" >打开Xcode<i class="fas fa-external-link-alt"></i></a>（你会神奇的发现如果你点击这个链接你的Xcode就会打开）。在<code>macOS</code>平台里选择 <code>Framework &amp; Library </code>&gt; <code>Library</code>。使用此模板新建一个项目，名称随便起，此处叫做<code>AppDeletePatch</code>，<code>Framework</code>选择<code>Cocoa</code>，<code>Type</code>选择<code>Dyamic</code>（动态）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ad-choose-temp.png" alt="选择模版"></p>
<p>这一步可以创建一个动态库工程。这个动态库就是我们要注入的动态库。</p>
<p>其次，我们打开<code>AppDeletePatch.m</code>文件。接下来我一步步带你编写动态库代码：</p>
</li>
<li><p>我们用两个<code>#import</code>语句，将<code>AppDeletePatch.h</code>文件与<code>objc/runtime.h</code>。<code>AppDeletePatch.h</code>文件（头文件），是每个<code>.m</code>文件里必须引用的。而<code>objc/runtime.h</code>库是什么？这就是很多小白不了解的地方之一。简单的解释，<code>runtime</code>是<code>C</code>类语言**”运行时”机制**的一个强大的库。通过这个库里的方法，可以在运行时实现对OC函数的 hook。</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &quot;AppDeletePatch.h&quot;
   #import &lt;objc&#x2F;runtime.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>现在，这两行代码明白了吧！</p>
</li>
<li><p>接下来，在两个引入语句的下面编写：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">@implementation AppDeletePatch



@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>Objective-C</code>语言中，可以使用<code>implementation</code>进行一个类的具体实现，类的实现代码以<code>@implementation</code>开始，以<code>@end</code>结束。这就类似于<code>Python</code>、<code>Swift</code>的<code>class</code>。<strong>这部分代码通常都是放在<code>.m</code>文件中</strong>。</p>
</li>
<li><p>然后，我们在<code>@implementation</code>的内部，声明一个函数：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (char)orphansArray:(NSString *)data &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 0x1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这又涉及了<code>OC</code>的语法，我们简单说一下。这样写，是实现了一个函数，函数名是<code>orphansArray:</code>。而冒号后面跟的是函数的参数列表<code>(NSString *)data</code>。这里声明了一个类型为<code>NSString</code>的参数<code>data</code>。而前面的<code>(char)</code>则代表函数的返回值。</p>
<p>如果你把原程序里<code>orphansArray:</code>的函数声明伪代码与这里的函数声明做对比，你会发现，这里的函数声明与原程序的函数声明一模一样。</p>
<p>你可能会疑问，函数前面的减号是干嘛的？类方法以<code>+</code>号开头，对象方法以<code>-</code>号开头。</p>
<p>函数里的两行代码就好解释了。<code>NSLog:</code>就是日志输出，相当于<code>Swift</code>和<code>Python</code>下的<code>print()</code>，这里我打印了一条信息以便记录；<code>return</code>就是返回的意思，此处返回了<code>0x1</code>一值。</p>
<p><code>orphansArray:</code>的实现就到此结束了。</p>
</li>
<li><p>在<code>orphansArray:</code>的实现后，空上几行，然后输入<code>load</code>。<code>Xcode</code>的自动补全功能会弹出列表。在列表第一行回车，之后在添上大括号：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">+ (void)load &#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个方法是干什么的？每当将类或类别添加到Objective-C的<code>runtime</code>时会被调用； 实现此方法以在加载时执行特定于类的行为。<code>load</code>方法的初始化顺序如下：</p>
<ol>
<li>您链接到的任何框架中的所有初始化程序。</li>
<li>图片中的所有<code> + load</code>方法。</li>
<li>图像中的所有<code>C++</code>静态初始化程序和<code>C</code> / <code>C ++</code> <code>__attribute __(constructor)</code>函数。</li>
<li>链接到您的框架中的所有初始化程序。</li>
</ol>
<p>我们在<code>load</code>里键入：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;ADController&quot;), NSSelectorFromString(@&quot;orphansArray:&quot;)); &#x2F;&#x2F; 1
Method newMethod &#x3D; class_getInstanceMethod([AppDeletePatch class], @selector(orphansArray:)); &#x2F;&#x2F; 2

method_exchangeImplementations(origMethod, newMethod); &#x2F;&#x2F; 3
NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>通过<code>class_getInstanceMethod</code>函数，获取程序里<code>orphansArray:</code>的原函数；</li>
<li>这一行代码与<code>3</code>同理，只不过是获取我们声明的替换函数<code>orphansArray:</code>；</li>
<li>通过<code>method_exchangeImplementations</code>函数替换刚才获取的两个新旧函数。</li>
</ol>
<p>其中：</p>
<ul>
<li><code>NSClassFromString</code>可以通过字符串获取类；</li>
<li><code>NSSelectorFromString</code>可以通过字符串获取方法；</li>
<li><code>[AppDeletePatch class]</code>代表<code>AppDeletePatch</code>类的<code>class</code>本身；</li>
<li>通过<code>@selector</code>直接获取一个函数。</li>
</ul>
</li>
</ol>
<p>到此，动态库的代码编写结束。整体的代码应该长这样：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &quot;AppDeletePatch.h&quot;
#import &lt;objc&#x2F;runtime.h&gt;

@implementation AppDeletePatch

- (char)orphansArray:(NSString *)data &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 0x1;
&#125;

+ (void)load &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;ADController&quot;), NSSelectorFromString(@&quot;orphansArray:&quot;));
    Method newMethod &#x3D; class_getInstanceMethod([AppDeletePatch class], @selector(orphansArray:));

    method_exchangeImplementations(origMethod, newMethod);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
&#125;

@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="动态库注入"><a href="#动态库注入" class="headerlink" title="动态库注入"></a>动态库注入</h2><p>编写完动态库，就可以注入了。按下<code>Cmd</code>+<code>B</code>编译，得到<code>.dylib</code>文件。</p>
<p>之后我们要注入。原作者用的是<code>bash</code>脚本，但是这样做比较费事，容易发生权限错误，因此我们用<code>insert_dylib</code>工具注入。点击<a class="link"   href="xcode://clone?repo=https%3A%2F%2Fgithub.com%2FTyilo%2Finsert_dylib" >这个链接<i class="fas fa-external-link-alt"></i></a>将<code>insert_dylib</code>项目克隆到<code>Xcode</code>，并且编译，得到<code>insert_dylib</code>二进制文件。</p>
<p>我们将动态库、二进制文件和<code>AppDelete</code>应用程序的路径分别记录下来，然后打开终端，执行命令（记得替换路径）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ .&#x2F;insert_dylib xxx&#x2F;libAppDeletePatch.dylib xxx&#x2F;AppDelete.app&#x2F;Contents&#x2F;MacOS&#x2F;AppDelete<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注：<code>./insert_dylib</code>的用法是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;insert_dylib [要被注入的动态库的路径] [要注入的二进制文件]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意第二个参数，是要注入的<strong>二进制文件</strong>，而不是<code>.app</code>文件，或者其他。还要注意，路径要使用<strong>绝对路径</strong>。</p>
<p>回车后，如果出现<code>LC_CODE_SIGNATURE load command found. Remove it? [y/n]</code>，那么就按下<code>y</code>，回车。</p>
<p>如果出现<code>Added LC_LOAD_DYLIB to /Applications/AppDelete.app/Contents/MacOS/AppDelete_patched</code>，代表注入成功。</p>
<p>回到<code>/Applications/AppDelete.app/Contents/MacOS/</code>路径，会发现多出一个<code>AppDelete_patched</code>文件。这就是已注入动态库的二进制文件。把原先的<code>AppDelete</code>二进制更名或删除，然后将<code>AppDelete_patched</code>更名为<code>AppDelete</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ad-chname.png" alt="重命名"></p>
<h1 id="验证破解"><a href="#验证破解" class="headerlink" title="验证破解"></a>验证破解</h1><p>我们现在不要用正常的方法打开软件。我们还保持上一步的目录（<code>MacOS</code>），然后双击已经被注入的二进制文件，应用也会打开。不过同时会打开一个终端窗口，在这个窗口中就可以看到我们在写代码时使用<code>NSLog</code>语句打印的内容了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>成功破解！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>OllyDBG 完美教程</title>
    <url>/posts/22015/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我以前研究的破解与反编译，一直处于Unix、类Unix的领空，比如我现在用的macOS。但是一个人的研究并不能止步于此吧，毕竟Windows系统的破解也值得学习，Windows上也有许多可供破解、研究、分析的软件，因此我把这篇介绍OllyDbg——Windows下专用反汇编软件——的文章，放在此处。</p>
<a id="more"></a>
<p>此篇文章的原作者是<strong>CCDebuger</strong>，但是很可惜，由于在各个平台上找不到其账号，因此无法单独感谢作者。我把原作者的文章进行排版，把其中一些语句梳理了一下，供大家阅读。</p>
<h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><h2 id="OllyDBG-的安装与配置"><a href="#OllyDBG-的安装与配置" class="headerlink" title="OllyDBG 的安装与配置"></a>OllyDBG 的安装与配置</h2><p>OllyDBG 1.10 版的发布版本是个 ZIP 压缩包，只要解压到一个目录下，运行 OllyDBG.exe 就可以了。汉化版的发布版本是个 RAR 压缩包，同样只需解压到一个目录下运行 OllyDBG.exe 即可：</p>
<p><img src="https://i.loli.net/2020/03/20/dnbSgrTKfFRkhXP.png" alt="ollydbg主窗口"></p>
<p>OllyDBG 中各个窗口的功能如上图。简单解释一下各个窗口的功能，更详细的内容可以参考 TT 小组翻译的中文帮助：</p>
<ul>
<li>反汇编窗口：显示被调试程序的反汇编代码，标题栏上的地址、HEX 数据、反汇编、注释可以通过在窗口中右击出现的菜单界面选项 &gt; 隐藏标题或显示标题来进行切换是否显示。用鼠标左键点击注释标签可以切换注释显示的方式。</li>
<li>寄存器窗口：显示当前所选线程的 CPU 寄存器内容。同样点击标签寄存器 (FPU) 可以切换显示寄存器的方式。</li>
<li>信息窗口：显示反汇编窗口中选中的第一个命令的参数及一些跳转目标地址、字串等。</li>
<li>数据窗口：显示内存或文件的内容。右键菜单可用于切换显示方式。</li>
<li>堆栈窗口：显示当前线程的堆栈。</li>
</ul>
<p>要调整上面各个窗口的大小的话，只需左键按住边框拖动，等调整好了，重新启动一下 OllyDBG 就可以生效了。</p>
<p>启动后我们要把插件及 UDD 的目录配置为绝对路径，点击菜单上的选项&gt;界面，将会出来一个界面选项的对话框，我们点击其中的目录标签：</p>
<p><img src="https://i.loli.net/2020/03/20/M4XBzQ3lx9iqEdt.png" alt="udd设置"></p>
<p>因为我这里是把 OllyDBG 解压在 F:\OllyDBG 目录下，所以相应的 UDD 目录及插件目录按图上配置。还有一个常用到的标签就是上图后面那个字体，在这里你可以更改 OllyDBG 中显示的字体。上图中其它的选项可以保留为默认，若有需要也可以自己修改。修改完以后点击确定，弹出一个对话框，说我们更改了插件路径，要重新启动 OllyDBG。在这个对话框上点确定，重新启动一下 OllyDBG，我们再到界面选项中看一下，会发现我们原先设置好的路径都已保存了。有人可能知道插件的作用，但对那个 UDD 目录不清楚。我简单解释一下：这个 UDD 目录的作用是保存你调试的工作。比如你调试一个软件，设置了断点，添加了注释，一次没做完，这时 OllyDBG 就会把你所做的工作保存到这个 UDD 目录，以便你下次调试时可以继续以前的工作。如果不设置这个 UDD 目录，OllyDBG 默认是在其安装目录下保存这些后缀名为 udd 的文件，时间长了就会显的很乱，所以还是建议专门设置一个目录来保存这些文件。</p>
<p>另外的一个重要的选项，就是调试选项，可通过菜单选项 &gt; 调试设置来配置：</p>
<p><img src="https://i.loli.net/2020/03/20/uzkUf6jNndX5cl2.png" alt="调试选项"></p>
<p>新手一般不需更改这里的选项，默认已配置好，可以直接使用。建议在对 OllyDBG 已比较熟的情况下再来进行配置。上面那个异常标签中的选项经常会在脱壳中用到，建议在有一定调试基础后学脱壳时再配置这里。</p>
<p>除了直接启动 OllyDBG 来调试外，我们还可以把 OllyDBG 添加到资源管理器右键菜单，这样我们就可以直接在 <code>.exe</code> 及 <code>.dll</code> 文件上点右键选择“用 OllyDBG 打开”菜单来进行调试。要把 OllyDBG 添加到资源管理器右键菜单，只需点菜单选项&gt;添加到浏览器，将会出现一个对话框，先点击“添加 Ollydbg 到系统资源管理器菜单”，再点击“完成”按钮即可。要从右键菜单中删除也很简单，还是这个对话框，点击“从系统资源管理器菜单删除OllyDBG”，再点击“完成”就行了。</p>
<p>OllyDBG 支持插件功能，插件的安装也很简单，只要把下载的插件（一般是个 DLL 文件）复制到 OllyDBG 安装目录下的 PLUGIN 目录中就可以了，OllyDBG 启动时会自动识别。要注意的是 OllyDBG 1.1 0 对插件的个数有限制，最多不能超过 32 个，否则会出错。建议插件不要添加的太多。</p>
<p>到这里基本配置就完成了，OllyDBG 把所有配置都放在安装目录下的<code>ollydbg.ini</code>文件中。</p>
<h2 id="基本调试方法"><a href="#基本调试方法" class="headerlink" title="基本调试方法"></a>基本调试方法</h2><p>OllyDBG 有三种方式来载入程序进行调试：点击菜单文件 &gt; 打开（快捷键是 F3）来打开一个可执行文件进行调试；点击菜单文件 &gt; 附加来附加到一个已运行的进程上进行调试，注意这里要附加的程序必须已运行；用右键菜单来载入程序。</p>
<p>一般情况下我们选第一种方式。比如我们选择一个<code>test.exe</code>来调试，通过菜单文件 &gt; 打开来载入这个程序，OllyDBG 中显示的内容将会是这样：</p>
<p><img src="https://i.loli.net/2020/03/20/RXdi5FLnbDz2ZQw.png" alt="加载test.exe"></p>
<p>调试中我们经常要用到的快捷键有这些：</p>
<ul>
<li><p>F2：设置断点，只要在光标定位的位置（上图中灰色条）按F2键即可，再按一次F2键则会删除断点。（相当于 SoftICE 中的 F9）</p>
</li>
<li><p>F8：单步步过。每按一次这个键执行一条反汇编窗口中的一条指令，遇 <code>CALL</code>等子程序不进入其代码。（相当于 SoftICE 中的 F10）</p>
</li>
<li><p>F7：单步步入。功能同单步步过（F8）类似，区别是遇到 <code>CALL</code> 等子程序时会进入其中，进入后首先会停留在子程序的第一条指令上。（相当于 SoftICE 中的 F8）</p>
</li>
<li><p>F4：运行到选定位置。作用就是直接运行到光标所在位置处暂停。（相当于 SoftICE 中的 F7）</p>
</li>
<li><p>F9：运行。按下这个键如果没有设置相应断点的话，被调试的程序将直接开始运行。（相当于 SoftICE 中的 F5）</p>
</li>
<li><p>CTRL + F9：执行到返回。此命令在执行到一个<code>ret</code>（返回指令）时暂停，常用于从系统领空返回到我们调试的程序领空。（相当于 SoftICE 中的 F12）</p>
</li>
<li><p>ALT + F9：执行到用户代码。可用于从系统领空快速返回到我们调试的程序领空。（相当于 SoftICE 中的 F 11）</p>
</li>
</ul>
<p>上面提到的几个快捷键对于一般的调试基本上已够用了。要开始调试只需设置好断点，找到你感兴趣的代码段再按 F8 或 F7 键来一条条分析指令功能就可以了。</p>
<h1 id="破解实例"><a href="#破解实例" class="headerlink" title="破解实例"></a>破解实例</h1><p>上一篇是使用入门，现在我们开始正式进入破解。</p>
<h2 id="字串参考"><a href="#字串参考" class="headerlink" title="字串参考"></a>字串参考</h2><p>今天的目标程序是看《加密与解密》一书第一版附带光盘中的 <code>crackmes.cjb.net</code> 镜像打包中的<code>CFF Crackme #3</code>，采用用户名/序列号保护方式。原版加了个 UPX 的壳。刚开始学破解先不涉及壳的问题，我们主要是熟悉用 OllyDBG 来破解的一般方法。我这里把壳脱掉来分析，附件是脱壳后的文件，直接就可以拿来用。先说一下一般软件破解的流程：拿到一个软件先别接着马上用 OllyDBG 调试，先运行一下，有帮助文档的最好先看一下帮助，熟悉一下软件的使用方法，再看看注册的方式。如果是序列号方式可以先输个假的来试一下，看看有什么反应，也给我们破解留下一些有用的线索。如果没有输入注册码的地方，要考虑一下是不是读取注册表或 Key 文件（一般称为 keyfile，就是程序读取一个文件中的内容来判断是否注册），这些可以用其它工具来辅助分析。如果这些都不是，原程序只是一个功能不全的试用版，那要注册为正式版本就要自己来写代码完善了。</p>
<p>接下来我们回到正题：获得程序的一些基本信息后，还要用查壳的工具来查一下程序是否加了壳，若没壳的话看看程序是什么编译器编的，如 VC、Delphi、VB 等。这样的查壳工具有 PEiD 和 FI。有壳的话我们要尽量脱了壳后再来用 OllyDBG 调试，特殊情况下也可带壳调试。下面进入正题。</p>
<p>我们先来运行一下这个 crackme（用 PEiD 检测显示是 Delphi 编的），界面如图：</p>
<p><img src="https://i.loli.net/2020/03/20/RuEynJYiqV89Ohz.png" alt="运行第一个crakeme"></p>
<p>这个 crackme 已经把用户名和注册码都输好了，省得我们动手^_^。我们在那个“Register now !”按钮上点击一下，将会跳出一个对话框：</p>
<img src="https://i.loli.net/2020/03/20/jNeCiZ5KLGRQgna.png" alt="crackme弹出错误对话框" style="zoom:150%;" />

<p>好了，今天我们就从这个错误对话框中显示的“Wrong Serial, try again!”来入手。启动 OllyDBG，选择菜单文件&gt;打开载入 CrackMe3.exe 文件，我们会停在这里：</p>
<p><img src="https://i.loli.net/2020/03/20/D8RmEjGUdiqt2Q5.png" alt="载入crackme后停在这里"></p>
<p>我们在反汇编窗口中右击鼠标，出来一个菜单，我们在查找 &gt; 所有参考文本字串上左键点击：</p>
<p><img src="https://i.loli.net/2020/03/20/bErxu8yDFiLh1Vt.png" alt="反汇编右击"></p>
<p>当然如果用上面那个超级字串参考＋插件会更方便。但我们的目标是熟悉 OllyDBG 的一些操作，我就尽量使用 OllyDBG 自带的功能，少用插件。好了，现在出来另一个对话框，我们在这个对话框里右击，选择“查找文本”菜单项，输入“Wrong Serial, try again!”的开头单词“Wrong”（注意这里查找内容要区分大小写）来查找，找到一处：</p>
<p><img src="https://i.loli.net/2020/03/20/O4bjFTol5YBs8gE.png" alt="找到一处字串"></p>
<p>在我们找到的字串上右击，再在出来的菜单上点击“反汇编窗口中跟随”，我们来到这里：</p>
<p><img src="https://i.loli.net/2020/03/20/FDEocJBKnmweXb1.png" alt="反汇编窗口中跟随"></p>
<p>见上图，为了看看是否还有其他的参考，可以通过选择右键菜单查找参考&gt;立即数，会出来一个对话框：</p>
<p><img src="https://i.loli.net/2020/03/20/SyxPJCzTqepV1R7.png" alt="立即数对话框"></p>
<p>分别双击上面标出的两个地址，我们会来到对应的位置：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00440F79 |. BA 8C104400     MOV EDX,CrackMe3.0044108C             ; ASCII “Wrong Serial,try again!”
00440F7E |. A1 442C4400     MOV EAX,DWORD PTR DS:[442C44]
00440F83 |. 8B00            MOV EAX,DWORD PTR DS:[EAX]
00440F85 |. E8 DEC0FFFF     CALL CrackMe3.0043D068
00440F8A |. EB 18           JMP SHORT CrackMe3.00440FA4
00440F8C |&gt; 6A 00           PUSH 0
00440F8E |. B9 80104400     MOV ECX,CrackMe3.00441080             ; ASCII “Beggar off!”
00440F93 |. BA 8C104400     MOV EDX,CrackMe3.0044108C             ; ASCII “Wrong Serial,try again!”
00440F98 |. A1 442C4400     MOV EAX,DWORD PTR DS:[442C44]
00440F9D |. 8B00            MOV EAX,DWORD PTR DS:[EAX]
00440F9F |. E8 C4C0FFFF     CALL CrackMe3.0043D068<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在反汇编窗口中向上滚动一下再看看：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">00440F2C |. 8B45 FC         MOV EAX,DWORD PTR SS:[EBP-4]
00440F2F |. BA 14104400     MOV EDX,CrackMe3.00441014             ; ASCII “Registered User”
00440F34 |. E8 F32BFCFF     CALL CrackMe3.00403B2C                ; 关键，要用F7跟进去
00440F39 |. 75 51           JNZ SHORT CrackMe3.00440F8C           ; 这里跳走就完蛋
00440F3B |. 8D55 FC         LEA EDX,DWORD PTR SS:[EBP-4]
00440F3E |. 8B83 C8020000   MOV EAX,DWORD PTR DS:[EBX+2C8]
00440F44 |. E8 D7FEFDFF     CALL CrackMe3.00420E20
00440F49 |. 8B45 FC         MOV EAX,DWORD PTR SS:[EBP-4]
00440F4C |. BA 2C104400     MOV EDX,CrackMe3.0044102C             ; ASCII “GFX-754-IER-954”
00440F51 |. E8 D62BFCFF     CALL CrackMe3.00403B2C                ; 关键，要用F7跟进去
00440F56 |. 75 1A           JNZ SHORT CrackMe3.00440F72           ; 这里跳走就完蛋
00440F58 |. 6A 00 PUSH 0
00440F5A |. B9 3C104400     MOV ECX,CrackMe3.0044103C             ; ASCII “CrackMe cracked successfully”
00440F5F |. BA 5C104400     MOV EDX,CrackMe3.0044105C             ; ASCII “Congrats! You cracked this CrackMe!”
00440F64 |. A1 442C4400     MOV EAX,DWORD PTR DS:[442C44]
00440F69 |. 8B00            MOV EAX,DWORD PTR DS:[EAX]
00440F6B |. E8 F8C0FFFF     CALL CrackMe3.0043D068
00440F70 |. EB 32           JMP SHORT CrackMe3.00440FA4
00440F72 |&gt; 6A 00           PUSH 0
00440F74 |. B9 80104400     MOV ECX,CrackMe3.00441080             ; ASCII “Beggar off!”
00440F79 |. BA 8C104400     MOV EDX,CrackMe3.0044108C             ; ASCII “Wrong Serial,try again!”
00440F7E |. A1 442C4400     MOV EAX,DWORD PTR DS:[442C44]
00440F83 |. 8B00            MOV EAX,DWORD PTR DS:[EAX]
00440F85 |. E8 DEC0FFFF     CALL CrackMe3.0043D068
00440F8A |. EB 18           JMP SHORT CrackMe3.00440FA4
00440F8C |&gt; 6A 00           PUSH 0
00440F8E |. B9 80104400     MOV ECX,CrackMe3.00441080             ; ASCII “Beggar off!”
00440F93 |. BA 8C104400     MOV EDX,CrackMe3.0044108C             ; ASCII “Wrong Serial,try again!”
00440F98 |. A1 442C4400     MOV EAX,DWORD PTR DS:[442C44]
00440F9D |. 8B00            MOV EAX,DWORD PTR DS:[EAX]
00440F9F |. E8 C4C0FFFF     CALL CrackMe3.0043D068<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大家注意看一下上面的注释，我在上面标了两个关键点。有人可能要问，你怎么知道那两个地方是关键点？其实很简单，我是根据查看是哪条指令跳到“wrong serial,try again”这条字串对应的指令来决定的。如果你在调试选项&gt;CPU 标签中把“显示跳转路径”及其下面的两个“如跳转未实现则显示灰色路径”、“显示跳转到选定命令的路径”都选上的话，就会看到是从什么地方跳到出错字串处的：</p>
<p><img src="https://i.loli.net/2020/03/20/VEz65UFyjRYWmuS.png" alt="看到从何跳到出错字串"></p>
<p>我们在上图中地址 00440F2C 处按 F2 键设个断点，现在我们按 F9 键，程序已运行起来了。我在上面那个编辑框中随便输入一下，如<code>CCDebuger</code>，下面那个编辑框我还保留为原来的“754-GFX-IER-954”，我们点一下那个“Register now !”按钮，OllyDBG 跳了出来，暂停在我们下的断点处。我们看一下信息窗口，你应该发现了你刚才输入的内容了吧？我这里显示是这样：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">堆栈 SS:[0012F9AC]&#x3D;00D44DB4, (ASCII &quot;CCDebuger&quot;)
EAX&#x3D;00000009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面的内存地址 <code>00D44DB4</code> 中就是我们刚才输入的内容，我这里是 <code>CCDebuger</code>。你可以在堆栈 <code>SS:[0 012F9AC]=00D44DB4, (ASCII &quot;CCDebuger&quot;)</code> 这条内容上左击选择一下，再点右键，在弹出菜单中选择“数据窗口中跟随数值”，你就会在下面的数据窗口中看到你刚才输入的内容。而 <code>EAX=00000009</code> 指的是你输入内容的长度。如我输入的 <code>CCDebuger</code> 是9个字符。如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/20/A5lmgt18udUsKZn.png" alt="数据窗口中跟随数值"></p>
<p>现在我们来按 F8 键一步步分析一下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00440F2C |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4] ; 把我们输入的内容送到EAX，我这里是“CCDebuger”
00440F2F |. BA 14104400 MOV EDX,CrackMe3.00441014 ; ASCII &quot;Registered User&quot;
00440F34 |. E8 F32BFCFF CALL CrackMe3.00403B2C ; 关键，要用F7跟进去00440F39 |. 75 51 JNZ SHORT CrackMe3.00440F8C ; 这里跳走就完蛋<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当我们按 F8 键走到 <code>00440F34 |. E8 F32BFCFF CALL CrackMe3.00403B2C</code> 这一句时，我们按一下 F7 键，进入这个 <code>CALL</code>，进去后光标停在这一句：</p>
<p><img src="https://i.loli.net/2020/03/20/bHEfGPYBdR5CSaA.png" alt="光标停在这一句"></p>
<p>我们所看到的那些 <code>PUSH EBX</code>、 <code>PUSH ESI</code> 等都是调用子程序保存堆栈时用的指令，不用管它，按 F8 键一步步过来，我们只关心关键部分：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00403B2C &#x2F;$ 53 PUSH EBX
00403B2D |. 56 PUSH ESI
00403B2E |. 57 PUSH EDI
00403B2F |. 89C6 MOV ESI,EAX ; 把EAX内我们输入的用户名送到 ES I
00403B31 |. 89D7 MOV EDI,EDX ; 把EDX内的数据“Registered Use r”送到EDI
00403B33 |. 39D0 CMP EAX,EDX ; 用“Registered User”和我们输入的用户名作比较
00403B35 |. 0F84 8F000000 JE CrackMe3.00403BCA ; 相同则跳
00403B3B |. 85F6 TEST ESI,ESI ; 看看ESI中是否有数据，主要是看看我们有没有输入用户名
00403B3D |. 74 68 JE SHORT CrackMe3.00403BA7 ; 用户名为空则跳
00403B3F |. 85FF TEST EDI,EDI
00403B41 |. 74 6B JE SHORT CrackMe3.00403BAE
00403B43 |. 8B46 FC MOV EAX,DWORD PTR DS:[ESI-4] ; 用户名长度送EAX 00403B46 |. 8B57 FC MOV EDX,DWORD PTR DS:[EDI-4] ; “Registered User”字串的长度送EDX
00403B49 |. 29D0 SUB EAX,EDX ; 把用户名长度和“Registered Use r”字串长度相减
00403B4B |. 77 02 JA SHORT CrackMe3.00403B4F ; 用户名长度大于“Registere d User”长度则跳
00403B4D |. 01C2 ADD EDX,EAX ; 把减后值与“Registered User”长度相加，即用户名长度
00403B4F |&gt; 52 PUSH EDX
00403B50 |. C1EA 02 SHR EDX,2 ; 用户名长度值右移2位，这里相当于长度除以4
00403B53 |. 74 26 JE SHORT CrackMe3.00403B7B ; 上面的指令及这条指令就是判断用户名长度最少不能低于4
00403B55 |&gt; 8B0E MOV ECX,DWORD PTR DS:[ESI] ; 把我们输入的用户名送到ECX
00403B57 |. 8B1F MOV EBX,DWORD PTR DS:[EDI] ; 把“Registered User”送到EBX
00403B59 |. 39D9 CMP ECX,EBX ; 比较
00403B5B |. 75 58 JNZ SHORT CrackMe3.00403BB5 ; 不等则完蛋<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据上面的分析，我们知道用户名必须是“Registered User”。我们按 F9 键让程序运行，出现错误对话框，点确定，重新在第一个编辑框中输入“Registered User”，再次点击那个“Register now !”按钮，被 OllyDBG 拦下。因为地址 <code>00440F34</code> 处的那个 <code>CALL</code> 我们已经分析清楚了，这次就不用再按 F7 键跟进去了，直接按 F8 键通过。我们一路按 F8 键，来到第二个关键代码处：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00440F49 |. 8B45 FC MOV EAX,DWORD PTR SS:[EBP-4] ; 取输入的注册码00440F4C |. BA 2C104400 MOV EDX,CrackMe3.0044102C ; ASCII &quot;GFX-754-IE R-954&quot;
00440F51 |. E8 D62BFCFF CALL CrackMe3.00403B2C ; 关键，要用F7跟进去00440F56 |. 75 1A JNZ SHORT CrackMe3.00440F72 ; 这里跳走就完蛋&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>大家注意看一下，地址 <code>00440F51</code> 处的 <code>CALL CrackMe3.00403B2C</code> 和上面我们分析的地址 <code>00440F34</code> 处的 <code>CALL CrackMe3.00403B2C</code> 是不是汇编指令都一样啊？这说明检测用户名和注册码是用的同一个子程序。而这个子程序 <code>CALL</code> 我们在上面已经分析过了。我们执行到现在可以很容易得出结论，这个 <code>CALL</code> 也就是把我们输入的注册码与 <code>00440F4C</code> 地址处指令后的“GFX-754-IER-954”作比较，相等则 OK。好了，我们已经得到足够的信息了。现在我们在菜单查看&gt;断点上点击一下，打开断点窗口（也可以通过组合键 ALT+B 或点击工具栏上那个“B”图标打开断点窗口）：</p>
<p><img src="https://i.loli.net/2020/03/20/B4stMxyn2CQ68Ef.png" alt="打开断点窗口"></p>
<p>为什么要做这一步，而不是把这个断点删除呢？这里主要是为了保险一点，万一分析错误，我们还要接着分析，要是把断点删除了就要做一些重复工作了。还是先禁用一下，如果经过实际验证证明我们的分析是正确的，再删不迟。现在我们把断点禁用，在 OllyDBG 中按 F9 键让程序运行。输入我们经分析得出的内容：</p>
<ul>
<li><p>用户名：Registered User</p>
</li>
<li><p>注册码：GFX-754-IER-954</p>
</li>
</ul>
<p>点击“Register now!”按钮，呵呵，终于成功了：</p>
<p><img src="https://i.loli.net/2020/03/20/rtDNVOondR4H8PC.png" alt="crackme1成功"></p>
<h2 id="函数参考"><a href="#函数参考" class="headerlink" title="函数参考"></a>函数参考</h2><p>现在进入第三篇，这一篇我们重点讲解怎样使用 <code>OllyDBG</code> 中的函数参考（即名称参考）功能。仍然选择 crackmes.cjb.net 镜像打包中的一个名称为 <code>CrackHead</code> 的crackme。老规矩，先运行一下这个程序看看：</p>
<p><img src="https://i.loli.net/2020/03/20/1Iefc9vDnLhQrk7.png" alt="CrackHead主界面"></p>
<p>别急，我们点一下程序上的那个菜单“Shit”（学英语的，你懂的），在下拉菜单中选“Try It”，会来到如下界面输入注册码：</p>
<p><img src="https://i.loli.net/2020/03/20/SJN9XFTrMLcUgqz.png" alt="crackme2输入注册码"></p>
<p>我们点一下那个“Check It”按钮试一下，哦，竟然没反应！我再输个“78787878”试试，还是没反应。再试试输入字母或其它字符，输不进去。由此判断注册码应该都是数字，只有输入正确的注册码才有动静。用 PEiD 检测一下，结果为 <code>MASM32 / TASM32</code>，怪不得程序比较小。信息收集的差不多了，现在关掉这个程序，我们用 OllyDBG 载入，按 F9 键直接让它运行起来，依次点击上面图中所说的菜单，使被调试程序显示如上面的第二个图。先不要点那个“Check It”按钮，保留上图的状态。现在我们没有什么字串好参考了，我们就在 API 函数上下断点，来让被调试程序中断在我们希望的地方。我们在 OllyDBG 的反汇编窗口中右击鼠标，在弹出菜单中选择查找 &gt; 当前模块中的名称 (标签)，或者我们通过按 CTRL + N 组合键也可以达到同样的效果（注意在进行此操作时要在 OllyDBG 中保证是在当前被调试程序的领空，我在第一篇中已经介绍了领空的概念，如我这里调试这个程序时 OllyDBG 的标题栏显示的就是<code>[CPU - 主线程, 模块 - CrackHead]</code>，这表明我们当前在被调试程序的领空）。通过上面的操作后会弹出一个对话框，如图：</p>
<p><img src="https://i.loli.net/2020/03/20/vRdxQZrX2O5DobU.png" alt="操作后弹出对话框"></p>
<p>对于这样的编辑框中输注册码的程序我们要设断点首选的 API 函数就是 <code>GetDlgItemText</code> 及 <code>GetWindowText</code>。</p>
<blockquote>
<p>每个函数都有两个版本，一个是 <code>ASCII</code> 版，在函数后添加一个 <code>A</code> 表示，如 <code>GetDlgItemTextA</code>，另一个是 <code>UNICODE</code> 版，在函数后添加一个 <code>W</code> 表示。如 <code>GetDlgItemTextW</code>。对于编译为 <code>UNCODE</code> 版的程序可能在 <code>Win98</code> 下不能运行，因为 <code>Win98</code> 并非是完全支持 <code>UNICODE</code> 的系统。而 <code>NT</code> 系统则从底层支持 <code>UNICODE</code>，它可以在操作系统内对字串进行转换，同时支持 ASCII 和 <code>UNICODE</code> 版本函数的调用。一般我们打开的程序看到的调用都是 <code>ASCII</code> 类型的函数，以<code>A</code>结尾。</p>
</blockquote>
<p>现在回到我们调试的程序上来，我们现在就是要找一下我们调试的程序有没有调用 <code>GetDlgItemTextA</code> 或 <code>GetWindowTextA</code> 函数。还好，找到一个 <code>GetWindowTextA</code>。在这个函数上右击，在弹出菜单上选择“在每个参考上设置断点”，我们会在 <code>OllyDBG</code> 窗口最下面的那个状态栏里看到“已设置 2 个断点”。另一种方法就是那个 <code>GetWindowTextA</code> 函数上右击，在弹出菜单上选择“查找输入函数参考”（或者按回车键），将会出现下面的对话框：</p>
<p><img src="https://i.loli.net/2020/03/20/pLFaUE1hWtofXY8.png" alt="回车出现下面的对话框"></p>
<p>看上图，我们可以把两条都设上断点。这个程序只需在第一条指令设断点就可以了。好，我们现在按前面提到的第一条方法，就是“在每个参考上设置断点”，这样上图中的两条指令都会设上断点。断点设好后我们转到我们调试的程序上来，现在我们在被我们调试的程序上点击那个“Check It”按钮，被 OllyDBG 断下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401323 |. E8 4C010000 CALL &lt;JMP.&amp;USER32.GetWindowTextA&gt; ; GetWin dowTextA
00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按F7键跟进去
0040132D |. 3BC6 CMP EAX,ESI ; 比较
0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋00401331 |. EB 2C JMP SHORT CrackHea.0040135F
00401333 |. 4E 6F 77 20 7&gt; ASCII &quot;Now write a keyg&quot;
00401343 |. 65 6E 20 61 6&gt; ASCII &quot;en and tut and y&quot;
00401353 |. 6F 75 27 72 6&gt; ASCII &quot;ou&#39;re done.&quot;,0
0040135F |&gt; 6A 00 PUSH 0 ; Style &#x3D; MB_OK|MB_APP LMODAL
00401361 |. 68 0F304000 PUSH CrackHea.0040300F ; Title &#x3D; &quot;Crudd &#39;s Crack Head&quot;
00401366 |. 68 33134000 PUSH CrackHea.00401333 ; Text &#x3D; &quot;No
w write a keygen and tut and you&#39;re done.&quot;
0040136B |. FF75 08 PUSH DWORD PTR SS:[EBP+8] ; hOwner 0040136E |. E8 19010000 CALL &lt;JMP.&amp;USER32.MessageBoxA&gt; ; Message BoxA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面的代码，我们很容易看出 <code>00401328</code> 地址处的 <code>CALL CrackHea.004013D2</code> 是关键，必须仔细跟踪。而注册成功则会显示一个对话框，标题是“Crudd’s Crack Head”，对话框显示的内容是“Now write a keygen and tut and you’re done.”现在我按一下 F8，准备步进到 <code>00401328</code> 地址处的那条 <code>CALL CrackHea.004013D2</code> 指令后再按 F7 键跟进去。等等，怎么回事？怎么按一下 F8 键跑到这来了：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401474 $- FF25 2C204000 JMP DWORD PTR DS:[&lt;&amp;USER32.GetWindowText&gt; ; U SER32.GetWindowTextA
0040147A $- FF25 30204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadCursorA&gt;] ; US ER32.LoadCursorA
00401480 $- FF25 1C204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadIconA&gt;] ; US
ER32.LoadIconA
00401486 $- FF25 20204000 JMP DWORD PTR DS:[&lt;&amp;USER32.LoadMenuA&gt;] ; US ER32.LoadMenuA
0040148C $- FF25 24204000 JMP DWORD PTR DS:[&lt;&amp;USER32.MessageBoxA&gt;] ; U SER32.MessageBoxA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原来是跳到另一个断点了。这个断点我们不需要，按一下 F2 键删掉它吧。删掉 <code>00401474</code> 地址处的断点后，我再按 F8 键，呵，完了，跑到 <code>User32.dll</code> 的领空了。看一下 OllyDBG 的标题栏：“[CPU - 主线程, 模块 - USER32]，跑到系统领空了，OllyDBG 反汇编窗口中显示代码是这样：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">77D3213C 6A 0C PUSH 0C
77D3213E 68 A021D377 PUSH USER32.77D321A0
77D32143 E8 7864FEFF CALL USER32.77D185C0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>怎么办？别急，我们按一下 ALT + F9 组合键，呵，回来了：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按F7键跟进去
0040132D |. 3BC6 CMP EAX,ESI ; 比较
0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>光标停在 <code>00401328</code> 地址处的那条指令上。现在我们按 F7 键跟进：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">004013D2 &#x2F;$ 56 PUSH ESI ; ESI入栈
004013D3 |. 33C0 XOR EAX,EAX ; EAX清零
004013D5 |. 8D35 C4334000 LEA ESI,DWORD PTR DS:[4033C4] ; 把注册码框中的数值送到ESI
004013DB |. 33C9 XOR ECX,ECX ; ECX清零
004013DD |. 33D2 XOR EDX,EDX ; EDX清零
004013DF |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 把注册码中的每个字符送到AL
004013E1 |. 46 INC ESI ; 指针加1，指向下一个字符004013E2 |. 3C 2D CMP AL,2D ; 把取得的字符与16进制值为2D的字符(即“-”)比较，这里主要用于判断输入的是不是负数
004013E4 |. 75 08 JNZ SHORT CrackHea.004013EE ; 不等则跳
004013E6 |. BA FFFFFFFF MOV EDX,-1 ; 如果输入的是负数，则把-1送到EDX，即16进制FFFFFFFF
004013EB |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 取“-”号后的第一个字符
004013ED |. 46 INC ESI ; 指针加1，指向再下一个字符004013EE |&gt; EB 0B JMP SHORT CrackHea.004013FB
004013F0 |&gt; 2C 30 SUB AL,30 ; 每位字符减16进制的30，因为这里都是数字，如1的ASCII码是“31H”，减30H后为1，即我们平时看到的数值
004013F2 |. 8D0C89 LEA ECX,DWORD PTR DS:[ECX+ECX*4] ; 把前面运算后保存在ECX中的结果乘5再送到ECX
004013F5 |. 8D0C48 LEA ECX,DWORD PTR DS:[EAX+ECX*2] ; 每位字符运算后的值与2倍上一位字符运算后值相加后送ECX
004013F8 |. 8A06 MOV AL,BYTE PTR DS:[ESI] ; 取下一个字符004013FA |. 46 INC ESI ; 指针加1，指向再下一个字符004013FB |&gt; 0AC0 OR AL,AL
004013FD |.^ 75 F1 JNZ SHORT CrackHea.004013F0 ; 上面一条和这一条指令主要是用来判断是否已把用户输入的注册码计算完
004013FF |. 8D040A LEA EAX,DWORD PTR DS:[EDX+ECX] ; 把EDX中的值与经过上面运算后的ECX中值相加送到EAX
00401402 |. 33C2 XOR EAX,EDX ; 把EAX与EDX异或。如果我们输入的是负数，则此处功能就是把EAX中的值取反
00401404 |. 5E POP ESI ; ESI出栈。看到这条和下一条指令，我们要考虑一下这个ESI的值是哪里运算得出的呢？
00401405 |. 81F6 53757A79 XOR ESI,797A7553 ; 把ESI中的值与797 A7553H异或
0040140B \. C3 RETN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里留下了一个问题：那个 ESI 寄存器中的值是从哪运算出来的？先不管这里，我们接着按 F8 键往下走，来到 <code>0040140B</code> 地址处的那条 <code>RETN</code> 指令（这里可以通过在调试选项的“命令”标签中勾选“使用 RET 代替RETN”来更改返回指令的显示方式），再按一下 F8，我们就走出 00401328 地址处的那个 <code>CALL</code> 了。现在我们回到了这里：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040132D |. 3BC6 CMP EAX,ESI ; 比较
0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>光标停在了 0040132D 地址处的那条指令上。根据前面的分析，我们知道 EAX 中存放的是我们输入的注册码经过计算后的值。我们来看一下信息窗口：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ESI&#x3D;E6B5F2F9
EAX&#x3D;FF439EBE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>左键选择信息窗口中的 <code>ESI=E6B5F2F9</code>，再按右键，在弹出菜单上选“修改寄存器”，我们会看到这样一个窗口：</p>
<img src="https://i.loli.net/2020/03/20/FxR2eUNs4Jp89Eu.png" alt="修改esi" style="zoom:150%;" />

<p>可能你的显示跟我不一样，因为这个 crackme 中已经说了每个机器的序列号不一样。关掉上面的窗口，再对信息窗口中的 <code>EAX=FF439EBE </code>做同样操作：</p>
<img src="https://i.loli.net/2020/03/20/SQWM6seORHKPwFT.png" alt="修改eax" style="zoom:150%;" />

<p>由上图我们知道了原来前面分析的对我们输入的注册码进行处理后的结果就是把字符格式转为数字格式。</p>
<p>我们原来输入的是字串“12345666”，现在转换为了数字 12345666。这下就很清楚了，随便在上面那个修改 ESI 图中显示的有符号或无符号编辑框中复制一个，粘贴到我们调试的程序中的编辑框中试一下：</p>
<p><img src="https://i.loli.net/2020/03/20/RlNY1CQ85eG26VD.png" alt="编辑框中试一下"></p>
<p>成功了！——且慢，这个 crackme 是要求写出注册机的。不过在这篇文章内，我们不要求写注册机，但我们要搞清楚注册的算法。还记得我在前面说到的那个 <code>ESI</code> 寄存器值的问题吗？现在看看我们上面的分析，其实对做注册机来说是没有多少帮助的。要搞清注册算法，必须知道上面那个 <code>ESI</code> 寄存器值是如何产生的，这弄清楚后才能真正清楚这个 crackme 算法。今天就先说到这里，关于如何追出 <code>ESI</code> 寄存器的值我就留到下一篇——内存断点中再讲吧。</p>
<h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>还记得上一篇的内容吗？在那篇文章中我们分析后发现一个 ESI 寄存器值不知是从什么地方产生的，要弄清这个问题必须要找到生成这个 ESI 值的计算部分。今天我们的任务就是使用 OllyDBG 的内存断点功能找到这个地方，搞清楚这个值是如何算出来的。这次分析的目标程序还是上一篇的那个 crackme，附件我就不再上传了，用上篇中的附件就可以了。下面我们开始。</p>
<p>还记得我们上篇中所说的关键代码的地方吗？温习一下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401323 |. E8 4C010000 CALL &lt;JMP.&amp;USER32.GetWindowTextA&gt; ; GetWin dowTextA
00401328 |. E8 A5000000 CALL CrackHea.004013D2 ; 关键，要按F7键跟进去
0040132D |. 3BC6 CMP EAX,ESI ; 比较
0040132F |. 75 42 JNZ SHORT CrackHea.00401373 ; 不等则完蛋<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们重新用 OllyDBG 载入目标程序，F9运行来到上面代码所在的地方（你上次设的断点应该没删吧？），我们向上看看能不能找到那个 ESI 寄存器中最近是在哪里赋的值。哈哈，原来就在附近啊：</p>
<p><img src="https://i.loli.net/2020/03/20/tAEkCfj8R6vWTN3.png" alt="就在附近"></p>
<p>我们现在知道 ESI 寄存器的值是从内存地址 <code>40339C</code> 中送过来的，那内存地址 <code>40339C</code> 中的数据是什么时候产生的呢？大家注意，我这里信息窗口中显示的是 <code>DS:[0040339C]=9FCF87AA</code>，你那可能是 <code>DS:[0040339C]=XXXXXXXX</code>，这里的 <code>XXXXXXXX</code> 表示的是其它的值，就是说与我这里显示的 <code>9FCF87AA</code> 不一样。我们按上图的操作在数据窗口中看一下：</p>
<p><img src="https://i.loli.net/2020/03/20/n18PG2imUXeB9W3.png" alt="在数据窗口中看"></p>
<p>从上图我们可以看出内存地址 <code>40339C</code> 处的值已经有了，说明早就算过了。现在怎么办呢？我们考虑一下，看情况程序是把这个值算出来以后写在这个内存地址，那我们要是能让 OllyDBG 在程序开始往这个内存地址写东西的时候中断下来，不就有可能知道目标程序是怎么算出这个值的吗？说干就干，我们在 OllyDBG 的菜单上点调试-&gt;重新开始，或者按 <code>CTRL + F2</code> 组合键（还可以点击工具栏上的那个有两个实心左箭头的图标）来重新载入程序。这时会跳出一个“进程仍处于激活状态”的对话框（我们可以在在调试选项的安全标签下把“终止活动进程时警告”这条前面的勾去掉，这样下次就不会出现这个对话框了），问我们是否要终止进程。这里我们选“是”，程序被重新载入，我们停在下面这一句上：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401000 &gt;&#x2F;$ 6A 00 PUSH 0 ; pModule &#x3D; NULL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在我们就要来设内存断点了。在 OllyDBG 中一般我们用到的内存断点有内存访问和内存写入断点。内存访问断点就是指程序访问内存中我们指定的内存地址时中断，内存写入断点就是指程序往我们指定的内存地址中写东西时中断。更多关于断点的知识大家可以参考论坛精华7 -&gt; 基础知识 -&gt; 断点技巧 -&gt; 断点原理这篇 Lenus 写的《如何对抗硬件断点之一 — 调试寄存器》文章，也可以看<a class="link"   href="http://bbs.pediy.com/showthread.php?threadid=10829" >这个帖<i class="fas fa-external-link-alt"></i></a>。根据当前我们调试的具体程序的情况，我们选用内存写入断点。还记得前面我叫大家记住的那个 <code>40339C</code> 内存地址吗？现在我们要用上了。我们先在 OllyDBG 的数据窗口中左键点击一下，再右击，会弹出一个如下图所示的菜单。我们选择其中的转到 -&gt; 表达式（也可以左键点击数据窗口后按 CTRL + G 组合键）。如下图：</p>
<p><img src="https://i.loli.net/2020/03/20/WzfCGjTShX3IqV6.png" alt="转到 -&gt; 表达式"></p>
<p>现在将会出现这样一个对话框：</p>
<p>我们在上面那个编辑框中输入我们想查看内容的内存地址 <code>40339C</code>，然后点确定按钮，数据窗口中显示如下：</p>
<p><img src="https://i.loli.net/2020/03/20/pe7dEOmqQihU2ta.png" alt="点确定按钮数据窗口中显示如下"></p>
<p>我们可以看到，<code>40339C</code> 地址开始处的这段内存里面还没有内容。我们现在在 <code>40339C</code> 地址处后面的 <code>HEX</code> 数据或 <code>ASCII</code> 栏中按住左键往后拖放，选择一段。内存断点的特性就是不管你选几个字节，<code>OllyDBG</code> 都会分配 4096 字节的内存区。这里我就选从 <code>40339C</code> 地址处开始的四个字节，主要是为了让大家提前了解一下硬件断点的设法，因为硬件断点最多只能选4个字节。选中部分会显示为灰色。选好以后松开鼠标左键，在我们选中的灰色部分上右击：</p>
<p><img src="https://i.loli.net/2020/03/20/NpgZf8K9ChIecs2.png" alt="选中的灰色部分上右击"></p>
<p>经过上面的操作，我们的内存断点就设好了（这里还有个要注意的地方：内存断点只在当前调试的进程中有效，就是说你如果重新载入程序的话内存断点就自动删除了。且内存断点每一时刻只能有一个。就是说你不能像按 F2 键那样同时设置多个断点）。现在按 F9 键让程序运行，呵，OllyDBG 中断了！</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">7C932F39 8808 MOV BYTE PTR DS:[EAX],CL ; 这就是我们第一次断下来的地方
7C932F3B 40 INC EAX
7C932F3C 4F DEC EDI
7C932F3D 4E DEC ESI
7C932F3E ^ 75 CB JNZ SHORT ntdll.7C932F0B
7C932F40 8B4D 10 MOV ECX,DWORD PTR SS:[EBP+10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面就是我们中断后反汇编窗口中的代码。如果你是其它系统，如 <code>Win98</code> 的话，可能会有所不同。没关系，这里不是关键。我们看一下领空，原来是在 <code>ntdll.dll</code> 内。系统领空，我们现在要考虑返回到程序领空。返回前我们看一下数据窗口：</p>
<p><img src="https://i.loli.net/2020/03/20/K3ZWzJDrydwhY1k.png" alt="返回前我们看一下数据窗口"></p>
<p>现在我们转到反汇编窗口，右击鼠标，在弹出菜单上选择断点 -&gt; 删除内存断点，这样内存断点就被删除了。</p>
<p><img src="https://i.loli.net/2020/03/20/QneZq7b9EwrSpxd.png" alt="内存断点就被删除"></p>
<p>现在我们来按一下 ALT + F9 组合键，我们来到下面的代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401431 |. 8D35 9C334000 LEA ESI,DWORD PTR DS:[40339C] ; ALT+F9返回后来到的位置
00401437 |. 0FB60D EC334000 MOVZX ECX,BYTE PTR DS:[4033EC]
0040143E |. 33FF XOR EDI,EDI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们把反汇编窗口往上翻翻，呵，原来就在我们上一篇分析的代码下面啊？</p>
<p><img src="https://i.loli.net/2020/03/22/DqNM8HY9O3P6Jgy.png" alt="上一篇分析的代码"></p>
<p>现在我们在 <code>0040140C</code> 地址处那条指令上按 F2 设置一个断点，现在我们按 CTRL + F2 组合键重新载入程序，载入后按 F9 键运行，我们将会中断在我们刚才在 <code>0040140C</code> 地址下的那个断点处：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040140C &#x2F;$ 60 PUSHAD
0040140D |. 6A 00 PUSH 0 ; &#x2F;RootPathName &#x3D; NULL 0040140F |. E8 B4000000 CALL &lt;JMP.&amp;KERNEL32.GetDriveTypeA&gt; ; \GetDriv eTypeA
00401414 |. A2 EC334000 MOV BYTE PTR DS:[4033EC],AL ; 磁盘类型参数送内存地址4033EC
00401419 |. 6A 00 PUSH 0 ; &#x2F;pFileSystemNameSiz
e &#x3D; NULL
0040141B |. 6A 00 PUSH 0 ; |pFileSystemNameBuffe
r &#x3D; NULL
0040141D |. 6A 00 PUSH 0 ; |pFileSystemFlags &#x3D; NULL 0040141F |. 6A 00 PUSH 0 ; |pMaxFilenameLength &#x3D; N ULL
00401421 |. 6A 00 PUSH 0 ; |pVolumeSerialNumbe
r &#x3D; NULL
00401423 |. 6A 0B PUSH 0B ; |MaxVolumeNameSiz
e &#x3D; B (11.)
00401425 |. 68 9C334000 PUSH CrackHea.0040339C ; |VolumeName Buffer &#x3D; CrackHea.0040339C
0040142A |. 6A 00 PUSH 0 ; |RootPathName &#x3D; NULL 0040142C |. E8 A3000000 CALL &lt;JMP.&amp;KERNEL32.GetVolumeInformationA&gt; ; \GetV olumeInformationA
00401431 |. 8D35 9C334000 LEA ESI,DWORD PTR DS:[40339C] ; 把crackme程序所在分区的卷标名称送到ESI
00401437 |. 0FB60D EC334000 MOVZX ECX,BYTE PTR DS:[4033EC] ; 磁盘类型参数送ECX
0040143E |. 33FF XOR EDI,EDI ; 把EDI清零
00401440 |&gt; 8BC1 MOV EAX,ECX ; 磁盘类型参数送EAX 00401442 |. 8B1E MOV EBX,DWORD PTR DS:[ESI] ; 把卷标名作为数值送到 EBX
00401444 |. F7E3 MUL EBX ; 循环递减取磁盘类型参数值与卷标名值相乘
00401446 |. 03F8 ADD EDI,EAX ; 每次计算结果再加上上次计算结果保存在EDI中
00401448 |. 49 DEC ECX ; 把磁盘类型参数作为循环次数，依次递减
00401449 |. 83F9 00 CMP ECX,0 ; 判断是否计算完
0040144C |.^ 75 F2 JNZ SHORT CrackHea.00401440 ; 没完继续0040144E |. 893D 9C334000 MOV DWORD PTR DS:[40339C],EDI ; 把计算后值送到内存地址40339C，这就是我们后来在ESI中看到的值
00401454 |. 61 POPAD
00401455 \. C3 RETN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过上面的分析，我们知道基本算法是这样的：先用 <code>GetDriveTypeA</code> 函数获取磁盘类型参数，再用 <code>GetVolumeInformationA</code> 函数获取这个 crackme 程序所在分区的卷标。如我把这个 Crackme 程序放在 <code>F:\OD教程\crackhead\</code> 目录下，而我 F 盘设置的卷标是 <code>GAME</code>，则这里获取的就是 <code>GAME</code>，<code>ASCII</code> 码为“47414D45”。但我们发现一个问题：假如原来我们在数据窗口中看到的地址 <code>40339C</code> 处的 16 进制代码是“47414D45”，即“GAME”，但经过地址 <code>00401442</code> 处的那条 <code>MOV EBX,DWORD PTR DS:[ESI]</code> 指令后，我们却发现 <code>EBX</code> 中的值是“454D4147”，正好把我们上面那个“47414D45”反过来了。为什么会这样呢？如果大家对 x86系列 CPU 的存储方式了解的话，这里就容易理解了。我们知道“GAME”有四个字节，即 <code>ASCII</code> 码为“47414D45”。我们看一下数据窗口中的情况：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040339C 47 41 4D 45 00 00 00 00 00 00 00 00 00 00 00 00 GAME............<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>大家可以看出来内存地址 <code>40339CH</code> 到 <code>40339FH</code> 分别按顺序存放的是 <code>47 41 4D 45</code>。如下图：</p>
<img src="https://i.loli.net/2020/03/22/9hO3yVM5zItWKbs.png" alt="olly-tutorial-32.jpg" style="zoom:150%;" />

<p>系统存储的原则为“高高低低”，即低字节存放在地址较低的字节单元中，高字节存放在地址较高的字节单元中。比如一个字由两个字节组成，像这样：<code>12 34</code> ，这里的高字节就是 <code>12</code> ，低字节就是 <code>34</code>。上面的那条指令 <code>MOV EBX,DWORD PTR DS:[ESI]</code> 等同于 <code>MOV EBX,DWORD PTR DS:[40339C]</code>。注意这里是 <code>DWORD</code>，即“双字”，由 4 个连续的字节构成。而取地址为 <code>40339C</code> 的双字单元中的内容时，我们应该得到的是“454D4147”，即由高字节到低字节顺序的值。因此经过 <code>MOV EBX,DWORD PTR DS: [ESI]</code> 这条指令，就是把从地址 <code>40339C</code> 开始处的值送到 <code>EBX</code>，所以我们得到了“454D4147”。好了，这里弄清楚了，我们再接着谈这个程序的算法。前面我们已经说了取磁盘类型参数做循环次数，再取卷标值 ASCII 码的逆序作为数值，有了这两个值就开始计算了。现在我们把磁盘类型值作为 t，卷标值 <code>ASCII</code> 码的逆序数值作为 a，最后得出的结果作为 b，有这样的计算过程：</p>
<p>第一次：$b = at$</p>
<p>第二次：$b=a\left( t-1\right) +b$</p>
<p>第三次：$b=a\left( t-2\right) +b$</p>
<p>…</p>
<p>第 n 次：$b=a\left( t-n+1\right) +b$</p>
<p>可得出公式为 $b=a[ n+\left( n-1\right) +\left( n-2\right) +\ldots +1]=a\cdot \dfrac {n\left( n+1\right) }{2}$</p>
<p>还记得上一篇我们的分析吗？看这一句：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401405 |. 81F6 53757A79 XOR ESI,797A7553 ; 把ESI中的值与797 A7553H异或<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里算出来的b最后还要和 <code>797A7553H</code> 异或一下才是真正的注册码。只要你对编程有所了解，这个注册机就很好写了。如果用汇编来写这个注册机的话就更简单了，很多内容可以直接照抄。</p>
<p>到此已经差不多了，最后还有几个东西也说一下吧：</p>
<ol>
<li><p>上面用到了两个 API 函数，一个是 <code>GetDriveTypeA</code>，还有一个是 <code>GetVolumeInformationA</code>，关于这两个函数的具体用法我就不多说了，大家可以查一下 MSDN。这里只要大家注意函数参数传递的次序，即调用约定。先看一下这里：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00401419 |. 6A 00 PUSH 0 ; &#x2F;pFileSystemNameSiz
e &#x3D; NULL
0040141B |. 6A 00 PUSH 0 ; |pFileSystemNameBuffe
r &#x3D; NULL
0040141D |. 6A 00 PUSH 0 ; |pFileSystemFlags &#x3D; NULL 0040141F |. 6A 00 PUSH 0 ; |pMaxFilenameLength &#x3D; N ULL
00401421 |. 6A 00 PUSH 0 ; |pVolumeSerialNumbe
r &#x3D; NULL
00401423 |. 6A 0B PUSH 0B ; |MaxVolumeNameSiz
e &#x3D; B (11.)
00401425 |. 68 9C334000 PUSH CrackHea.0040339C ; |VolumeName Buffer &#x3D; CrackHea.0040339C
0040142A |. 6A 00 PUSH 0 ; |RootPathName &#x3D; NULL 0040142C |. E8 A3000000 CALL &lt;JMP.&amp;KERNEL32.GetVolumeInformationA&gt; ; \GetVolumeInformationA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把上面代码后的 OllyDBG 自动添加的注释与 MSDN 中的函数原型比较一下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">BOOL GetVolumeInformation(
LPCTSTR lpRootPathName, &#x2F;&#x2F; address of root directory of the file system LPTSTR lpVolumeNameBuffer, &#x2F;&#x2F; address of name of the volume
DWORD nVolumeNameSize, &#x2F;&#x2F; length of lpVolumeNameBuffer
LPDWORD lpVolumeSerialNumber, &#x2F;&#x2F; address of volume serial number
LPDWORD lpMaximumComponentLength, &#x2F;&#x2F; address of system&#39;s maximum filenam e length
LPDWORD lpFileSystemFlags, &#x2F;&#x2F; address of file system flags
LPTSTR lpFileSystemNameBuffer, &#x2F;&#x2F; address of name of file system
DWORD nFileSystemNameSize &#x2F;&#x2F; length of lpFileSystemNameBuffer
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大家应该看出来点什么了吧？函数调用是先把最后一个参数压栈，参数压栈顺序是从后往前。这就是一般比较常见的 <code>stdcall</code> 调用约定。</p>
</li>
<li><p>我在前面的 <code>00401414</code> 地址处的那条<code>MOV BYTE PTR DS:[4033EC],AL</code>指令后加的注释是“磁盘类型参数送内存地址4033EC”。为什么这样写？大家把前一句和这一句合起来看一下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040140F |. E8 B4000000 CALL &lt;JMP.&amp;KERNEL32.GetDriveTypeA&gt; ; \GetDriv eTypeA
00401414 |. A2 EC334000 MOV BYTE PTR DS:[4033EC],AL ; 磁盘类型参数送内存地址4033EC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>地址 <code>0040140F</code> 处的那条指令是调用 <code>GetDriveTypeA</code> 函数，一般函数调用后的返回值都保存在 <code>EAX</code> 中，所以地址 <code>00401414</code> 处的那一句 <code>MOV BYTE PTR DS:[4033EC],AL</code> 就是传递返回值。查一下 MSDN 可以知道 <code>GetDriveTypeA</code> 函数的返回值有这几个：</p>
<blockquote>
<p>Value Meaning 返回在EAX中的值：</p>
<ul>
<li>DRIVE_UNKNOWN The drive type cannot be determined. 0</li>
<li>DRIVE_NO_ROOT_DIR The root directory does not exist. 1</li>
<li>DRIVE_REMOVABLE The disk can be removed from the drive. 2</li>
<li>DRIVE_FIXED The disk cannot be removed from the drive. 3</li>
<li>DRIVE_REMOTE The drive is a remote (network) drive. 4</li>
<li>DRIVE_CDROM The drive is a CD-ROM drive. 5</li>
<li>DRIVE_RAMDISK The drive is a RAM disk. 6</li>
</ul>
</blockquote>
<p>上面那个“返回在EAX中的值”是我加的，我这里返回的是 3，即磁盘不可从驱动器上删除。</p>
</li>
<li><p>通过分析这个程序的算法，我们发现这个注册算法是有漏洞的。如果我的分区没有卷标的话，则卷标值为 0，最后的注册码就是 <code>797A7553H</code>，即十进制 <code>2038068563</code>。而如果你的卷标和我一样，且磁盘类型一样的话，注册码也会一样，并不能真正做到一机一码。</p>
</li>
</ol>
<h2 id="消息断点及-RUN-跟踪"><a href="#消息断点及-RUN-跟踪" class="headerlink" title="消息断点及 RUN 跟踪"></a>消息断点及 RUN 跟踪</h2><p>找了几十个不同语言编写的 crackme，发现只用消息断点的话有很多并不能真正到达我们要找的关键位置，想想还是把消息断点和 RUN 跟踪结合在一起讲，更有效一点。关于消息断点的更多内容大家可以参考 jingulong 的那篇《几种典型程序Button处理代码的定位》的文章，堪称经典之作。今天仍然选择 crackmes.cjb.net 镜像打包中的一个名称为 cycle 的 crackme。按照惯例，我们先运行一下这个程序看看：</p>
<img src="https://i.loli.net/2020/03/22/W9KGVsxicCamEwq.png" alt="cycle主页面" style="zoom:150%;" />

<p>我们输入用户名 <code>CCDebuger</code>，序列号 <code>78787878</code>，点上面那个“Check”按钮，呵，没反应！看来是要注册码正确才有动静。现在关掉这个 crackme，用 PEiD 查一下壳，原来是 <code>MASM32 / TASM32 [Overlay]</code>。启动 OllyDBG 载入这个程序，F9让它运行。这个程序按我们前面讲的采用字串参考或函数参考的方法都很容易断下来。但我们今天主要学习的是消息断点及 RUN 跟踪，就先用消息断点来断这个程序吧。在设消息断点前，有两个内容我们要简单了解一下：首先我们要了解的是消息。<code>Windows</code> 的中文翻译就是“窗口”，而 <code>Windows</code> 上面的应用程序也都是通过窗口来与用户交互的。现在就有一个问题，应用程序是如何知道用户作了什么样的操作的？这里就要用到消息了。<code>Windows</code> 是个基于消息的系统，它在应用程序开始执行后，为该程序创建一个“消息队列”，用来存放该程序可能创建的各种不同窗口的信息。比如你创建窗口、点击按钮、移动鼠标等等，都是通过消息来完成的。通俗的说，<code>Windows</code> 就像一个中间人，你要干什么事是先通知它，然后它才通过传递消息的方式通知应用程序作出相应的操作。说到这，又有个问题了，在 <code>Windows</code> 下有多个程序都在运行，那我点了某个按钮，或把某个窗口最大化，<code>Windows</code> 知道我是点的哪个吗？这里就要说到另一个内容：句柄（handle）了。句柄一般是个 32 位的数，表示一个对象。<code>Windows</code> 通过使用句柄来标识它代表的对象。比如你点击某个按钮，<code>Windows</code> 就是通</p>
<p>过句柄来判断你是点击了那一个按钮，然后发送相应的消息通知程序。说完这些我们再回到我们调试的程序上来，你应该已经用 OllyDBG 把这个 crackme 载入并按 F9 键运行了吧？现在我们输入用户名“CCDebuger”，序列号“78787878”，先不要点那个“Check”按钮，我们来到 OllyDBG 中，点击菜单查看-&gt;窗口（或者点击工具栏上那个“W”的图标），我们会看到以下内容：</p>
<p><img src="https://i.loli.net/2020/03/22/M8Xuza1p5svNWkD.png" alt="点击工具栏上那个“W”的图标"></p>
<p>我们在选中的条目上点右键，再选择上图所示的菜单项，会来到下面这个窗口：</p>
<p><img src="https://i.loli.net/2020/03/22/59U4w8a6shKZbHV.png" alt="会来到下面这个窗口"></p>
<p>现在我们点击图上的那个下拉菜单，呵，原来里面的消息真不少。这么多消息我们选哪个呢？注册是个按钮，我们就在按下按钮再松开时让程序中断。查一下 MSDN，我们知道这个消息应该是 <code>WM_LBUTTON_UP</code>，看字面意思也可以知道是左键松开时的消息：</p>
<p><img src="https://i.loli.net/2020/03/22/pZKtdjvxqNHeIDP.png" alt="可以知道是左键松开时的消息"></p>
<p>从下拉菜单中选中那个 <code>202 WM_LBUTTON_UP</code>，再按确定按钮，我们的消息断点就设好了。现在我们还要做一件事，就是把 RUN 跟踪打开。有人可能要问，这个 RUN 跟踪是干什么的？简单的说，RUN 跟踪就是把被调试程序执行过的指令保存下来，让你可以查看被调试程序运行期间干了哪些事。RUN 跟踪会把地址、寄存器的内容、消息以及已知的操作数记录到 RUN 跟踪缓冲区中，你可以通过查看 RUN 跟踪的记录来了解程序执行了那些指令。在这还要注意一个缓冲区大小的问题，如果执行的指令太多，缓冲区满了的话，就会自动丢弃前面老的记录。我们可以在调试选项 -&gt; 跟踪中设置：</p>
<p><img src="https://i.loli.net/2020/03/22/y1iqG4a9RnADPTd.png" alt="调试选项 -&gt; 跟踪中设置"></p>
<p>现在我们回到 OllyDBG 中，点击菜单调试-&gt;打开或清除 RUN 跟踪（第一次点这个菜单是打开 RUN 跟踪，在打开的情况下点击就是清除 RUN 跟踪的记录，对 RUN 跟踪熟悉时还可以设置条件），保证当前在我们调试的程序领空，在反汇编窗口中点击右键，在弹出菜单中选择 RUN 跟踪 -&gt; 添加所有函数过程的入口：</p>
<p><img src="https://i.loli.net/2020/03/22/L8Jz3x7HR9oI2U4.png" alt="RUN 跟踪 -&gt; 添加所有函数过程的入口"></p>
<p>我们可以看到 OllyDBG 把识别出的函数过程都在前面加了灰色条：</p>
<p><img src="https://i.loli.net/2020/03/22/yl9zaqAdrP54QWR.png" alt="在前面加了灰色条"></p>
<p>现在我们回到那个 crackme 中按那个“Check”按钮，被 OllyDBG 断下了：</p>
<p><img src="https://i.loli.net/2020/03/22/aLIW8fGObXHhTEr.png" alt="“Check”按钮被OllyDBG断下了"></p>
<p>这时我们点击菜单查看 -&gt; 内存，或者点击工具栏上那个“M”按钮（也可以按组合键 ALT + M），来到内存映射窗口：</p>
<p><img src="https://i.loli.net/2020/03/22/rGxVPkbZRAg1O7S.png" alt="来到内存映射窗口"></p>
<p>为什么在这里设访问断点，我也说一下。我们可以看一下常见的 PE 文件，没加过壳的用 PEiD 检测是这样：</p>
<p><img src="https://i.loli.net/2020/03/22/usLIOqzy4U7XFEh.png" alt="没加过壳的用 PEiD 检测是这样"></p>
<p>点一下 EP 段后面那个“&gt;”符号，我们可以看到以下内容：</p>
<p><img src="https://i.loli.net/2020/03/22/2Rxypf5eJtzmobP.png" alt="点一下 EP 段后面那个“&gt;”符号"></p>
<p>看完上面的图我们应该了解为什么在 <code>401000</code> 处的代码段下访问断点了，我们这里的意思就是在消息断点断下后，只要按 F9 键运行时执行到程序代码段的指令我们就中断，这样就可以回到程序领空了（当然在 <code>401000</code> 处所在的段不是绝对的，我们主要是要看程序的代码段在什么位置，其实在上面图中 OllyDBG 内存窗口的“包含”栏中我们就可以看得很清楚了）。设好访问断点后我们按 F9 键，被 OllyDBG 断下：</p>
<p><img src="https://i.loli.net/2020/03/22/m9i8hJWYCUpDya2.png" alt="按F9被OllyDBG断下"></p>
<p>现在我们先不管，按 F9 键（或者按 CTR+F12 组合键跟踪步过）让程序运行，再点击菜单查看-&gt;RUN 跟踪，或者点击工具栏上的那个“…”符号，打开 RUN 跟踪的记录窗口看看：</p>
<p><img src="https://i.loli.net/2020/03/22/pzJXOKTdZAEVBr1.png" alt="打开 RUN 跟踪的记录窗口看看"></p>
<p>我们现在再来看看统计的情况：</p>
<p><img src="https://i.loli.net/2020/03/22/vYbKuOwQiens3c9.png" alt="再来看看统计的情况"></p>
<p>在地址 <code>401082</code> 处的那条指令上双击一下，来到以下位置：</p>
<p><img src="https://i.loli.net/2020/03/22/fSF31HpaYenzTrD.png" alt="olly-tutorial-47.jpg"></p>
<p>现在我们在地址 <code>4010A6</code> 处的那条指令上按 F2，删除所有其它的断点，点菜单调试 -&gt; 关闭 RUN 跟踪，现在我们就可以开始分析了：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">004010E2 |. 8BFE MOV EDI,ESI ; 用户名送 EDI 004010E4 |. 03F8 ADD EDI,EAX
004010E6 |. FC CLD
004010E7 |. F3:A4 REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]
004010E9 |. 33C9 XOR ECX,ECX ; 清零，设循环计数器004010EB |. BE 71214000 MOV ESI,cycle.00402171 ; 注册码送ESI 004010F0 |&gt; 41 INC ECX
004010F1 |. AC LODS BYTE PTR DS:[ESI] ; 取注册码的每个字符
004010F2 |. 0AC0 OR AL,AL ; 判断是否为空
004010F4 |. 74 0A JE SHORT cycle.00401100 ; 没有则跳走004010F6 |. 3C 7E CMP AL,7E ; 判断字符是否为非ASCII字符
004010F8 |. 7F 06 JG SHORT cycle.00401100 ; 非ASCII字符跳走
004010FA |. 3C 30 CMP AL,30 ; 看是否小于30H，主要是
判断是不是数字或字母等
004010FC |. 72 02 JB SHORT cycle.00401100 ; 小于跳走004010FE |.^ EB F0 JMP SHORT cycle.004010F0
00401100 |&gt; 83F9 11 CMP ECX,11 ; 比较注册码位数，必须为十进制17位
00401103 |. 75 1A JNZ SHORT cycle.0040111F
00401105 |. E8 E7000000 CALL cycle.004011F1 ; 关键，F7跟进去0040110A |. B9 01FF0000 MOV ECX,0FF01
0040110F |. 51 PUSH ECX
00401110 |. E8 7B000000 CALL cycle.00401190 ; 关键，跟进去00401115 |. 83F9 01 CMP ECX,1
00401118 |. 74 06 JE SHORT cycle.00401120
0040111A |&gt; E8 47000000 CALL cycle.00401166 ; 注册失败对话框
0040111F |&gt; C3 RETN
00401120 |&gt; A1 68214000 MOV EAX,DWORD PTR DS:[402168]
00401125 |. 8B1D 6C214000 MOV EBX,DWORD PTR DS:[40216C]
0040112B |. 33C3 XOR EAX,EBX
0040112D |. 3305 82214000 XOR EAX,DWORD PTR DS:[402182]
00401133 |. 0D 40404040 OR EAX,40404040
00401138 |. 25 77777777 AND EAX,77777777
0040113D |. 3305 79214000 XOR EAX,DWORD PTR DS:[402179]
00401143 |. 3305 7D214000 XOR EAX,DWORD PTR DS:[40217D]
00401149 |.^ 75 CF JNZ SHORT cycle.0040111A ; 这里跳走就完蛋
0040114B |. E8 2B000000 CALL cycle.0040117B ; 注册成功对话框<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写到这准备跟踪算法时，才发现这个 crackme 还是挺复杂的，具体算法我就不写了，实在没那么多时间详细跟踪。有兴趣的可以跟一下，注册码是17位，用户名采用复制的方式扩展到 16 位，如我输入“CCDebuger”，扩展后就是“CCDebugerCCDebug”。大致是先取扩展后用户名的前 8 位和注册码的</p>
<p>前 8 位，把用户名的前四位和后四位分别与注册码的前四位和后四位进行运算，算完后再把扩展后用户名的后 8 位和注册码的后 8 位分两部分，再与前面用户名和注册码的前 8 位计算后的值进行异或计算，最后结果等于 0 就成功。注册码的第 17 位我尚未发现有何用处。对于新手来说，可能这个 crackme 的难度大了一点。没关系，我们主要是学习 OllyDBG 的使用，方法掌握就可以了。</p>
<p>最后说明一下：</p>
<ol>
<li><p>这个程序在设置了消息断点后可以省略在代码段上设访问断点那一步，直接打开 RUN 跟踪，消息断点断下后按 CTR+F12 组合键让程序执行，RUN 跟踪记录中就可以找到关键地方。</p>
</li>
<li><p>对于这个程序，你可以不设消息断点，在输入用户名和注册码后先不按那个“Check”按钮，直接打开 R UN 跟踪，添加“所有函数过程的入口”后再回到程序中点“Check”按钮，这时在 OllyDBG 中打开 RUN 跟踪记录同样可以找到关键位置。</p>
</li>
</ol>
<h2 id="汇编功能"><a href="#汇编功能" class="headerlink" title="汇编功能"></a>汇编功能</h2><p>今天我们的目标程序是 <code>MyUninstaller 1.34</code> 版。这是一个非常小的程序卸载工具，<code>VC6</code>编写，大小只有61K。我拿到的这个是上次@闪电狼给我的，附带在里面的简体中文语言文件是由六芒星制作的。这个程序有个毛病：就是在列出的可卸载程序上双击查看属性时，弹出的属性窗口的字体非常难看，应该就是系统字体（<code>SYSTEM_FONT</code>）：</p>
<p><img src="https://i.loli.net/2020/03/22/tNy4dla8brCqRIV.png" alt="字体非常难看"></p>
<p>我们今天的目标就是利用 OllyDBG 的汇编功能把上面显示的字体改成我们常见的9号（小五）宋体。首先我们用 OllyDBG 载入程序，按 CTRL + N 组合键查找一下有哪些 API 函数，只发现一个和设置字体相关的 <code>CreateFontIndirectA</code>。现在我们按鼠标右键，选择“在每个参考上设置断点”，关掉名称对话框，F9运行，程序已经运行起来了。我们在程序的列表框中随便找一项双击一下，很不幸，那个字体难看的界面又出现了，OllyDBG 没有任何动作。可见创建这个窗口的时候根本没调用 <code>CreateFontIndirectA</code>，问题现在就变得有点复杂了。先点确定把这个字体难看的对话框关闭，现在我们从另一个方面考虑：既然没有调用设置字体的函数，那我们来看看这个窗口是如何创建的，跟踪窗口创建过程可能会找到一些对我们有用的信息。现在我们再回到我们调试程序的领空，按 CTRL + N 看一下，发现 <code>CreateWindowExA</code> 这个 API 函数比较可疑。我们在 <code>CreateWindowExA</code> 函数的每个参考上设上断点，在 <code>MyUninstaller</code> 的列表框中再随便找一项双击一下，被 OllyDBG 断下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \断在这里<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上下翻看一下代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F3B |. 50 |PUSH EAX ; |hInst
00408F3C |. 8B45 C0 |MOV EAX,DWORD PTR SS:[EBP-40] ; |
00408F3F |. 6A 00 |PUSH 0 ; |hMenu &#x3D; NULL
00408F41 |. 03C6 |ADD EAX,ESI ; |
00408F43 |. FF75 08 |PUSH DWORD PTR SS:[EBP+8] ; |hParent 00408F46 |. FF75 D0 |PUSH DWORD PTR SS:[EBP-30] ; |Height 00408F49 |. 57 |PUSH EDI ; |Width
00408F4A |. 50 |PUSH EAX ; |Y
00408F4B |. FF75 BC |PUSH DWORD PTR SS:[EBP-44] ; |X
00408F4E |. FF75 EC |PUSH DWORD PTR SS:[EBP-14] ; |Style
00408F51 |. 68 80DE4000 |PUSH myuninst.0040DE80 ; |WindowN ame &#x3D; &quot;&quot;
00408F56 |. 68 DCD94000 |PUSH myuninst.0040D9DC ; |Clas
s &#x3D; &quot;STATIC&quot;
00408F5B |. FF75 D4 |PUSH DWORD PTR SS:[EBP-2C] ; |ExtStyle 00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \断在这里
00408F64 | 6A 00 |PUSH 0 ; 第一处要修改的地方
00408F66 | 8945 F4 |MOV DWORD PTR SS:[EBP-C],EAX
00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;
00408F6E |. 50 |PUSH EAX ; |hInst
00408F6F |. 8B45 DC |MOV EAX,DWORD PTR SS:[EBP-24] ; |
00408F72 |. 6A 00 |PUSH 0 ; |hMenu &#x3D; NULL
00408F74 |. 03F0 |ADD ESI,EAX ; |
00408F76 |. FF75 08 |PUSH DWORD PTR SS:[EBP+8] ; |hParent 00408F79 |. FF75 CC |PUSH DWORD PTR SS:[EBP-34] ; |Height 00408F7C |. 53 |PUSH EBX ; |Width
00408F7D |. 56 |PUSH ESI ; |Y
00408F7E |. FF75 D8 |PUSH DWORD PTR SS:[EBP-28] ; |X
00408F81 |. FF75 E8 |PUSH DWORD PTR SS:[EBP-18] ; |Style
00408F84 |. 68 80DE4000 |PUSH myuninst.0040DE80 ; |WindowN ame &#x3D; &quot;&quot;
00408F89 |. 68 D4D94000 |PUSH myuninst.0040D9D4 ; |Clas
s &#x3D; &quot;EDIT&quot;
00408F8E |. FF75 B8 |PUSH DWORD PTR SS:[EBP-48] ; |ExtStyle 00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F97 | 8945 F0 |MOV DWORD PTR SS:[EBP-10],EAX ; 第二处要修改的地方
00408F9A | 8B45 F8 |MOV EAX,DWORD PTR SS:[EBP-8]
00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; &#x2F;&lt;%s&gt;
00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |
00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |forma
t &#x3D; &quot;%s:&quot;
00408FAA |. 50 |PUSH EAX ; |s
00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \ sprintf
00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowText A&gt;] ; USER32.SetWindowTextA
00408FB7 |. 83C4 0C |ADD ESP,0C
00408FBA |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150]
00408FC0 |. 50 |PUSH EAX ; &#x2F;Text
00408FC1 |. FF75 F4 |PUSH DWORD PTR SS:[EBP-C] ; |hWnd
00408FC4 |. FFD6 |CALL ESI ; \SetWindowTextA
00408FC6 |. 8D85 ACFAFFFF |LEA EAX,DWORD PTR SS:[EBP-554]
00408FCC |. 50 |PUSH EAX ; &#x2F;Arg3
00408FCD |. FF75 FC |PUSH DWORD PTR SS:[EBP-4] ; |Arg2
00408FD0 |. FF35 00EF4000 |PUSH DWORD PTR DS:[40EF00] ; |Arg 1 &#x3D; 00BEADCC
00408FD6 |. E8 1884FFFF |CALL &lt;myuninst.sub_4013F3&gt; ; \sub_40 13F3
00408FDB |. 83C4 0C |ADD ESP,0C
00408FDE |. 50 |PUSH EAX
00408FDF |. FF75 F0 |PUSH DWORD PTR SS:[EBP-10]
00408FE2 |. FFD6 |CALL ESI
00408FE4 |. FF45 FC |INC DWORD PTR SS:[EBP-4]
00408FE7 |. 8345 F8 14 |ADD DWORD PTR SS:[EBP-8],14
00408FEB |. 837D FC 0F |CMP DWORD PTR SS:[EBP-4],0F
00408FEF |.^ 0F8C 32FFFFFF \JL &lt;myuninst.loc_408F27&gt;
00408FF5 |. 5F POP EDI
00408FF6 |. 5E POP ESI
00408FF7 |. 5B POP EBX
00408FF8 |. C9 LEAVE
00408FF9 \. C3 RETN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我想上面的代码我不需多做解释，OllyDBG 自动给出的注释已经够清楚的了。我们双击 <code>MyUninstaller</code> 列表框中的的某项查看属性时，弹出的属性窗口上的 <code>STATIC</code> 控件和 <code>EDIT</code> 控件都是由 <code>CreateWindowExA</code> 函数创建的，然后再调用 <code>SetWindowTextA</code> 来设置文本，根本没考虑控件上字体显示的问题，所以我们看到的都是系统默认的字体。我们要设置控件上的字体，可以考虑在 <code>CreateWindowExA</code> 创建完控件后，在使用 <code>SetWindowTextA</code> 函数设置文本之前调用相关字体创建函数来选择字体，再调用 <code>SendMessageA</code> 函数发送 <code>WM_SETFONT</code> 消息来设置控件字体。思路定下来后，我们就开始来实施。首先我们看一下这个程序中的导入函数，CreateFontIndirectA 这个字体创建函数已经有了，再看看 <code>SendMessageA</code>，呵呵，不错，原程序也有这个函数。这样我们就省事了。有人可能要问，如果原来并没有这两个导入函数，那怎么办呢？其实这也很简单，我们可以直接用 <code>LordPE</code> 来在程序中添加我们需要的导入函数。我这里用个很小的 PE 工具 <code>zeroadd</code> 来示范一下，这个程序里面没有 <code>CreateFontIndirectA</code> 和 <code>SendMessageA</code> 函数（这里还有个问题说一下，其实我们编程时调用这两个函数时都是直接写 <code>CreateFontIndirect</code> 及 <code>SendMessage</code>，一般不需指定。但在程序中写补丁代码时我们要指定这是什么类型的函数。这里在函数后面加个“A”表示这是 <code>ASCII</code> 版本，同样 <code>UNICODE</code> 版本在后面加个“W”，如 <code>SendMessageW</code>。在 <code>Win9X</code> 下我们一般都用 <code>ASCII</code> 版本的函数，<code>UNICODE</code> 版本的函数很多在 <code>Win9X</code> 下是不能运行的。而NT系统如 <code>WinXP</code> 一般都是 <code>UNICODE</code> 版本的，但如果我们用了 <code>ASCII</code> 版本的函数，系统会自动转换调用 <code>UNICODE</code> 版本。这样我们写补丁代码的时候就可以直接指定为 <code>ASCII</code> 版本的函数，可</p>
<p>以兼容各个系统）：我们用 <code>LordPE</code> 的 PE 编辑器载入 <code>zeroadd</code> 程序，选择“目录”，再在弹出的目录表对话框中选择输入表后面的那个“…”按钮，会弹出一个对话框：</p>
<p><img src="https://i.loli.net/2020/03/22/riQHdDxMPjZlTAw.png" alt="会弹出一个对话框"></p>
<p>因为 <code>SendMessageA</code> 在 <code>USER32.dll</code> 中，我们在右键菜单中点击按钮“添加导入表”，来到下面：</p>
<img src="https://i.loli.net/2020/03/22/M7pml2QvNIrcJER.png" alt="输入表对话框" style="zoom:150%;" />

<p><img src="https://i.loli.net/2020/03/22/riQHdDxMPjZlTAw.png" alt="点击按钮“添加导入表”"></p>
<p>按上面的提示完成后点“确定”，我们回到原先的那个“输入表”对话框：</p>
<p><img src="https://i.loli.net/2020/03/22/YQidyqpFzmVe6AI.png" alt="回到原先的那个“输入表”对话框"></p>
<p>从上图中我们可以看出多出了一个 <code>USER32.dll</code>，这就是我们添加 <code>SendMessageA</code> 的结果。这也是用工具添加的一个缺点。我们一般希望把添加的函数直接放到已存在的 <code>DLL</code> 中，而不是多出来一个，这样显得不好看。但用工具就没办法，<code>LordPE</code> 默认是建一个 1K 的新区段来保存添加后的结果，由此出现了上图中的情况。如果你对 PE 结构比较熟悉的话，也可以直接用16进制编辑工具来添加你需要的函数，这样改出来的东西好看。如果想偷懒，就像我一样用工具吧。在上图中我还标出了要注意 <code>FirstThunk</code> 及那个 <code>ThunkRVA</code> 的值，并且要把“总是查看<code>FirstThunk</code>”那个选项选上。有人可能不理解其作用，我这里也解释一下：一般讲述 PE 格式的文章中对 <code>FirstThunk</code> 的解释是这样的：<code>FirstThunk</code> 包含指向一个 <code>IMAGE_THUNK_DATA</code> 结构数组的 RVA 偏移地址，当把 PE 文件装载到内存中时，PE装载器将查找 <code>IMAGE_THUNK_DATA</code> 和 <code>IMAGE_IMPORT_BY_NAME</code> 这些结构数组来决定导入函数的地址，随后用导入函数真实地址来替代由 <code>FirstThunk</code> 指向的 <code>IMAGE_THUNK_DATA</code> 数组里的元素值。</p>
<p>这样说起来还是让人不明白，我举个例子：比如你有个很要好的朋友，他是个大忙人，虽然你知道他的家庭住址，可他很少回家。如果你哪天想找他，直接去他家，很可能吃个闭门羹，找不到他人。怎么办？幸好你有他的手机号码，你就给他拨了一个电话：“小子，你在哪呢？”，他告诉你：“我正在XXX饭店喝酒呢！”这时你怎么办？（当然是杀到他说的那家饭店去蹭饭了！^_^）这里的 <code>ThunkRVA</code> 就相当于你朋友的手机号码， <code>SendMessageA</code> 就相当于你那个朋友。而 <code>FirstThunk</code> 就是你手机里的号码分组。你把你的多个朋友都放在 <code>FirstThunk</code> 这样的号码分组里，每个 <code>ThunkRVA</code> 就是你一个朋友的手机号码。你要找他们，就是通过 <code>ThunkRVA</code> 这样的手机号码来和他们联系，直接去他家找他你很可能要碰壁。而移动或联通就相当于操作系统，他们负责把你的手机号码和你的朋友对应上。而 <code>FirstThunk</code> 这样的号码分组还有一个好处就是你可以不记你某个朋友的具体号码，只要记得 <code>FirstThunk</code> 号码分组的值，你的朋友会按顺序在里面排列。比如上图中 <code>USER32.dll</code> 中的第一个函数是 <code>SendMessageA</code>，它的 <code>ThunkRVA</code> 值就是 <code>FirstThunk</code> 值。如果还有第二个函数，比如是 <code>MessageBoxA</code>，它的值就是 <code>FirstThunk</code> 值加上 4，其余类推。你只要记住各个函数的位置，也可以通过 <code>FirstThunk</code> 加上位置对应值来找到它。当然这比不上直接看 <code>ThunkRVA</code> 来得方便。</p>
<p>说了上面这些，我们就要考虑怎么在程序中调用了。你可能会说，我在 OllyDBG 中直接在我们要修改的程序中这样调用：<code>CALL SendMessageA</code>。哦，别这样。这等于我上面说的都是废话，会让我感到伤心的。你这里的 <code>CALL SendMessageA</code> 就相当于也不跟你朋友打个招呼就直接去他家找他，很有可能你会乘兴而去，败兴而归。别忘了他的手机号码，我们只有通过号码才知道他到底在什么地方。我们应该这样：<code>CALL DWORD PTR [40B01A]</code>，这里的 <code>40B01A</code> 就是上面的 <code>SendMessageA</code> 在程序载入后的所在的地方，由基址 <code>00400000</code> 加上 <code>ThunkRVA 0000B01A </code>得到的。这就是你要找的人所在的地方，不管他跑到哪，你有他的手机号码就能找到他。同样道理，你只要记住了 <code>ThunkRVA</code> 值，就按这个来调用你需要的函数，在别的 <code>Windows</code> 系统下也是没有问题的。系统会自动把你要找到函数和 <code>ThunkRVA</code> 值对应上。而你在 OllyDBG 中写 <code>CALL SendMessageA</code>，可能你在你的系统上成功了，可放到别的系统下就要出错了。为什么？因为你找的人已经不在原来的位置了，他跑到别的地方去了。你还到老地方找他，当然看不见人了。说了这么多废话，也不知大家听明白了没有，别越听越糊涂就行了。总之一句话，别像 CALL <code>SendMessageA</code> 这样直接调用某个函数，而应该通过 <code>ThunkRVA</code> 值来调用它。下面我们回到我们要修改的 <code>MyUninstaller</code> 上来，先用 <code>LordPE</code> 打开看一下，呵呵，原来 <code>CreateFontIndirectA</code> 和 <code>SendMessageA</code> 原程序里面都有了，省了我们不少事情。看一下这两个函数的 <code>ThunkRVA</code> 值，<code>CreateFontIndirectA</code> 在 <code>GDI32.dll</code> 里面，<code>ThunkRVA</code> 值是 <code>0000B044</code>，这样我们就知道在程序中调用它的时候就是 <code>CALL DWORD PTR [0040B044]</code>。同样，<code>SendMessageA</code> 的<code>Thunk RVA</code> 值是 <code>0000B23C</code>，调用时应该是这样：<code>CALL DWORD PTR [0040B23C]</code>。了解了这些东西我们就来考虑怎么写代码了。首先我们来看一下 <code>CreateFontIndirectA</code> 和 <code>SendMessageA</code> 这两个函数的定义</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CreateFontIndirectA：
HFONT CreateFontIndirect(
CONST LOGFONT *lplf &#x2F;&#x2F; pointer to logical font structure
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>CreateFontIndirect</code>的返回值就是字体的句柄。</p>
<p>对于这个函数我们需要的参数就是给它一个 <code>LOGFONT</code> 的字体结构指针，我们只要在要修改程序的空白处建一个标准的9号（小五）宋体的 <code>LOGFONT</code> 字体结构，再把指针给 <code>CreateFontIndirectA</code> 就可以了。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SendMessageA：
LRESULT SendMessage(
HWND hWnd, &#x2F;&#x2F; handle of destination window
UINT Msg, &#x2F;&#x2F; message to send
WPARAM wParam, &#x2F;&#x2F; first message parameter
LPARAM lParam &#x2F;&#x2F; second message parameter
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的第一个参数是窗口句柄，我们知道 <code>CreateWindowExA</code> 返回的就是窗口句柄，我们可以直接拿来用。第二个消息参数我们这里是设置字体，选<code>WM_SETFONT</code>，这个值是 30H。第三个参数是字体句柄，可以由上面的 <code>CreateFontIndirectA</code> 获得。第四个参数我们不需要，留空。现在我们准备开始写代码，首先我们要在程序中建一个标准9号宋体的 <code>LOGFONT</code>，以便于我们调用。对于 <code>LOGFONT</code>，我们再来看一下定义：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">typedef struct tagLOGFONT &#123; &#x2F;&#x2F; lf
LONG lfHeight;
LONG lfWidth;
LONG lfEscapement;
LONG lfOrientation;
LONG lfWeight;
BYTE lfItalic;
BYTE lfUnderline;
BYTE lfStrikeOut;
BYTE lfCharSet;
BYTE lfOutPrecision;
BYTE lfClipPrecision;
BYTE lfQuality;
BYTE lfPitchAndFamily;
TCHAR lfFaceName[LF_FACESIZE];
&#125; LOGFONT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样我们的标准9号宋体的 <code>LOGFONT</code> 值应该是32字节，16进制就像这样：<code>F4FFFFFF000000000000000000000000900100000000008600000000CBCECCE5</code>。现在在程序中找个空地。我们用 PE iD 来帮助我们寻找，用 PEiD 打开程序，点 EP 段后面的那个 &gt; 号，随便选择一个区段右击，选“搜索全0处”（原版好像是<code>cave</code>什么的）：</p>
<p><img src="https://i.loli.net/2020/03/22/SOAongZ28jzfBKs.png" alt="搜索全0处"></p>
<p>我们看到 PEiD 把搜索到的空间都给我们列出来了：</p>
<p><img src="https://i.loli.net/2020/03/22/DrHwGFpBvxs4kud.png" alt="都给我们列出来了"></p>
<p>现在我们用 <code>WinHEX</code> 打开我们要修改的程序，转到偏移 9815 处，从 9815 处选择 32 字节（16进制是0X20）的一个选块，把光标定位到 9815 处，右键选择菜单剪贴板数据 -&gt; 写入(从当前位置覆写)，随后的格式选择 <code>ASCII Hex</code>，把我们 <code>LOGFONT</code> 的 16 进制值</p>
<p><code>F4FFFFFF000000000000000000000000900100000000008600000000CBCECCE5</code></p>
<p>写入保存。现在我们用 OllyDBG 载入已添加了 LOGFONT 数据的程序，先转到 VA 40A415 处（从上图中看到的）往下看一下：</p>
<p><img src="https://i.loli.net/2020/03/22/AUWcNsPTdJFhG2k.png" alt="往下看一下"></p>
<p>因为 <code>SendMessageA</code> 还要用到一个窗口句柄，我们可以通过前面的 <code>CreateWindowExA</code> 来获得。现在我们就把前一张图中的 <code>.rdata</code> 区段中的地址 <code>0040C56E</code> 作为我们保存窗口句柄 <code>HWND</code> 值的临时空间。一切就绪，开始写代码。先回顾一下我们最先说的那两个要修改的地方：</p>
<p>第一个要改的地方：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F64 6A 00 PUSH 0 ; 修改前
00408F66 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX
00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改后：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F64 E9 D5140000 JMP myuninst.0040A43E ; 跳转到我们的补丁代码处
00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二个要改的地方：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F97 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX ; 改这里 00408F9A 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]
00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; &#x2F;&lt;%s&gt;
00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |
00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |forma t &#x3D; &quot;%s:&quot;
00408FAA |. 50 |PUSH EAX ; |s
00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \ sprintf
00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowText A&gt;] ; USER32.SetWindowTextA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改后</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F97 E9 D4140000 JMP myuninst.0040A470 ; 跳到我们的第二部分补丁代码处
00408F9C 90 NOP
00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX] ; &#x2F;&lt;%s&gt;
00408F9F |. 8D85 B0FEFFFF |LEA EAX,DWORD PTR SS:[EBP-150] ; |
00408FA5 |. 68 D0D94000 |PUSH myuninst.0040D9D0 ; |forma t &#x3D; &quot;%s:&quot;
00408FAA |. 50 |PUSH EAX ; |s
00408FAB |. FF15 90B14000 |CALL DWORD PTR DS:[&lt;&amp;MSVCRT.sprintf&gt;] ; \ sprintf
00408FB1 |. 8B35 84B24000 |MOV ESI,DWORD PTR DS:[&lt;&amp;USER32.SetWindowTextA&gt;] ; USER32.SetWindowTextA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个地方的修改都是把原代码改成跳转，跳到我们的补丁代码那继续执行。在修改之前先把原代码复制下来，以便恢复。我们在 OllyDBG 中按 CTRL + G 组合键，来到 <code>0040A43E</code> 地址处，开始输补丁代码：</p>
<p><img src="https://i.loli.net/2020/03/22/mfXY3KxrpeO4SLh.png" alt="开始输补丁代码"></p>
<p>同样，我们也在 0040A470 地址处输入我们另一部分的补丁代码。两部分的补丁代码分别如下：</p>
<p>补丁代码1：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040A43E 60 PUSHAD ; 保护现场
0040A43F A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX ; 保存窗口句柄
0040A444 68 15A44000 PUSH myuninst.0040A415 ; 传递字体句柄LOGFONT
0040A449 FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirectA&gt;] ; GDI32.CreateFontIndirectA
0040A44F 6A 00 PUSH 0 ; lParam 参数留空
0040A451 50 PUSH EAX ; 字体句柄LOGFONT 0040A452 6A 30 PUSH 30 ; WM_SETFONT
0040A454 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; 窗口句柄送ECX
0040A45A 51 PUSH ECX ; 压入窗口句柄参数
0040A45B FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; USER32.SendMessageA
0040A461 61 POPAD ; 恢复现场
0040A462 6A 00 PUSH 0 ; 恢复原代码
0040A464 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX
0040A467 ^ E9 FDEAFFFF JMP myuninst.00408F69 ; 返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>补丁代码2：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040A470 &gt; \60 PUSHAD
0040A471 . A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX
0040A476 . 68 15A44000 PUSH myuninst.0040A415 ; &#x2F;pLogfon
t &#x3D; myuninst.0040A415
0040A47B . FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirect A&gt;] ; \CreateFontIndirectA
0040A481 . 6A 00 PUSH 0 ; &#x2F;lParam &#x3D; 0
0040A483 . 50 PUSH EAX ; |wParam
0040A484 . 6A 30 PUSH 30 ; |Message &#x3D; WM_SET FONT
0040A486 . 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; |
0040A48C . 51 PUSH ECX ; |hWnd &#x3D;&gt; NULL
0040A48D . FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; \SendMessageA
0040A493 . 61 POPAD
0040A494 . 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX
0040A497 . 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]
0040A49A .^ E9 FEEAFFFF JMP myuninst.00408F9D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为补丁代码2与补丁代码1类似，我就不做详细解释了。现在我们的代码都写完了，现在我们开始保存我们的工作，选中我们修改的代码，点击鼠标右键，会出来一个菜单：</p>
<p><img src="https://i.loli.net/2020/03/22/csar69L4KgdfXjB.png" alt="会出来一个菜单"></p>
<p>们左键选所有修改（当然选它了，要不然只会保存我们选定的这一部分。关于这个地方还要说一下，有的时候我们修改完程序选“复制到可执行文件”时只有“选择”菜单，没有“所有修改”菜单项。按 OllyDBG 帮助里关于备份功能的说法，好像是受内存块限制的，补丁功能也同样是这样。对于备份及补丁功能我用的比较少，并不是很了解，这方面的内容还是大家自己去研究吧，有什么好的心得也希望能共享一下。我遇到不能保存所有修改的情况就是先把补丁代码全部复制下来，同时利用二进制功能复制代码，先选一段补丁代码保存为文件，再用 OllyDBG 打开保存后的文件，转到相应位置分别把我们复制下来的补丁二进制代码粘贴上去后保存。纯属笨办法，当然你也可以用 <code>HexView</code> 这样的工具来修改代码），随后会出来一个“把选中的内容复制到可执行文件”的对话框，我们选“全部复制”，又出来一个对话框，我们在上面点右键，在弹出的菜单上选“保存文件”：</p>
<p><img src="https://i.loli.net/2020/03/22/k7VzvgsTOFZmURn.png" alt="保存文件"></p>
<p>这时会出来一个另存文件的对话框，我们另选一个名字如 <code>myuninst1.exe</code> 来保存，不要直接覆盖原文件 <code>myuninst.exe</code>，以便于出错后好修改。现在关闭 OllyDBG，先不要急着运行刚刚修改过的文件，因为我们还有个地方要改一下。大家还记得我们在 <code>.rdata</code> 中用了个地方作为我们保存临时变量的地方吧？原先的 <code>.rdata</code> 段属性设置是不可写的，现在我们写入了数据，运行时是会出错的。现在我们要修改一下 <code>.rdata</code> 段的属性。用 <code>LordPE</code> 的 PE 编辑器打开我们修改后的程序，点“区段”按钮，在弹出的对话框中点击 <code>.rdata</code> 段，右键选择弹出菜单中的“编辑区段”：</p>
<p><img src="https://i.loli.net/2020/03/22/aL17cJYkNewsSKo.png" alt="编辑区段"></p>
<p>在弹出的对话框中选标志后面那个“…”按钮：</p>
<p><img src="https://i.loli.net/2020/03/22/WieCyLUpvPFzTY4.png" alt="编辑区段"></p>
<p>现在我们把区段标志添加一个可写入的属性：</p>
<p><img src="https://i.loli.net/2020/03/22/VlUs5XcHWOv87iR.png" alt="可写入的属性"></p>
<p>完成后按确定保存我们所做的工作，运行一下修改后的程序，呵呵，终于把字体改过来了：</p>
<p><img src="https://i.loli.net/2020/03/22/d5cEb4q6QTtOG8e.png" alt="终于把字体改过来了"></p>
<p>如果你运行出错也没关系，用 OllyDBG 调试一下你修改后的程序，看看错在什么地方。这一般都是输入补丁代码时造成的，你只要看一下你补丁代码运行的情况就可以了。到这里我们的任务似乎也完成了，但</p>
<p>细心的朋友可能会发现补丁代码1和补丁代码2前面的代码基本上是相同的。一个两个这样的补丁还好，如果要是多的话，这样重复就要浪费不少空间了，况且工作量也相应加大了。既然前面有很多代码都是重复的，为什么我们不把这些重复的代码做成一个子程序呢？这样调用起来要方便的多。下面我们把前面的补丁代码修改一下，我们先把补丁代码1的代码改成这样：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040A43E 60 PUSHAD ; 保护现场
0040A43F A3 6EC54000 MOV DWORD PTR DS:[40C56E],EAX ; 保存窗口句柄
0040A444 68 15A44000 PUSH myuninst.0040A415 ; 我们建的L OGFONT对应指针
0040A449 FF15 44B04000 CALL DWORD PTR DS:[&lt;&amp;GDI32.CreateFontIndirectA&gt;] ; GDI32.CreateFontIndirectA
0040A44F 6A 00 PUSH 0 ; lParam 参数留空
0040A451 50 PUSH EAX ; 字体句柄
0040A452 6A 30 PUSH 30 ; WM_SETFONT
0040A454 8B0D 6EC54000 MOV ECX,DWORD PTR DS:[40C56E] ; 窗口句柄
0040A45A 51 PUSH ECX ; 窗口句柄压栈
0040A45B FF15 3CB24000 CALL DWORD PTR DS:[&lt;&amp;USER32.SendMessageA&gt;] ; USER32.SendMessageA
0040A461 61 POPAD ; 恢复现场
0040A462 C3 RETN ; 返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样我们的子程序代码就写好了。现在我们再在子程序代码后面写上两个补丁代码，当然不要忘了改前面原程序中的跳转：</p>
<p>修改后的补丁代码1：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040A467 E8 D2FFFFFF CALL myuninst.0040A43E ; 调用子程序 0040A46C 6A 00 PUSH 0 ; 恢复前面修改过的代码 0040A46E 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX
0040A471 ^ E9 F3EAFFFF JMP myuninst.00408F69 ; 返回继续执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>修改后的补丁代码2：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0040A47A E8 BFFFFFFF CALL myuninst.0040A43E
0040A47F 8945 F0 MOV DWORD PTR SS:[EBP-10],EAX
0040A482 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]
0040A485 ^ E9 13EBFFFF JMP myuninst.00408F9D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我在每个补丁代码片断间留了4个字节来分隔。同样，我们还要修改一下我们前面的跳转：</p>
<p>第一个要修改跳转的地方：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F5E |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \断在这里
00408F64 E9 FE140000 JMP myuninst.0040A467 ; 跳到我们的第一部分补丁代码处
00408F69 |. E8 A098FFFF |CALL &lt;myuninst.sub_40280E&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二个要修改跳转的地方：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00408F91 |. FF15 98B24000 |CALL DWORD PTR DS:[&lt;&amp;USER32.CreateWindowEx A&gt;] ; \CreateWindowExA
00408F97 E9 DE140000 JMP myuninst.0040A47A ; 跳到我们的第二部分补丁代码处
00408F9C 90 NOP
00408F9D |. FF30 |PUSH DWORD PTR DS:[EAX]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改好后保存，同样不要忘了再修改一下 <code>.rdata</code> 区段的属性。运行一下，一切OK！</p>
<blockquote>
<p>本文完，再次感谢作者CCDebuger！</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>院落伴我远行</title>
    <url>/posts/62d8e15f/</url>
    <content><![CDATA[<p>我们家的奢侈，不在于西洋家具，不在于开阔视野，不在于现代艺术，也不在于高端科技。但是，在高楼耸立、跟电梯打交道的今天，能有一个陪伴我13年的小院子，自然、古朴、清闲，我已经很知足了。</p>
<p>这个小院，竟牵起我的不少思绪，教会我不少道理。</p>
<p>与我同庚的房子并不豪华，当我寻思何要执着于此，我看见窗外：院落成矩形，比我矮的原木栅栏，一面贴墙，三面正巧框住家门和客厅的窗户，家门正对的栅栏开着一个小门。牡丹与海棠在这里挥洒笔墨；成片的绿草占了半个院子；攀着葡萄架的凌霄一树两用，春夏作蚂蚁蜜蜂之美食，秋冬作无家麻雀之鸟巢；<u>最具有特色的是一条小河连接的“南湖北湖”，鱼儿潜跃，由南湖水泵驱动的北湖瀑布“倾泻而下”</u>，仿木的小桥横跨而过，构成一种闲情逸致、自然的景观美。</p>
<p>我九十岁的一次冬月中旬，院子里洗车水枪被盗，我为院子安防干着急，想换上铁栅栏。妈妈指了指：院门只有简单的门闩，从外面就可以伸手打开。即使是小孩也可以轻松地窥进院里的景色，流浪的小猫小狗也可以从栅栏随随便进进出出。被盗的只是一个水枪，<strong>院里春色既然关不住，那何必要关呢？</strong></p>
<p>2019年冰冻的前一夜，因为种种原因，我们忘记把室外的鱼转移到室内的鱼缸里。第二天早上，池水出乎意料全部结冰，<u>所有的鱼儿被定格成了冰雕，姿态不一，有的仿佛飘逸的仙人，有的仿佛挣扎于绝境。</u>我一时不知是喜是悲，直到妈妈走进，才哭出声来。鱼儿们的结局，是我记忆中的一个断片，一片空白，但我至今想起都追悔莫及，<strong>是我没有尽到责任。</strong>自此，我家永不养鱼。</p>
<p>这个小院落，正在经受着时光的冲刷：夏天蚊子过多，池水被抽干；上了初中，只能一周见一次；院内的角角落落，也日渐腐朽……<strong>但院落确乎如母亲一般，偷偷在游子的行囊中，塞满了生活必需品。</strong></p>
<p>它与我的故事，将是一段永恒的记忆。</p>
<blockquote>
<p>本文原创，下面也是原创的阅读题，纯属学习交流使用，答案也附在下面，有能力的同学可以自己坐着玩。商用或推广需联系作者。</p>
</blockquote>
<h1 id="阅读题"><a href="#阅读题" class="headerlink" title="阅读题"></a>阅读题</h1><ol>
<li><p>文中第二自然段起到了什么作用？（2分）</p>
</li>
<li><p>第二自然段“思绪”“道理”在文中指的是什么？（3分）</p>
</li>
<li><p>赏析文中划线的句子。<br>(1) <u>最具有特色的是一条小河连接的“南湖北湖”，鱼儿潜跃，由南湖水泵驱动的北湖瀑布“倾泻而下”。</u>（3分）</p>
<p>(2) <u>所有的鱼儿被定格成了冰雕，姿态不一，有的仿佛飘逸的仙人，有的仿佛挣扎于绝境。</u>（3分）</p>
</li>
<li><p>第一自然段中，“我已经很知足了”，为什么？（2分）</p>
</li>
<li><p>如何理解第六自然段的“但院落确乎如母亲一般，偷偷在游子的行囊中，塞满了生活必需品”一句？（4分）</p>
</li>
<li><p>文中“它与我的故事，将是一段永恒的记忆”。在你的生活中，是否也有伴你远行的信物或者回忆？按照本文的形式，简单说说，100字左右。（10分）</p>
</li>
</ol>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol>
<li>承上启下。承接上文“介绍小院子”，引出并概括下文“小院子教会我的道理”。<strong>解析：本题比较简单，回答关系后，再展开说即可。</strong></li>
<li>（1）品味生活真味比执着于“表面豪华”更好（2）不要过于吝啬，要学会分享（3）要对自己所爱的事物负责任。<strong>解析：关键在于总结3～5段所表达的思想，一条一分，相对简单。</strong></li>
<li>赏析题<ol>
<li>使用夸张和幽默的写作手法，将池子说成湖，体现出小小院落在作者心里所占的空间之大，表达出作者对院落以及院落水景的喜爱之情。<strong>解析：指出手法，写出手法直接作用，最后点名中心即可。</strong></li>
<li>使用比喻的手法，将冰冻的鱼儿比喻成仙人，写出冰冻下鱼儿飘逸的特点，侧面反映出作者内心的一片空白，表达出作者对鱼儿的喜爱与惋惜，以及对自己不负责任的痛心疾首之情。<strong>解析：比喻很好判断，关键是这里的感情一定要联系上下文体会，一条一分。</strong></li>
</ol>
</li>
<li>因为别人都在高楼大厦居住，很少能接近自然，然而我却得以在院子中畅游。<strong>解析：答出别人与我两点即可。</strong></li>
<li>使用了比喻的手法，意思是说院落像母亲一样，在作者变得繁忙、与院子疏远之际，不知不觉在我的记忆中，填充了难忘的回忆与做人道理，与我同行，伴我终生。<strong>解析：理解题关键要把每一个词语解释出来。</strong></li>
<li>略</li>
</ol>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>青春岁月，我与11点相约</title>
    <url>/posts/19eed9be/</url>
    <content><![CDATA[<p>晚上11点到了。</p>
<p>我钻在被窝里，脑子里昏昏沉沉，却浑身上下暖暖和和。屋内屋外仿佛凝成了一锭墨块，深沉得化不开。钟表里的指针在角落中无声地旋转着，没有给谁看的意思。夜灯在隐秘的角落孤独地闪烁着昏黄的灯光，也快睡着了。台灯是冰冷的；桌子早就入睡了，一动不动地沉寂着；铅笔、橡皮和几册童话仿佛是它的孩子，也盖着被子。</p>
<p>又是一个晚上11点，除夕晚上。</p>
<p>这次我是在客厅，大脑极度兴奋，我一边看着《春节联欢晚会》，一边朝着寒假作业上划拉。这是我第一次目睹临近午夜的表盘长什么样。客厅里灯火通明，昔日清净的土地，现在几乎变成一块舞池。电视闪烁着刺眼的霓虹，一颗颗像素仿佛小精灵，从屏幕中跳跃出来，再钻进瞳孔里。爸爸和妈妈反倒不如以往兴奋了，耷拉着头，盯着手机，诶、诶地回答着我的问题。我本打算跟风“跨年”，但是想到小孩熬夜不好，忍不住，还是躺到床上进入梦乡。</p>
<p>晚上11点悄然而至。</p>
<p>黑暗的书房，只有台灯与我。虽然那灯不怎么亮，却如同一颗恒星，指使我坚持下去。下面是作业与书本，我将自己埋在其中，丝毫没有察觉周围的变化。我不知道它们有多少，但是，一字落笔，我又将任务推进了百分之一。笔尖走过的地方，笔迹龙飞凤舞却不见脏乱差；手未经过的题目，一个个括号仿佛一张张饥饿的嘴巴，等着我塞满；我迫不及待将它们填上，更有一种爽快之感。</p>
<p>抬起头来，钟表上只剩下的一根指针，着实让我吓了一跳。</p>
<p>这些所有我经历过的11点，仿佛历经沧桑的皱纹，愈发清晰。这些过往，从稚嫩到成熟，见证了我生活的一点一滴，以及</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>你没看错：动手开发GUI简单操作系统（一）</title>
    <url>/posts/88254ba6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我终于想好发布这篇文章，以前自己一直在摸索开发，保证100%原创。这个操作系统异常简单，没有Windows的高级，没有OS X的华丽，更没有Linux的强大——也别指望了，<strong>对于个人来说根本没多少生产力，只能用来学习知识，自己整着玩。</strong>但是，OS开发的资料太少了，“你没看错”系列中的每一行代码，确实是作者我本人摸滚打爬才得来的。</p>
<p>或许我的文字在各位大佬眼中会很简单。所以说，我尽力吧，简明易懂，不加废话。如果有不专业的地方，直接留言改正，谢谢。</p>
<p>我准备出一系列“你没看错”文章，一定会有后续的。OS一篇文章讲不完，我的写法是理论和实践相辅相成，一点点讲。</p>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><p>第一天我们的目标很简单，主要是写启动扇区：</p>
<ol>
<li>实现在启动扇区打印字符串</li>
<li>在启动扇区打印地址</li>
<li>添加读取磁盘的功能</li>
</ol>
<p>这些实现主要是为以后加载内核、出现错误调试做准备。</p>
<h1 id="要求知识"><a href="#要求知识" class="headerlink" title="要求知识"></a>要求知识</h1><ol>
<li>汇编语言不要求精通，但一定要熟悉，有基本了解；</li>
<li>C语言要会，写内核要用；</li>
<li>shell必须会敲命令，没得说；</li>
<li>可以先修一些附加技能，比如gdb、Makefile等，也可以先了解相关概念。</li>
</ol>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>在开发之前，我们需要配置开发环境。我使用的是Mac，终端用的是zsh。如果有能力，可以用Linux，因为Linux包含开发过程中大部分的工具。如果是Windows……那就去论坛下载个虚拟机，使用Linux吧。为了不让诸位一上来就被各种安装震慑住，我们开发一点安装一点。首先（假设你有<code>Homebrew</code>，一定要<strong>换源</strong>）：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew install qemu nasm # 怎么样？很简单吧<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>简单认识一下：<code>qemu</code>是个开源的模拟器，<code>nasm</code>是Netwide汇编编译器。</p>
<h1 id="加载启动扇区"><a href="#加载启动扇区" class="headerlink" title="加载启动扇区"></a>加载启动扇区</h1><p>我们的操作系统，从<code>bootsector</code>写起。这个<code>bootsector</code>是个启动扇区。<strong>当这个分区被识别有效后，系统就会启动。</strong>我们的首要目标是创建能被识别的bs。</p>
<p>为了检测磁盘是可启动的，BIOS会检测第511和512字节是否为十六进制AA55。记住0xAA55，这个数字是硬件开发者所设置的。</p>
<p>新建你的项目文件夹，给你自己的系统起个名字，比如我的叫<code>Venus</code>。创建<code>bootsect.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">loop:
    jmp loop ; 开始递归，在这里做无限循环。其实也可以用hlt或者jmp $实现。

times 510 - ($-$$) db 0 ; 在bs前放上510个0
dw 0xAA55 ; 在第511字节处，定义0xAA55，覆盖两个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们编译、模拟两步走：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ nasm -fbin boot_sect.asm -o boot_sect.bin 
$ qemu-system-x86_64 boot_sect.bin # 如果错误，改成qemu boot_sect.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-hlt.png" alt="bs-hlt"></p>
<p><strong>至此，你迈开了第一步！</strong>系统在引导之后，进入了无限循环。</p>
<h1 id="输出至屏幕"><a href="#输出至屏幕" class="headerlink" title="输出至屏幕"></a>输出至屏幕</h1><p>先来了解一下中断：</p>
<blockquote>
<p>在点击鼠标或键盘时（正如我现在在做的事情），计算机会立即给我反馈处理结果，计算机与我们之间是在进行实时交互的。<strong>而实时性的实现便是依赖了中断</strong>，中断是为了顺应人们对实时性交互的需求而产生的技术。中断之所以有用，是因为它会立刻停下当前的程序（软件）去做另外一件事。</p>
</blockquote>
<p>我们希望启动后，让系统在屏幕上输出几个字符：’Venus’。<strong>我们需要用到<code>int 0x10</code>。这个中断用于控制屏幕输出，它好比一个约定俗成的函数，有两个参数，ax寄存器的低位al就是要输出的字符，高位ah就是控制输出模式的指示符。</strong>代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ah, 0x0E ; 指示符为0x0E代表tty模式（你应该知道tty是什么，TeleTYpe）
mov al, &#39;V&#39;  ; 把al赋值&#39;V&#39;
int 0x10     ; 终端输出
mov al, &#39;e&#39;  ; 重复以上流程
int 0x10
mov al, &#39;n&#39;
int 0x10
mov al, &#39;u&#39;
int 0x10
mov al, &#39;s&#39;
int 0x10

jmp $

; BIOS识别的数字
times 510 - ($-$$) db 0
dw 0xAA55 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们编译、模拟两步走：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-print.png" alt="bs-print"></p>
<h1 id="完善打印功能"><a href="#完善打印功能" class="headerlink" title="完善打印功能"></a>完善打印功能</h1><p>为了方便我们今后的调试，我们需要完善打印功能，这样出了什么差错直接print就OK了。我们的打印分为两种：打印字符串和打印地址。</p>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>都知道，C语言中的字符串结构长这样：</p>
<pre class="line-numbers language-none"><code class="language-none">&quot;Venus&quot; -&gt; &#39;V&#39; &#39;e&#39; &#39;n&#39; &#39;u&#39; &#39;s&#39; &#39;0x0&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>都是几个字符再加上一个空字节0x0。如果要打印字符串，而不是单个字符，在汇编里面，可以对应成一个栈来处理。同目录新建一个<code>print.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print:
    pusha ; 将所有东西压入栈

; 记住：一直循环打印栈的字符，直到碰到字符串末0x0
; while (string[i] !&#x3D; 0) &#123; print string[i]; i++ &#125;

start:
    mov al, [bx] ; bx相当于字符串参数，是字符串的首位
    cmp al, 0    ; al和0比较
    je done      ; 如果相等，就到了字符串末尾，跳转到结束done

    mov ah, 0x0E ; 如果不相等，开始打印，先进入tty模式
    int 0x10     ; 直接中断。因为al参数已经有字符了

    add bx, 1    ; 如果你把这个栈+1，相当于地址后移一位，这样再打印就是下一个字符串
    jmp start    ; 递归

done:
    popa         ; 弹出栈  
    ret          ; 返回主程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再空几行，实现一个附加功能——换行：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print_nl:        ; print NewLine
    pusha
    
    mov ah, 0x0E ; tty模式
    mov al, 0x0A ; 把0x0A和0x0D合起来相当于\n
    int 0x10
    mov al, 0x0D ; 把0x0A和0x0D合起来相当于\n
    int 0x10
    
    popa
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="打印地址（4位）"><a href="#打印地址（4位）" class="headerlink" title="打印地址（4位）"></a>打印地址（4位）</h2><p>打印地址也很有用的。但它涉及到一个把指定字符转换为ASCII的问题。因为传入的参数不是带引号的字符串，而是譬如0x1234这样的地址，那到底应该打印什么呢？转换方法如下：</p>
<blockquote>
<h3 id="字符与ASCII对应关系"><a href="#字符与ASCII对应关系" class="headerlink" title="字符与ASCII对应关系"></a>字符与ASCII对应关系</h3><p>数字转换：0<del>9是0x30</del>0x39，所以<strong>把数字加上0x30</strong>即是ASCII；</p>
<p>字母转换：A<del>F（当成1</del>6）是0x41~0x46，所以<strong>把字母加上0x40</strong>。</p>
</blockquote>
<p>代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print_hex:
    pusha
    mov cx, 0 ; cx在循环指令和重复前缀中，作循环次数计数器

; 参数dx：要打印的地址
hex_loop:
    cmp cx, 4 ; cx是不是已经循环了四次？
    je end    ; 如果是，跳转到end结束
    
    ; 如果不是：开始处理

    mov ax, dx     ; 在ax上对字符处理，（dx是我们的地址参数）
    and ax, 0x000F ; 先把这个地址只保留最后一位。比如0x1234就变成0x0004
    add al, 0x30   ; 加上30，这样4就会变成ASCII：34（别忘了这个al是ax的一部分，是一个寄存器——
    cmp al, 0x39   ; 如果发现这个数字&gt;9，不是0～9，那么这个数字就是字母，加上7，就会是A~F中的一个
    jle step2      ; Jump if Lower or Equal：al小于等于0x39跳转至step2
    add al, 7

step2:
    ; 第二步：我们的ASCII字符应该放在哪个地址呢？
    ; 地址BX：基地址+字符串长度（5位，别忘了还有最后的0x0）-字符索引
    mov bx, HEX_OUT + 5 ; 基+长
    sub bx, cx          ; -索引
    mov [bx], al        ; 把al中的字符移到[bx]，中括号表示地址的内容
    ror dx, 4           ; ROll Right：0x1234 -&gt; 0x4123 -&gt; 0x3412 -&gt; 0x2341 -&gt; 0x1234. ror帮我们实现类似遍历字符串的效果。你可以去掉这行指令，看看会发生什么

    add cx, 1           ; 循环计数器+1
    jmp hex_loop        ; 回到循环

end:
    mov bx, HEX_OUT     ; 把HEX_OUT设置到bx里，作为下一个call的参数
    call print          ; 调用写好的print.asm

    popa
    ret

HEX_OUT:
    db &#39;0x0000&#39;, 0 ; 这是我们输出的地址，先定义下来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="尝试使用打印功能"><a href="#尝试使用打印功能" class="headerlink" title="尝试使用打印功能"></a>尝试使用打印功能</h2><p>编写<code>bootsect.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]

mov bx, GREETINGS ; 设置参数
call print        ; 打印
call print_nl     ; 换行

mov dx, 0x4567    ; 设置参数（地址）
call print_hex    ; 打印十六进制


mov bx, SHUTDOWN  ; 同上
call print
call print_nl

jmp $             ; 挂起程序，无限循环（hlt也行）

%include &quot;boot_sect_print.asm&quot;
%include &quot;boot_sect_print_hex.asm&quot;

; 定义两个数据，注意末尾一定要带0字节
GREETINGS:
    db &#39;Welcome to Venus&#39;, 0

SHUTDOWN:
    db &#39;Shutdown&#39;, 0

times 510-($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明两个地方：</p>
<ol>
<li><code>[org 0x7C00]</code>：org是用来设置程序基址的。因为BIOS将bs加载到0x7C00的位置，所以我们设置基址为0x7C00。这行指令的中括号去掉也行。</li>
<li><code>%include</code>：用来引用文件，后面跟上空格和双引号，双引号里写文件名称。值得注意的是，**<code>%include</code>命令相当于把引用的文件直接替换到程序中**，不做任何操作。</li>
</ol>
<p>还是按老办法编译、模拟：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-final.png" alt="bs-final"></p>
<h1 id="读取磁盘"><a href="#读取磁盘" class="headerlink" title="读取磁盘"></a>读取磁盘</h1><p>好了，最枯燥却最有用的功能来了，读取磁盘。我们总不能神经质地把整个系统都放在启动扇区。我们先了解一下磁盘（这个部分必须看）：</p>
<h2 id="磁盘基础"><a href="#磁盘基础" class="headerlink" title="磁盘基础"></a>磁盘基础</h2><h3 id="盘片、片面和磁头"><a href="#盘片、片面和磁头" class="headerlink" title="盘片、片面和磁头"></a>盘片、片面和磁头</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct1.png" alt="dsk-struct1" style="zoom:50%;" />

<p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。</p>
<h3 id="扇区（sector）和磁道（track）"><a href="#扇区（sector）和磁道（track）" class="headerlink" title="扇区（sector）和磁道（track）"></a>扇区（sector）和磁道（track）</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct2.png" alt="dsk-struct2" style="zoom:50%;" />

<p>上图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）。</p>
<h3 id="磁头（head）和柱面（cylinder）"><a href="#磁头（head）和柱面（cylinder）" class="headerlink" title="磁头（head）和柱面（cylinder）"></a>磁头（head）和柱面（cylinder）</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct3.png" alt="dsk-struct3" style="zoom:50%;" />

<p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 </p>
<h2 id="开始读取吧！"><a href="#开始读取吧！" class="headerlink" title="开始读取吧！"></a>开始读取吧！</h2><p>我就直接放代码了，没什么技术含量，只不过有一些关键的寄存器数值与中断号码需要明白：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 参数：
;   - dh：扇区个数
;   - dl：磁盘
; 读取的数据存入es:bx

disk_load:
    pusha              ; 压入栈
                       ; 将dx也压入栈
    push dx            ; dx一会会被读取磁盘的操作覆盖，所以先压入栈保存

    mov ah, 0x02       ; BIOS 读取扇区的功能编号
    mov al, dh         ; AL - 扇区读取个数，也就是我们的dh
    mov cl, 0x02       ; CL - 从哪里开始读取，因为第一个扇区是启动扇区，所以这里是0x02
    mov ch, 0x00       ; CH - 柱面编号(0x0-0x3FF)
    mov dh, 0x00       ; DH - 磁头编号(0x0-0xF)

    int 0x13           ; 读取磁盘的中断标号
    jc disk_error      ; Jump if Carry：如果CF被设置，就是出现了错误，跳转
    
    ; 如果没有错误
    pop dx             ; dx我们用完了，弹出栈
    cmp al, dh         ; 此时bios会把al设置为扇区个数，对比一下
    jne sectors_error  ; 如果两者不一样，读取扇区出现了错误，跳转
    popa               ; 如果一样，停止程序
    ret

; 剩下的是错误处理部分，大家都明白
disk_error:
    mov bx, DISK_ERROR
    call print
    call print_nl
    mov dh, ah
    call print_hex
    jmp disk_loop

sectors_error:
    mov bx, SECTORS_ERROR
    call print

disk_loop:
    jmp $

DISK_ERROR: db &quot;Disk read error&quot;, 0
SECTORS_ERROR: db &quot;Incorrect number of sectors read&quot;, 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们将启动扇区代码<code>bootsect.asm</code>做出如下更改：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]
mov bp, 0x8000 ; 把栈顶设成0x8000，这样不与BIOS相干
mov sp, bp     ; 同上
mov bx, 0x9000 ; es:bx &#x3D;&#x3D; 0x0000:0x9000 &#x3D;&#x3D; 0x09000

; 现在我们要设置disk_load参数
mov dh, 2 ; 读取两个扇区
; 此处不用设置dl，BIOS已经帮我们设置过了
call disk_load ; 调用

mov dx, [0x9000] ; 获取第一扇区
call print_hex
call print_nl

mov dx, [0x9000 + 512] ; 获取第二扇区（注意偏移地址，跟下面数据对应）
call print_hex

jmp $

%include &quot;print.asm&quot;
%include &quot;print_hex.asm&quot;
%include &quot;disk.asm&quot;

times 510 - ($-$$) db 0
dw 0xAA55

; 上面是bs（第一个扇区）
times 256 dw 0x1234 ; 第2
times 256 dw 0x5678 ; 第3
; 上面的第二第三也不一定，因为有的磁盘一个扇区512，现在有的4096
; …………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-final.png" alt="dsk-final"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>别着急，这只是第一天呢，离加载内核还远着呢。我给大家指指路，我们已经可以读取磁盘，接下来我们需要：</p>
<ol>
<li>加载启动扇区</li>
<li>读取磁盘，加载内核</li>
<li>从命令行转成GUI图形界面</li>
<li>设置GDT（代码最简单，但是最困难的部分，也消耗了我的大部分研究时间）</li>
<li>切换到32bit保护模式</li>
<li>执行内核：kernel_main</li>
<li>正式切换到C语言！</li>
</ol>
<p>剩下的几个步骤我会划分成几天的内容，发布文章讲解。</p>
<p>其实我写着写着突然想到这不就跟革命斗争一样吗，在执行内核前是多么煎熬，执行内核切换C语言后跟解放了一样。</p>
<p>一点点来吧。</p>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>《你没听错：动手开发GUI简单操作系统》系列</tag>
      </tags>
  </entry>
  <entry>
    <title>再战CleanMyMac X最新版完美暴破</title>
    <url>/posts/a5950fc/</url>
    <content><![CDATA[<blockquote>
<p><strong>因为<code>CleanMyMac X</code>的破解屡次被代理商投诉，并且有被黑心网站挖掘文章的可能，故不能发布成品。文章这么长，其实是就是几个<code>frida-trace</code>和<code>Hopper</code>，更多的是分析，再说论坛上的同志都不是白给的，肯定搞得定。</strong></p>
</blockquote>
<p>自从写了<a href="https://tlhorse.github.io/posts/16190/">《一次意外的 CleanMyMac X 破解》</a>后，在手的CleanMyMac X 4.5.3就一直没更新换代。笔者撰写此文，CleanMyMac X 已经发展到4.7.4了，于是便想着重新破解一遍。如果还未读过上篇文章的，建议读一遍。</p>
<h1 id="Hopper分析"><a href="#Hopper分析" class="headerlink" title="Hopper分析"></a>Hopper分析</h1><p>按照上一篇文章的思路，我们先找<code> -[CMActivationManager isAppActivated]</code>这个函数。竟然还在：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/cmmnew-search-sym.png" alt="cmmnew-search-sym"></p>
<p>但是，为了避免像我破解4.6.7时频繁输密码的问题，安装<code>frida</code>，我们使用<code>frida-trace</code>进行调试修改：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">frida-trace -m &quot;-[* isAppActivated]&quot; &quot;CleanMyMac X&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令我需要解释一下。<code>-m</code>是trace（跟踪）<code>OBJC_METHOD</code>的参数，后面第一个字符串参数是一个搜索关键词，其中*是通配符，不论是哪个class的<code>isAppActivated</code>都会被我们监视到。后面的<code>&quot;CleanMyMac X&quot;</code>是进程名称。</p>
<p>但是可惜的是在激活命令之前，我们需要把CMM打开，这样<code>frida</code>才能attach到进程。也就是说，CMM和命令几乎要同时打开。我在调试的过程中一直是把app和回车同时按下去，很麻烦，知道写文章才发觉自己好可爱，为什么不用下面的命令呢：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">open &#x2F;Applications&#x2F;CleanMyMac\ X.app &amp;&amp; frida-trace -m &quot;-[* isAppActivated]&quot; &quot;CleanMyMac X&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后我们会看到下面的输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Instrumenting...                                                        
-[CMActivationManager isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMActivationManager&#x2F;isAppActivated.js&quot;
-[CMSubscriptionStatusManager isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMSubscriptionStatusManager&#x2F;isAppActivated.js&quot;
-[CMSubscriptionRequestSchedule isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMSubscriptionRequestSchedule&#x2F;isAppActivated.js&quot;
Started tracing 3 functions. Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到有三个函数被调用，也就是说这是三个函数都得被hook，终于不用像以前傻呵呵只改一个函数了。</p>
<h1 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h1><p>为了省时间，在这里就不用Hopper了。我们在<code>frida</code>生成的<code>__handlers__</code>文件夹（位于当前目录，也就是在trace之前要<code>cd</code>到一个准备好的目录）中，分别将三个函数的<code>onLeave</code>改成1：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">onLeave</span><span class="token punctuation">(</span><span class="token parameter">log<span class="token punctuation">,</span> retval<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  retval<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后再运行<code>frida-trace</code>，打开软件，提示信息消失。正当欣喜若狂开始清理垃圾时，突然停止清理，提示我买会员。噩耗传来：<strong>这是伪破解。不过别泄气啊。</strong></p>
<p>仔细观察软件会发现，有的地方是未注册的UI，有的地方是已注册的UI，也就是暴破函数没找全。我们查看一下<code>-[CMActivationManager isAppActivated]</code>伪代码，发现，里面的<code>sub_100334850</code>在做着不为人知的事情：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;* @class CMActivationManager *&#x2F;
-(char)isAppActivated &#123;
    rax &#x3D; sub_100334850(0x0);
    return rax;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sub_100334850</code>：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">int sub_100334850(int arg0) &#123;
    var_2E8 &#x3D; arg0;
    rax &#x3D; objc_autoreleasePoolPush();
    var_300 &#x3D; 0x0;
    var_2A0 &#x3D; &amp;var_300;
    var_318 &#x3D; rax;
    if (**_NSApp !&#x3D; 0x0) &#123;
            var_320 &#x3D; qword_1007a3b28(**_NSApp, 0x1007a3b70);
            var_328 &#x3D; var_320;
    &#125;
    else &#123;
            var_328 &#x3D; 0x0;
    &#125;
    var_2A8 &#x3D; var_328;
    sub_100392510(&quot;DM_ENABLE_DEBUG_LOGGING_ACTIVATION&quot;, @&quot;_get_: %p&quot;, var_2A8, 0x0, r8, r9, stack[-1704]);
    if ((var_2A8 &#x3D;&#x3D; 0x0) || (var_2A0 &#x3D;&#x3D; 0x0)) goto loc_1003349b4;
  &#x2F;&#x2F; ......
  &#x2F;&#x2F; Plethora ommitted...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码很长，就不全部展示了。<kbd>Shift</kbd><kbd>X</kbd>查看交叉引用，让我们“顺瓜摸藤”，结果让我眼前大吃一惊，好多啊……</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-subx.png" alt="搜索交叉引用"></p>
<p>原来，这个sub是个判断激活的进程<strong>，不止<code>isAppActivated</code>调用了它，还有许许多多的类和方法，包括<code>EntryPoint</code>。</strong></p>
<p>想要hook这个sub，还需获取在内存中的地址，着实麻烦，就不写<code>frida</code>了。<strong>Hopper直接改返回值。</strong>双击空格，切到ASM模式，让我们：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><kbd>Cmd</kbd><kbd>Shift</kbd><kbd>E</kbd>，生成可执行文件，给源文件改名，替换——三步走，之后打开<code>CleanMyMac X</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-ked-1.png" alt="1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-ked-2.png" alt="2"></p>
<p>祝大家新年快乐，牛年大吉，破解技术共获提升，软件使用快乐！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>你没看错：动手开发GUI简单操作系统（二）</title>
    <url>/posts/b833a77e/</url>
    <content><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ol>
<li>编写GDT</li>
<li>切换到32位保护模式（32-bit protected mode，又叫PM）</li>
</ol>
<blockquote>
<p>我突然发现写到第二篇文章就难以启齿了，因为切PM、加载内核这些东西几乎是环环相扣的，有一点差错都不行。</p>
<p>另外劝大家一定要学好英文，怎么着也得七八千词汇量吧。</p>
</blockquote>
<h1 id="编写GDT"><a href="#编写GDT" class="headerlink" title="编写GDT"></a>编写GDT</h1><p>GDT是最难理解的部分，却不可避免，不好意思，我这次又整了一大段理论写在这里。我觉得下面说的还算比较全吧，如果我一下引入那么多名词，我都难以下笔。但是，必须看，如果实在读不进去，看<strong>加粗字体</strong>：</p>
<h2 id="认识全局描述符表"><a href="#认识全局描述符表" class="headerlink" title="认识全局描述符表"></a>认识全局描述符表</h2><blockquote>
<p>为了行文方便，下文使用缩写。</p>
<table>
<thead>
<tr>
<th align="center">中文名称</th>
<th>英文名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局描述符表</td>
<td>Global Descriptor Table</td>
<td>GDT</td>
</tr>
<tr>
<td align="center">保护模式</td>
<td>Protected Mode</td>
<td>PM</td>
</tr>
<tr>
<td align="center">真实模式</td>
<td>Real Mode</td>
<td>RM</td>
</tr>
</tbody></table>
</blockquote>
<p>GDT在PM下，是一个重要的必不可少的数据结构。</p>
<p>为什么要有GDT？我们首先考虑一下在RM（就是切PM之前）下的编程模型：在RM下，我们对一个内存地址的访问是通过<code>Segment:Offset</code>的方式来进行的，其中Segment是一个段的基地址，一个Segment的最大长度是64KB，这是16位系统所能表示的最大长度。而Offset则是相对于此段基地址的偏移量。<strong>基地址+偏移就是一个内存绝对地址。</strong></p>
<p>由此，我们可以看出，一个段具备两个因素：基地址和段的最大长度。而对一个内存地址的访问，则是需要指出两点：</p>
<ol>
<li>使用的是哪个段；</li>
<li>相对于这个段基地址的偏移：这个偏移应该小于此段的最大长度。</li>
</ol>
<p>当然对于16位系统，最大长度不用指定，默认为最大长度64KB，16位的便宜也永远不可能大于最大长度。而我们在实际编程的时候，使用16位段寄存器CS，DS，SS来指定段，CPU将段寄存器中的数值向左偏移4位，放到20位的地址线上就成为20位的基地址。</p>
<p>到了PM，内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的。也就是说，PM的内存管理模式事实上是：纯段模式和段页式。进一步说，段模式是必不可少的，而页模式则是可选的——如果使用页模式，则是段页式；否则这是纯段模式。</p>
<p>既然是这样，我们就先不去考虑页模式。对于段模式来讲，访问一个内存地址仍然使用Segment:Offset的方式，这是很自然的。由于PM运行在32位系统上，那么Segment的两个因素：基地址和最大长度也都是32位的。IA-32允许将一个段的基地址设为32位所能表示的任何值（最大长度则可以被设为32位所能表示的2<sup>12</sup>的整数倍的任何值），而不像RM下，一个段的基地址只能是16的倍数（因为其低4位是通过左移运算得来的，只能为0，从而达到使用16位段寄存器表示20位基地址的目的），而一个段的最大长度只能为固定值64KB。</p>
<p><strong>另外PM顾名思义，就是为段访问提供了保护机制</strong>，也就说一个段的描述符需要规定对自身的访问权限（Access）。所以在PM下，对一个段的描述则包括3方面因素：Base Address（基地址）、Limit（最大长度）、Access（访问权限），它们加在一起被放在一个64位长的数据结构中，被称为段描述符。这种情况下，如果我们直接通过一个64位段描述符来引用一个段的时候，就必须使用一个64位长的段寄存器装入这个段描述符。Intel为了保持向后兼容，但将段寄存器仍然规定为16位（尽管每个段寄存器事实上有一个64位长的不可见部分，但对于编程人员来说段寄存器就是16位的），那么很明显，我们无法通过16位长度的段寄存器来直接引用64位的段描述符。怎么办？<strong>解决的方法就是把这些长度为64位的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用（事实上，是将段寄存器中的高13位的内容作为索引）。</strong></p>
<p><strong>——这个全局的数组就是GDT。</strong>事实上，在GDT中存放的不仅仅是段描述符，还有其它描述符，它们都是64-bit长，我们随后再讨论。GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，C<strong>PU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器<code>gdtr</code>用来存放GDT的入口地址</strong>。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDT是PM所必须的数据结构，也是唯一的——不应该，也不可能有多个GDT。</p>
<p>另外，正像它的名字Global Descriptor Table所揭示的，它是全局可见的，对任何一个任务而言都是这样。除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT，但与GDT不同的是，<strong>LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。</strong></p>
<p><strong>另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。</strong>IA-32为LDT的入口地址也提供了一个寄存器LDTR，因为在任何时刻只能有一个任务在运行，所以<strong>LDT寄存器全局也只需要有一个</strong>。如果一个任务拥有自身的LDT，那么当它需要引用自身的LDT时，它需要通过LLDT将其LDT的段描述符装入此寄存器。</p>
<p>LLDT指令与LGDT指令不同的是，LGDT指令的操作数是一个32位的内存地址，这个内存地址处存放的是一个32位GDT的入口地址，以及16位的GDT最大长度。而LLDT指令的操作数是一个16位的选择子，这个选择子主要内容是：<strong>被装入的LDT的段描述符在GDT中的索引值</strong>——这一点和刚才所讨论的通过段寄存器访问段的情况是一样的。</p>
<p>现在你知道为什么要有GDT了吧……</p>
<h2 id="GDT结构"><a href="#GDT结构" class="headerlink" title="GDT结构"></a>GDT结构</h2><p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-table.png" alt="gdt结构"></p>
<p>这是GDT的结构。其中Flags和Access Byte部分又分为如下表格：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-detail.png" alt="gdt详细"></p>
<h2 id="编写GDT-1"><a href="#编写GDT-1" class="headerlink" title="编写GDT"></a>编写GDT</h2><p>我们先讲讲上面两个图每一项都代表什么，并且应该设置什么值。</p>
<table>
<thead>
<tr>
<th align="left">图中标签</th>
<th>中文</th>
<th>英文</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Pr</td>
<td>展示</td>
<td>present</td>
<td>1</td>
<td>段在内存中被展示</td>
</tr>
<tr>
<td align="left">Privl</td>
<td>访问权限</td>
<td>privilege</td>
<td>0</td>
<td>俗话说的ring级别。ring0 = 最高权限（内核）；ring3 = 最低权限（用户App）</td>
</tr>
<tr>
<td align="left">S</td>
<td>描述符类型</td>
<td>descriptor type</td>
<td>1</td>
<td>设为1，表示是CS/DS</td>
</tr>
<tr>
<td align="left">Ex</td>
<td>是否为可执行</td>
<td>Executable</td>
<td>1</td>
<td>1表示可执行，说明是代码；0表示不可执行，说明是数据</td>
</tr>
<tr>
<td align="left">DC</td>
<td>指示/遵循</td>
<td>Direction/Conforming</td>
<td>0</td>
<td>代码段中，0：代码只能被Privl权限执行，1：代码可以被≤Privil权限执行。数据段中，0：段从下到上，1：段从上到下。</td>
</tr>
<tr>
<td align="left">RW</td>
<td>读写性</td>
<td>Readable/Writable</td>
<td>1</td>
<td>对于代码段：1是可读（可以获取常量），0是可执行，不可写；对于数据段：1是可写，2是可读，不可执行</td>
</tr>
<tr>
<td align="left">Ac</td>
<td>已访问段</td>
<td>Accessed</td>
<td>0</td>
<td>设为0。当CPU访问段，access会设成1，由CPU控制</td>
</tr>
<tr>
<td align="left">Gr</td>
<td>粒度</td>
<td>Granularity</td>
<td>1</td>
<td>如果是1，我们的limit会扩大四倍</td>
</tr>
<tr>
<td align="left">Sz</td>
<td>大小</td>
<td>Size</td>
<td>1</td>
<td>1代表使用32位PM，0是使用16位PM</td>
</tr>
<tr>
<td align="left">0（第一个）</td>
<td>64位代码段</td>
<td>64-bit CS</td>
<td>0</td>
<td>32位处理器我们不用，0</td>
</tr>
<tr>
<td align="left">0（第二个）</td>
<td>系统可使用</td>
<td>AVailabLe for use by system software （AVL）</td>
<td>0</td>
<td>调试用，0</td>
</tr>
</tbody></table>
<p>我们根据需要的值写一个GDT。GDT有不止一种写法（也有许多比这高级的），我这种写法是定义了一个数据体，简单明了，但是可能不易于后期维护，项目里新建<code>gdt.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">gdt_start: ; 在这里写一个标签，待会用来计算大小

gdt_null:  ; 这个叫做空段，是Intel预留的
    dd 0   ; DD &#x3D; double word  （此处也可以把两个dd合并为一个dq）
    dd 0   ;    &#x3D; 4 byte

gdt_code: 
    dw 0xFFFF    ; Limit            0-15 bits
    dw 0         ; Base address     0-15
    db 0         ; 同上              16-23
    db 10011010B ; 按照图二Access Byte从右至左（0-7）的顺序填写。注意Privl因为值可以是0-3，所以说占两字节，填两个0
    db 11001111B ; 按图二flags从右至左填写。我们再看图一，flags右边还有limits最后4位，不满8位编译不通过，所以把limits合并在flags右面，0xF&#x3D;0b1111
    db 0         ; Base             24-31

gdt_data:        ; 同上
    dw 0xFFFF
    dw 0
    db 0  
    db 10010010B ; 不同的是这里把Ex改成0，因为这里是数据段
    db 11001111B
    db 0

gdt_end:         ; gdt结束标签，

; GDT
gdt_descriptor:
    dw gdt_end - gdt_start - 1 ; 大小&#x3D;结束-开始-1（真实大小永远-1）
    dd gdt_start               ; 开始地址

; 常量
CODE_SEG equ gdt_code - gdt_start ; CS
DATA_SEG equ gdt_data - gdt_start ; DS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>GDT大功告成！<strong>如果你没有编译成功，出了问题，请留言跟帖或者私信，我一定会回复！</strong></p>
<h1 id="在32位保护模式下打印"><a href="#在32位保护模式下打印" class="headerlink" title="在32位保护模式下打印"></a>在32位保护模式下打印</h1><p>我们现在写一个文件<code>32bit-print</code>，用来在32位保护模式下打印，不过只用来测试，到时候加载了内核切了GUI就可以删了。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]

VIDEO_MEMORY equ 0xB8000 ; 这是VGA开始的地方
WHITE_ON_BLACK equ 0x0F  ; 是一个颜色代码，黑背景，白色字符

print_string_pm:
    pusha
    mov edx, VIDEO_MEMORY

print_string_pm_loop:
    mov al, [ebx]          ; [ebx]是字符串参数
    mov ah, WHITE_ON_BLACK ; ah颜色参数

    cmp al, 0 ; 是不是已经到末尾？
    je print_string_pm_done ; 结束

    ; 如果不是
    mov [edx], ax ; 在Vram中保存字符
    add ebx, 1 ; 下一个字符
    add edx, 2 ; 下一个Vram字符位置，+2

    jmp print_string_pm_loop ; 递归

print_string_pm_done:
    popa
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="切换到32位保护模式"><a href="#切换到32位保护模式" class="headerlink" title="切换到32位保护模式"></a>切换到32位保护模式</h1><p>简单说一下为什么会有所谓保护模式：仔细想一想就能知道，如果这个OS给用户用就是开玩笑，就好像用户和操作系统一块在计算机里玩，而不是用户在操作系统里玩，它没有安全性可言，可以随便访问内存，更别提什么ring0、ring3的了，所以说切PM是为了让OS得到保护。</p>
<p>新建代码<code>switch_pm.asm</code>，很简单。主要目标是认识并使用这个控制寄存器cr0：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 16] ; 代表在16位模式下。中括号可以去掉
switch_to_pm:
    cli                   ; 1. 一定要关掉CPU中断！让CPU专心干一件事
    lgdt [gdt_descriptor] ; 2. 还记得lgdt命令吗？加载我们的gdt_descriptor标签
    mov eax, cr0          ; 把cr0暂存到eax
    or eax, 0x1           ; 3. cr0设置为1，切到32位PM
    mov cr0, eax
    jmp CODE_SEG:init_pm  ; 4. 远跳转，跳到代码段（下面）

[bits 32] ; 32位！
init_pm:
    mov ax, DATA_SEG ; 5. 更新段寄存器
    mov ds, ax
    mov ss, ax
    mov es, ax  ; 把每个都刷一遍
    mov fs, ax
    mov gs, ax

    mov ebp, 0x90000 ; 6. 基址指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部，把它放到0x90000，待会加载内核
    mov esp, ebp

    call BEGIN_PM ; 跳到bootsect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cr0</code>全称叫做Control Register 0，这个控制寄存器专门用来在RM和PM之间切换。</p>
<p>我们编辑一下<code>bootsect.asm</code>，使用上面的“函数”：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]
    mov bp, 0x9000
    mov sp, bp

    mov bx, MSG_REAL_MODE
    call print ; 在实模式下打印

    call switch_to_pm ; 切PM
    ; 这里不管加什么代码都不会被执行

%include &quot;print.asm&quot;
%include &quot;gdt.asm&quot;
%include &quot;32bit-print.asm&quot;
%include &quot;switch_pm.asm&quot;

[bits 32] ; 32位
BEGIN_PM: ; 切换后跳转到这里
    mov ebx, MSG_PROT_MODE ; 打印
    call print_string_pm ; 注意！！！这个信息会被打印到整个屏幕的最左上角，覆盖BIOS的打印
    jmp $ ; 挂起

MSG_REAL_MODE db &quot;Started in 16-bit real mode&quot;, 0
MSG_PROT_MODE db &quot;Loaded 32-bit protected mode&quot;, 0

times 510-($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行两步走：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/32pm-load-success.png" alt="32pm-load-success"></p>
<h1 id="加载并执行空内核"><a href="#加载并执行空内核" class="headerlink" title="加载并执行空内核"></a>加载并执行空内核</h1><p>切32位PM是为加载内核准备的，我就一块整了吧，不然切PM毫无用处。</p>
<p>首先我们得认识到，汇编作为底层语言的代价是功能太少，不方便我们编程。内核编程需要用到C。但是一个操作系统项目里，怎么能容得下两种语言编译呢？你别着急，我们的做法是将启动扇区和内核部分分开，启动扇区编译成一个bin，内核编译成一个bin，编译的过程中我们把ld命令做一些调整，使数据便宜到0x1000，之后把两个bin用cat合并。</p>
<h2 id="内核编写"><a href="#内核编写" class="headerlink" title="内核编写"></a>内核编写</h2><p>所以说咱们先开始写内核吧，新建<code>kernel.c</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void main() &#123;
    char *video_memory &#x3D; (char*) 0xb8000;
    *video_memory &#x3D; &#39;V&#39;;
    char *video_memory1 &#x3D; (char*) 0xb8002;
    *video_memory1 &#x3D; &#39;e&#39;;
    char *video_memory2 &#x3D; (char*) 0xb8004;
    *video_memory2 &#x3D; &#39;n&#39;;
    char *video_memory3 &#x3D; (char*) 0xb8006;
    *video_memory3 &#x3D; &#39;u&#39;;
    char *video_memory4 &#x3D; (char*) 0xb8008;
    *video_memory4 &#x3D; &#39;s&#39;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的作用就是到VGA的地址打印<code>Venus</code>。</p>
<h2 id="汇编编写"><a href="#汇编编写" class="headerlink" title="汇编编写"></a>汇编编写</h2><p>同级新建<code>kernel_entry.asm</code>，仅有四行代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]
[extern main] ; 像C一样，对外部函数得先声明。这个main就是kernel.c里面那个
call main     ; 执行
jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>是时候到<code>bootsect.asm</code>加载了：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7c00]
KERNEL_OFFSET equ 0x1000 ; 定义常量，这个常量是内核的位置

    mov [BOOT_DRIVE], dl ; BIOS会自动把磁盘编号设置到dl。我们在下面间一个常量，先存起来，因为dl可能会被覆盖
    mov bp, 0x9000
    mov sp, bp

    mov bx, MSG_REAL_MODE ; 实模式打印
    call print
    call print_nl

    call load_kernel  ; 加载内核
    call switch_to_pm ; 切PM

%include &quot;print.asm&quot;
%include &quot;print_hex.asm&quot;
%include &quot;disk.asm&quot;
%include &quot;gdt.asm&quot;
%include &quot;print.asm&quot;
%include &quot;switch_pm.asm&quot;

[bits 16]
load_kernel:
    mov bx, MSG_LOAD_KERNEL
    call print
    call print_nl

    mov bx, KERNEL_OFFSET ; 读取到内核偏移地址
    mov dh, 2
    mov dl, [BOOT_DRIVE]
    call disk_load
    ret

[bits 32]
BEGIN_PM:
    mov ebx, MSG_PROT_MODE
    call print_string_pm
    call KERNEL_OFFSET ; 执行内核代码
    jmp $


BOOT_DRIVE db 0
MSG_REAL_MODE db &quot;Started in 16-bit Real Mode&quot;, 0
MSG_PROT_MODE db &quot;Landed in 32-bit Protected Mode&quot;, 0
MSG_LOAD_KERNEL db &quot;Loading kernel into memory&quot;, 0

times 510 - ($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/kern-exec.png" alt="kern-exec"></p>
<p>今天就到这里，<strong>以后更新可能会慢点</strong>，太累了，我还要干别的呢。我发现不少坛友貌似有点功利性质，说什么期待后续如果可以再下手，哈哈，我理解你们，毕竟项目要么就不做，要么就做成。我的个人理念是不做就不做，做就做大。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>《你没听错：动手开发GUI简单操作系统》系列</tag>
      </tags>
  </entry>
</search>
