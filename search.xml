<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CleanMyMac X破解初尝试</title>
    <url>/posts/16190/</url>
    <content><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p><code>CleanMyMac X</code>应该是每个Mac用户耳熟能详的电脑清洁软件，以下简称<code>CMM</code>。我几天前用的是<code>CMM 4.5.3</code>版本，是在xx破解网站上搜索的TNT版本，结果今天一打开CMM发现，已经有了4.6.0版本的更新。与其到xx破解网站上搜破解版，不如自己再动手破解一遍，于是就有了这篇文章。我真的……一开始我也没想到这次破解会这么顺……</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><code>CMM 4.6.0</code>一枚；</li>
<li><code>Hopper Disassembler v4</code>一枚。</li>
</ul>
<h1 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h1><h2 id="查找线索"><a href="#查找线索" class="headerlink" title="查找线索"></a>查找线索</h2><p>首先将CMM拖进Hopper。我先搜索了一波UI中的Strings。搜索无果后，尝试搜索<code>vip</code> <code>register</code> <code>activate</code>关键词，发现<code>activate</code>关键词有很多激活相关项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/15/hop-cmm-search-str.jpg" alt="搜索字符串"></p>
<p>我找到了四个方法，名为<code>isAppActivated</code>。我想，相比其他复杂的函数与方法，那是不是把这四个方法patch了，整个CMM就能用了呢？</p>
<p>然而我又发现了第一个方法<code> -[CMActivationManager isAppActivated]</code>的伪代码调用了一个函数<code>_mLyGsJNgru0iJKGfhK</code>，并将这个函数的返回值（是<code>int</code>类型）赋予给了<code>rax</code>，而这个函数的内部逻辑很复杂，很可能就是验证激活的过程。</p>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><p>接着上一个步骤，双击进入<code>_mLyGsJNgru0iJKGfhK</code>，打开伪代码模式，看着一长串的代码别着急，从程序入口开始，按照程序的<code>goto</code>走，顺藤摸瓜，最后<code>return</code>了一个<code>rax</code>——那简单，跳到汇编模式，直接：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再打开伪代码，你会发现这个方法的伪代码已经变成：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">int _mLyGsJNgru0iJKGfhK(int arg0) &#123;
    return 0x1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这就对了！</p>
<h1 id="留下足迹"><a href="#留下足迹" class="headerlink" title="留下足迹"></a>留下足迹</h1><p>为什么要有这一步，在我的<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >CrossOver 19<i class="fas fa-external-link-alt"></i></a>破解文章里已经说明了。在CMM中，我们要达到这样的效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/15/hop-cmm-mod-credits.png" alt="留下足迹"></p>
<blockquote>
<p>注：这个窗口可以在程序顶栏 CleanMyMac X &gt; 关于CleanMyMac里找到。</p>
</blockquote>
<p>这段文字是一个<code>.rtf</code>，在<code>/Applications/CleanMyMac X.app/Contents/Resources/zh-Hans.lproj/Credits.rtf</code>。打开这个文件，在开头按格式添加上你的Credit，注意一点，这个文件开头的几个空行要保留，否则达不到CMM的滚动效果。</p>
<p>之后，就大功告成了！</p>
<h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><ol>
<li>使用时，应用缺少权限，即使已经在设置里设置了磁盘完全访问。</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Hopper 之 CrossOver 19 破解</title>
    <url>/posts/16189/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章不仅放在了我的博客上，还是本人在<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >吾爱破解<i class="fas fa-external-link-alt"></i></a>上的第一个帖子。我在吾爱破解论坛上发布帖子后，又将语言表达顺了一遍，放在了我的博客上，文中的图片链接全部引用自吾爱破解，可以看到吾爱破解的水印。<strong>此篇文章未经允许，谢绝转载，并仅供学习研究。</strong></p>
<p>最近一直在鼓捣各种软件的逆向与反编译，又准备要在Mac上运行Windows程序，于是准备上手<code>CrossOver</code>。但是感觉在五花八门的破解网站上下载的东西不安全，求人不如求己，所以我就当练练手，自己破解试试看，而后就有了这篇文章。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>从<a class="link"   href="https://www.crossoverchina.com/" >CrossOver 官网<i class="fas fa-external-link-alt"></i></a>上下载最新版的 CrossOver 19 。</li>
<li><a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler v4<i class="fas fa-external-link-alt"></i></a> 一枚。</li>
</ul>
<h1 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h1><h2 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h2><p>首先打开<code>CrossOver</code>，简单的看了一下，分析出几个信息：</p>
<ul>
<li><p>打开软件后弹出了一个要钱弹窗，弹窗里提示了试用剩余天数，并提示你购买软件或者进行使用；</p>
</li>
<li><p>要钱弹窗中有两个需要关注的按钮，一个是 <code>现在试用</code>，另一个是 <code>使用购买信息解锁</code> ;</p>
</li>
<li><p>按下 <code>现在试用</code> 按钮，可以直接跳转到App里，开始14天试用；</p>
</li>
<li><p>按下 <code>使用购买信息解锁</code> 按钮，可以进行邮箱/密码激活，或者使用邮箱+密码+验证码激活；</p>
</li>
<li><p>开始试用App后，在<code>CrossOver</code>里仍然可以进行App激活操作。</p>
</li>
<li><p>嘿嘿，CrossOver竟然没有反调试。</p>
<p>于是，我们就有如下的破解思路：</p>
</li>
<li><p>Patch剩余天数；</p>
</li>
<li><p>Patch使用购买信息解锁的验证流程。</p>
</li>
</ul>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><h3 id="Patch剩余天数"><a href="#Patch剩余天数" class="headerlink" title="Patch剩余天数"></a>Patch剩余天数</h3><p>本篇文章选用第一种思路“Patch剩余天数”，因为第一种思路相对简单直接。我试过第二种思路，对新手来说相对复杂，我就不再阐述了。</p>
<p>打开 <code>Hopper</code>，将<code>CrossOver</code>拖入分析。本来想搜索UI中的字符串，字符串搜索无果后，根据“剩余天数”的英文“left”，搜索关键词：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-serach-left.png" alt="搜索left"></p>
<p>我们发现，第一个函数<code>-[CXApplication daysLeft]</code>，于是打开伪代码发现，这个函数返回的是一个<code>int</code>，极有可能是剩余的天数。我们可以尝试Patch这里，使得该函数永远返回十六进制<code>0x8ef8</code>。将汇编代码改为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x8ef8
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里我们要注意一点：十六进制<code>0x8ef8</code>对应的是十进制的<code>36600</code>（天）。我设置成36600，只是为了好看——36600天就是100多年。事实上，这个数值可以设置为任意大于0的整数，别忘了这个数值已经被我们 patch 了，是不会变动的。接着，我们动态调试运行一下，成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-36600.png" alt="剩余天数破解成功"></p>
<h3 id="Patch-激活窗口"><a href="#Patch-激活窗口" class="headerlink" title="Patch 激活窗口"></a>Patch 激活窗口</h3><p>你肯定觉得这篇文章不可能这么快结束。接下来，我要让你认识到一点：在App里面，仍然有某些按钮可以进行激活操作。比如程序顶栏上的<code>CrossOver</code> &gt; <code>解锁 CrossOver</code>按键，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-regwin.png" alt="某些解锁按钮仍然存在"></p>
<p>而这些按键恰恰是我们不需要的。为了App的简洁，我们现在要把App里所有激活相关的按键禁用。与其禁用所有按钮，不如把这些按钮弹出来的<strong>同一个</strong>激活窗口禁用掉。这怎么做到呢？其实非常简单。这里有个小技巧，在<code>macOS</code>里，弹出窗口必须通过<code>windowDidLoad:</code>函数，因此我们可以将<code>windowdidload</code>作为关键词搜索：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-search-windowdl.png" alt="windowdidload搜索"></p>
<p>这时我看中了<code>DemoRegisterController</code>，它应该是一个注册管理类，所以他的<code>windowDidLoad:</code>方法弹出来的窗口很有可能是那个激活窗口。我们再把<code>DemoRegisterController</code>作为关键词搜索，把这个类的相关函数（图中红框内的方法）都<code>ret</code>掉即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-drcret.png" alt="DemoRegisterController搜索"></p>
<p>指令为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>修改后，以调试的方式运行<code>CrossOver</code>，发现注册相关的按钮已经按不动了。成功！</p>
<h1 id="留下足迹"><a href="#留下足迹" class="headerlink" title="留下足迹"></a>留下足迹</h1><p>我之所以把这个步骤设置成一级内容，是因为它实际跟破解没有关系。通过这一步，我要告诉你，任何一位craker为了保证自己的破解作品不被盗用或广泛传播（真正的craker破解出来的东西不会随便发给别人），都会注明程序是自己破解的。就像这样：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-credits.png" alt="留下足迹" style="zoom:50%;" />

<blockquote>
<p>注：此窗口可以在程序顶栏<code>CrossOver</code>&gt;<code>关于</code>中调出。</p>
</blockquote>
<p>这个怎么办到呢？其实，如果你的App有着跟上图类似的界面，那么这个界面中间的电子权利信息（也就是文字部分）通常会被储存为一个<code>.html</code>、<code>.txt</code>或<code>.rtf</code>文件。你可以根据一下规则尝试找到它：</p>
<ol>
<li><p>如果程序支持<strong>多语言</strong>，那么它<strong>有可能</strong>在程序资源的多语言文件夹里，也就是：xxx.app/Contents/Resources/xxx.lproj/xxx.xxx。</p>
</li>
<li><p>如果程序只支持<strong>单语言</strong>，那么它<strong>可能</strong>在：xxx.app/Contents/Resources/xxx.xxx。</p>
</li>
</ol>
<p>在这个App里，我们可以根据第一个规则（此App是多语言的），通过下图找到电子权利信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-creditspath.png" alt="电子权利信息路径"></p>
<p>找到后，用文本编辑打开，在文件开头加上一句类似下面的话：</p>
<blockquote>
<p>这个版本的 CrossOver 已经由xxx破解。你可以放心使用。注意，请勿广泛传播……</p>
</blockquote>
<p>保存文件，再打开<code>CrossOver</code>，终于破解完成！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>PocketSphinx实现语音识别</title>
    <url>/posts/7ab4abc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我最近一直在搞一个名叫 A.N.N.A. 的 <code>Python</code> 语音机器人项目（Anna 是什么单词的缩写我就不说了，自己猜去），需要用的强大的语音识别技术。翻看全网教程，没有一篇说的通的，要么就是教会如何购买百度AI会员，要么就是教如何翻墙使用谷歌语音……</p>
<p>我最近发现<code>PocketSphinx</code>语音识别很不错，但是全网还是没有哪篇文章会告诉你，如何从头到尾下载这个库，用这个库进行语音识别，<strong>并且不在电脑上留下任何垃圾</strong>，可以随时删除的安装方法。然后你又会抱怨<code>PocketSphinx</code>有多么垃圾。</p>
<p>在这篇文章里，我将告诉你如何安装<code>pocketsphinx</code>，并将其嵌入<code>speech_recognition</code>库，来更好地实现最终的语音转文字。</p>
<h1 id="电脑环境"><a href="#电脑环境" class="headerlink" title="电脑环境"></a>电脑环境</h1><ul>
<li>系统：<code>macOS Catalina</code> v10.15.3；</li>
<li>软件<ul>
<li><code>Xcode</code> v11（版本其实无所谓）；</li>
<li><code>Homebrew</code> （安装命令：<code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</code>）</li>
<li><code>Python 3</code></li>
</ul>
</li>
</ul>
<h1 id="安装PocketSphinx"><a href="#安装PocketSphinx" class="headerlink" title="安装PocketSphinx"></a>安装<code>PocketSphinx</code></h1><p>我们先来看一下<code>PocketSphinx</code>的依赖关系图：</p>
<pre class="line-numbers language-none"><code class="language-none">PocketSphinx
    |
    |-- SphinxBase
    |  |--libogg
    |  |--libvorbis
    |  |--flac
    |  |--libsamplerate
    |  &#96;--libsndfile
    &#96;-- Swig
         &#96;--PCRE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><p>打开终端，运行如下<code>brew</code>命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew install pcre
$ brew install swig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中，<code>swig</code>是<code>pocketsphinx</code>的依赖，<code>pcre</code>是<code>swig</code>的依赖。<code>swig</code>不需要自己编译，直接用<code>brew</code>安装即可。</p>
</li>
<li><p>再使用<code>brew</code>安装<code>SphinxBase</code>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ brew install SphinxBase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令会将<code>SphinxBase</code>及其所有依赖安装到电脑上。现在，<code>brew list</code>应该如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">index_out_of_range@imac ~ % brew list
cmu-sphinxbase	libogg		libvorbis	portaudio
flac		libsamplerate	openssl@1.1	swig
ldid		libsndfile	pcre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注：<code>portaudio</code>、<code>ldid</code>和<code>openssl</code>是我自己安装的，不用安装。</p>
</blockquote>
</li>
<li><p>克隆<code>PocketSphinx</code>仓库，我们要在之后的步骤手动安装仓库，别问我为什么：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git@github.com:cmusphinx&#x2F;pocketsphinx.git
# 或者（推荐）
git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;cmusphinx&#x2F;pocketsphinx.git
# cd 到仓库
cd pocketsphinx-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：必须<code>clone</code>，直接下载仓库会有文件缺失，因为这个库引用了其它仓库代码。如果网速太慢，可以fq或者把仓库导入<code>gitee</code>。</p>
</li>
<li><p>==使用<code>vim</code>更改关键文件==（如果直接用<code>pip</code>安装，会有文件出错<a class="link"   href="https://github.com/bambocher/pocketsphinx-python/issues/28" >^1<i class="fas fa-external-link-alt"></i></a>）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim deps&#x2F;sphinxbase&#x2F;src&#x2F;libsphinxad&#x2F;ad_openal.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接下来用<code>vim</code>把</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#include &lt;al.h&gt;
#include &lt;alc.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>改为</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#include &lt;OpenAL&#x2F;al.h&gt;
#include &lt;OpenAL&#x2F;alc.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>使用<code>setup.py</code>安装（至关重要的一步，仔细看命令！）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意是<code>python3</code>而不是<code>python</code>。我一开始没加3，结果安装到<code>python2</code>系统目录去了。</p>
</li>
</ol>
<h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>使用如下命令测试<code>PocketSphinx</code>是否安装成功：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">index_out_of_range@imac ~ % python3
Python 3.8.2 (v3.8.2:7b3ab5921f, Feb 24 2020, 17:52:18)
[Clang 6.0 (clang-600.0.57)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pocketsphinx
&gt;&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果像我一样<code>import</code>没有报错，就是安装成功了！</p>
<h1 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h1><h2 id="英文识别"><a href="#英文识别" class="headerlink" title="英文识别"></a>英文识别</h2><p>安装完<code>PocketSphinx</code>后，就进入到我们的第二个阶段，嵌入<code>speech_recognition</code>模块进行语音识别了。你可以将<code>speech_recognition</code>模块理解为众多语音识别SDK与API的一个高层封装模块。使用<code>pip install SpeechRecognition</code>安装即可。</p>
<p>接下来，新建一个<code>.py</code>文件，输入如下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 注：安装时用的是 SpeechRecognition 这一名称，但是注意 import 时要用 speech_recognition 这一名称。
import speech_recognition as sr

r &#x3D; sr.Recognizer()
mic &#x3D; sr.Microphone()

def recognize(r, mic, lang&#x3D;&quot;en-US&quot;):
    print(&quot;Please wait...&quot;, end&#x3D;&quot;&quot;) # 在开始录音前等待
    
    with mic as source:
        r.adjust_for_ambient_noise(source)
        backspace &#x3D; &quot;\r&quot; * 14 # 退格字符
        print(f&#39;&#123;backspace&#125;Say something: &#39;, end&#x3D;&quot;&quot;)
        audio &#x3D; r.listen(source)
    
    # 调用识别函数（这个函数只有安装了 PocketSphinx 才能调用），具体方法看官方文档
    result &#x3D; r.recognize_sphinx(audio, language&#x3D;lang)
    
    # 打印并返回结果
    print(result)
    return result

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    recognize(r, mic)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用终端运行代码（我用<code>VSCode</code>不知为何打不开麦克风）：程序首先会打印<code>Please wait...</code>，等待一会<code>Please wait...</code>会变成<code>Say something:</code>，之后说一句英文（比如<code>hello</code>），程序就会打印出<code>hello</code>。</p>
<p>但是问题来了，我们是中国人啊！于是你把<code>recognize(r, mic)</code>改成了<code>recognize(r, mic, lang=&quot;zh-CN&quot;)</code>，程序报错了。</p>
<h2 id="中文识别"><a href="#中文识别" class="headerlink" title="中文识别"></a>中文识别</h2><p>说白了，程序的报错原因就是你没有中文语言模型，<code>PocketSphinx</code>是默认只有英文的。接下来我们添加中文模型：</p>
<ol>
<li>到 SourceForge 的<a class="link"   href="https://sourceforge.net/projects/cmusphinx/files/Acoustic%20and%20Language%20Models" >这个项目<i class="fas fa-external-link-alt"></i></a>里，找到 Mandarin（普通话），点进去有个<code>tar</code>包，下载下来并解压。</li>
<li>将解压出的目录改名为<code>zh-CN</code>，拖动到<code>/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/speech_recognition/pocketsphinx-data/</code>目录下。</li>
<li>按图中方式，将<code>zh-CN</code>目录里的文件按<code>en-US</code>目录里文件的命名规律改名：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-sphinx-chname.jpg" alt="改名"></li>
</ol>
<p>现在把程序里<code>recognize(r, mic)</code>改成<code>recognize(r, mic, lang=&quot;zh-CN&quot;)</code>，程序成功运行！不过通过实验发现，这个模型识别出来的中文貌似很垃圾……只能自己训练模型了……</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>“木兰”辞</title>
    <url>/posts/37946/</url>
    <content><![CDATA[<blockquote>
<p>针对此前刘雷团队对外宣布“自主研发的‘木兰’编程语言体系“，中科院计算技术研究所1月24日在官网发布相关调查与处理意见，称刘雷在宣传活动中存在虚假陈述行为，同时在对外宣传活动中存在对单位的欺瞒行为。对刘雷的处理包括取消五年内专业技术岗位晋升的申请资格、全所通报批评、岗位等级降低等。中科院计算所1月15日对外发布该所计算机体系结构国家重点实验室编译技术团队自主研发、面向新一代人工智能和物联网应用的“木兰”编程语言体系，同时推出“木兰”开源软件包，供全球用户免费下载获取。随后“木兰”被指出就是Python语言“换了外皮”。中科院计算所随即于1月19日宣布当事人停职检查，对该问题展开深入调查。中科院计算所的最终处理意见称，“木兰”团队主要负责人刘雷在宣传活动中存在虚假陈述行为，同时在对外宣传活动中存在对单位的欺瞒行为。“刘雷交给媒体的宣传材料，与提交给我所宣传主管的审批材料存在严重的不一致，属欺瞒行为。”“木兰”语言分为前后两个版本，团队定义了语言规范，自主开发了编译器、字节码规范和虛拟机，基于开源的Blockly开发了可视化编程环境，针对中小学青少年编程教育开展了一些深入的工作，工作较为系统完整。但向媒体宣称“完全自主设计”有夸大成分；宣称“木兰”是“完全自主设计、开发和实现的编程语言”属虚假陈述；声称“木兰定位为下一代重要应用物联网应用的开发语言”缺乏应用案例的支撑；声称“木兰”语言采用了弹性actor执行模型、利用数据稀疏性提升效率技术属虚假陈述。意见决定对刘雷做出如下处理：取消五年内专业技术岗位晋升的申请资格；取消三年内科研项目的申请资格；全所范围内通报批评；岗位等级从工程师一级降低为助理工程师一级。  </p>
</blockquote>
<h1 id="《木兰辞》改编"><a href="#《木兰辞》改编" class="headerlink" title="《木兰辞》改编"></a>《木兰辞》改编</h1><p>无声复无声，桌前看新闻。不闻打字声，惟闻吾叹息。</p>
<p>问吾何所思，问吾何所忆。吾亦无所思，吾亦无所忆。适才见文章，美国限AI，清单十二卷，卷卷有国名。科研无自主，编程无语言，愿为<code>Python</code>改，从此当原创。</p>
<p>东市下破解，西市换衣裳，南市请砖家，北市发布会。旦辞GitHub去，暮宿中科院，不闻国人求自强，但闻科研经费打水漂。旦见利润高，暮生欺人心，不见中科求自立，但见木兰日夜吞蛇蟒。</p>
<p>狂窜排行榜，狂夺下载量。全国一起用，人人称真香。开发生百bug，运维十年归。</p>
<p>归见负责人，负责坐明堂。下千万功夫，赏千万大洋。负责问所欲，木兰不用走闭源，愿驰千里足，送儿继续闯。</p>
<p>国家内外闻，上网相保存；各语闻妹来，各个皆惊奇；网友闻姊来，逆向霍霍向木兰。开它<code>UPX</code>，撞它脆外皮。脱它假函数，著它真外衣。当窗来解码，照妖镜检查。裸奔同行前，同行皆惊忙：号称自主研，不知木兰是<code>Python</code>，<code>Matlab</code>做计算，H5写UI，双语傍地走，安能辨我是雌雄！</p>
<h1 id="《木兰辞》原文"><a href="#《木兰辞》原文" class="headerlink" title="《木兰辞》原文"></a>《木兰辞》原文</h1><p>唧唧复唧唧，木兰当户织。不闻机杼声，惟闻女叹息。</p>
<p>问女何所思，问女何所忆。女亦无所思，女亦无所忆。昨夜见军帖，可汗大点兵，军书十二卷，卷卷有爷名。阿爷无大儿，木兰无长兄，愿为市鞍马，从此替爷征。</p>
<p>东市买骏马，西市买鞍鞯，南市买辔头，北市买长鞭。旦辞爷娘去，暮宿黄河边，不闻爷娘唤女声，但闻黄河流水鸣溅溅。旦辞黄河去，暮至黑山头，不闻爷娘唤女声，但闻燕山胡骑鸣啾啾。</p>
<p>万里赴戎机，关山度若飞。朔气传金柝，寒光照铁衣。将军百战死，壮士十年归。</p>
<p>归来见天子，天子坐明堂。策勋十二转，赏赐百千强。可汗问所欲，木兰不用尚书郎，愿驰千里足，送儿还故乡。</p>
<p>爷娘闻女来，出郭相扶将；阿姊闻妹来，当户理红妆；小弟闻姊来，磨刀霍霍向猪羊。开我东阁门，坐我西阁床，脱我战时袍，著我旧时裳。当窗理云鬓，对镜帖花黄。出门看火伴，火伴皆惊忙：同行十二年，不知木兰是女郎。</p>
<p>雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>Hopper 一拳搞定 Interface Inspector</title>
    <url>/posts/24364/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近本打算搞定 <code>Downie 4</code>破解版，可谁知开发者用了<code>Swift</code>语言编写，导致我这个小白破解总是不得逞。忽然间听说了一个叫做<code>Interface Inspector</code>的软件，感觉还挺厉害的。接下来先给大家介绍一下（这是官方介绍，不是广告）：</p>
<blockquote>
<p><code>Interface Inspector</code> 使您可以在运行时研究任何<code>macOS</code>应用程序的用户界面结构和属性。</p>
<p>在程序中使用<code>Interface Inspector</code>非常容易。 您可以通过使用<code>Interface Inspector</code>中的快捷键<code>⌘⌥A</code>来使用附加菜单，然后选择要附加到的应用程序。 然后，您可以检查视图属性，或尝试使用不同的值来约束和更多。</p>
<p>将<code>Interface Inspector</code>附加到应用程序后，您可以使用快捷键⇧⌘K通过选择模式轻松标识各个组件。 只需单击您感兴趣的组件，它就会在<code>Interface Inspector</code>中被选中，然后开始分析其属性。</p>
</blockquote>
<p>总结来说<code>Interface Inspector</code>就相当于<code>iOS</code>越狱里的<code>FLEX</code>，或者相当<code>macOS</code>下的<code>Reveal</code>。不过后两者只能用于<code>iOS</code>，而<code>Interface Inspector</code>用于<code>macOS</code>。</p>
<p>这个软件的<strong>最新版本</strong>开发要追溯到2014年，算是一个很久没有更新的软件（估计以后也不会更新），不过仍然是付费的，所以<code>macOS</code>的 crakers，这一次我带你们 patch 它！你们有福利了。</p>
<h1 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h1><p>这次破解，我们的目标是：随便输入注册信息，即可使用App。</p>
<h2 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h2><p>这个软件的最后更新是2014年——如果你懂一些历史的话，你会知道那时候 Apple 的SDK非常落后，开发者的反破解方案很简陋，因此这个软件应该比较好破解。首先我们在注册 License 界面的UI中收集一些字符串（图一是要 License 主页面，图二是输错 License 的页面）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-ui1.png" alt="license 主页面"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-ui2.png" alt="license 错误界面"></p>
<p>我们得到的字符串：</p>
<ul>
<li>Enter your registration details below, exacly as you recieved in your confirmation email:</li>
<li>Invalid license code</li>
<li>Please go back and try again.</li>
</ul>
<blockquote>
<p>注：exacly 单词其实拼错了，应该是 exactly。不过，一切以程序中为准。</p>
</blockquote>
<h2 id="Hopper-分析"><a href="#Hopper-分析" class="headerlink" title="Hopper 分析"></a>Hopper 分析</h2><p>将程序二进制文件拖入 Hopper 分析，然后在<code>Str</code>一栏随便搜索一条我们得到的信息，比如第一条，之后不断按<code>X</code>，找到代码引用的源头：<code>-[SMEnterLicenseViewController loadView]</code>，地址为<code>0x10010ff3a</code>。我们再把<code>SMEnterLicenseViewController</code>作为关键词搜索。这个类就应该是图一的视图管理器。这时候，我们发现了一个很可疑的函数<code>register:</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-search-smelvc.png" alt="搜索SMVC"></p>
<p>我们在<code>register:</code>处下个断，然后运行，随便输入一个<code>Name</code>和<code>License</code>，按下<code>Register</code>键——断下来了！这就说明，<code>register:</code>函数里包含着<code>License</code>的验证流程。</p>
<p>打开伪代码模式：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class SMEnterLicenseViewController *&#x2F;
-(void)register:(void *)arg2 &#123;
    rdx &#x3D; arg2;
    r15 &#x3D; self;
    [self commitEditing];
    r14 &#x3D; [[r15 licenseName] retain];
    if ([r14 length] !&#x3D; 0x0) &#123;
            rbx &#x3D; [[r15 licenseCode] retain];
            r12 &#x3D; [rbx length];
            [rbx release];
            [r14 release];
            if (r12 !&#x3D; 0x0) &#123;
                    r14 &#x3D; [[r15 delegate] retain];
                    r12 &#x3D; [[r15 licenseName] retain];
                    rbx &#x3D; [[r15 licenseCode] retain];
                    [r14 enterLicenseViewControllerDidSelectRegister:r15 withLicenseName:r12 code:rbx];
                    rdi &#x3D; rbx;
                    [rdi release];
                    [r12 release];
                    [r14 release];
            &#125;
    &#125;
    else &#123;
            [r14 release];
    &#125;
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看见，第16行调用了方法<code>enterLicenseViewControllerDidSelectRegister:withLicenseName:code:</code>。我们双击看看这个方法：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class SMLicenseWindowController *&#x2F;
-(void)enterLicenseViewControllerDidSelectRegister:(void *)arg2 withLicenseName:(void *)arg3 code:(void *)arg4 &#123;
    r8 &#x3D; arg4;
    var_30 &#x3D; self;
    r12 &#x3D; [arg3 retain];
    r13 &#x3D; [r8 retain];
    rax &#x3D; [SMLicenseManager sharedInstance];
    rax &#x3D; [rax retain];
    var_38 &#x3D; rax;
    rcx &#x3D; r13;
    rbx &#x3D; [rax registerLicenseWithName:r12 code:rcx];
    [r13 release];
    [r12 release];
    if (rbx !&#x3D; 0x0) &#123;
            [var_30 loadView:0x2, rcx, r8];
            r14 &#x3D; [[var_30 delegate] retain];
            [r14 licenseWindowControllerDidRegister:var_30, rcx, r8];
            [r14 release];
    &#125;
    else &#123;
            [var_30 loadView:0x1];
    &#125;
    [var_38 release];
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们仔细品这段代码。第11行<code>rbx</code>右调用了另一个函数，不过不要紧，<code>rbx</code>应该是一个布尔值。因为第14行的判断说明，如果<code>rbx</code>为真，那么就会执行<code>if</code>代码。你再看看<code>if</code>里的第17行代码里调用了<code>licenseWindowControllerDidRegister</code>方法，从字面来看有“注册成功”的意思，因此<code>if</code>里的代码是我们想要执行的，而不是<code>else</code>里的代码。</p>
<p>上面一自然段完全是我的逻辑判断。如果你觉得我说得啰嗦，你可以通过<strong>下断点</strong>来一步步判断代码到底执行了<code>if</code>，还是<code>else</code>。</p>
<h2 id="修改-License-验证"><a href="#修改-License-验证" class="headerlink" title="修改 License 验证"></a>修改 License 验证</h2><p>想必这一步在坐各位都会了吧！打开<code>CFG Mode</code>，然后按照图中的方式 patch：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-cfg-patch.png" alt="CFG Patch"></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">jne loc_10010d137<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们导出二进制，然后打开应用，成……咦？</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-signerr.png" alt="签名错误"></p>
<h2 id="修复签名验证"><a href="#修复签名验证" class="headerlink" title="修复签名验证"></a>修复签名验证</h2><p>就如提示框说的一样，这个开发者也确实不是傻子，还知道验证个签名，防止程序被 Crack。不过别着急，先用提示框中的文字搜索一波 String：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-search-sign.png" alt="搜索签名 string"></p>
<p>看到了吗？红框中的 String 就是提示框中的字符串。</p>
<blockquote>
<p>这里教大家一个小常识，开发软件中怎样不让别人在逆向中搜索你的 String：你可以将必要的提示框间接写在一个<code>.html</code>中，这样字符串就不会再程序里直接出现。</p>
</blockquote>
<p>之后，我们随便点开一个字符串，不断按<code>X</code>查找引用，终于在<code>applicationWillFinishLaunching:</code>启动函数中的<code>loc_100024851</code>找到。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">loc_100024851:
    r14 &#x3D; [[NSAlert alloc] init];
    var_F8 &#x3D; r14;
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Signature of the Interface Inspector is broken&quot; value:@&quot;&quot; table:0x0] retain];
    [r14 setMessageText:rbx];
    [rbx release];
    [r13 release];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;The application has an unepected signature and seems to be broken or modified. Please re-download the application.&quot; value:@&quot;&quot; table:0x0] retain];
    [var_F8 setInformativeText:rbx];
    rdi &#x3D; rbx;
    rbx &#x3D; *_objc_release;
    [rdi release];
    [r13 release];
    r12 &#x3D; rbx;
    [var_F8 setAlertStyle:0x2];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Quit&quot; value:@&quot;&quot; table:0x0] retain];
    [[[var_F8 addButtonWithTitle:rbx] retain] release];
    [rbx release];
    [r13 release];
    r13 &#x3D; [[NSBundle mainBundle] retain];
    rbx &#x3D; [[r13 localizedStringForKey:@&quot;Visit Website&quot; value:@&quot;&quot; table:0x0] retain];
    rdx &#x3D; rbx;
    [[[var_F8 addButtonWithTitle:rdx] retain] release];
    [rbx release];
    [r13 release];
    if ([var_F8 runModal] &#x3D;&#x3D; 0x3e8) &#123;
            [**_NSApp terminate:0x0];
    &#125;
    else &#123;
            r14 &#x3D; [[NSWorkspace sharedWorkspace] retain];
            r13 &#x3D; [[[[NSBundle mainBundle] retain] localizedStringForKey:@&quot;http:&#x2F;&#x2F;www.interface-inspector.com&quot; value:@&quot;&quot; table:0x0] retain];
            rbx &#x3D; [[NSURL URLWithString:r13, @&quot;&quot;, 0x0] retain];
            [r14 openURL:rbx, @&quot;&quot;, 0x0];
            (r12)(rbx, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(r13, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(rax, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            (r12)(r14, @selector(openURL:), rbx, @&quot;&quot;, 0x0);
            [**_NSApp terminate:0x0, @&quot;&quot;, 0x0];
    &#125;
    [var_F8 release];
    goto loc_100024b88;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>CFG Mode</code>里，流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-signcfg.png" alt="签名CFG流程"></p>
<p>我们只需要把主程序的最后一行<code>jne</code>改为<code>je</code>即可，也就是说，如果签名没有修改，那么就会报错；如果签名被修改，反而不会报错。</p>
<p>将<code>000000010002447e</code>的代码修改为：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">je loc_100024851<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="改头换面"><a href="#改头换面" class="headerlink" title="改头换面"></a>改头换面</h1><p>接下来，我们该修改一下程序的<code>About</code>资源了。在<code>/Applications/Interface Inspector.app/Contents/Resources/</code>目录下找到<code>Credits.rtf</code>，之后在上面加上你自己的 Credit，然后在应用程序顶栏<code>Interface Inspector</code>-&gt;<code>About Interface Inspector</code>，即可看到你的 Credit：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ii-credits.png" alt="你的 credit"></p>
<p>哈哈！我把我的名字加上去了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然这么一个简简单单的小程序，搞起来也不是多么容易。况且我第一次上手时，搜索关键词来来回回搞了很多次呢。就算我们这样破解下来，还有个小小的 bug：每次程序启动，你必须重新输入一遍 Name 和 License，只能算是不完美破解。但是搞下来还是很有收获的——毕竟这个软件本身也来之不易啊！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>《草房子》读后感</title>
    <url>/posts/33945/</url>
    <content><![CDATA[<p>在这几天看的书中，给我印象最深刻的就是《草房子》，令我忍不住想要写些我的感想。</p>
<p>故事讲述了主人公桑桑跟随来接管油麻地小学的父亲来到油麻地期间，令他刻骨铭心、终身难忘的小学六年生活。在这里，他明白了许多发人深省的哲理，亲眼目睹甚至是经历了一连串感人肺腑、撼动人心的故事，例如：他和纸月之间心心相印的感情；不幸的杜小康与厄运作斗争的悲凉与勇敢；男孩细马的善良内心和他对尊严的执着坚持；秦大奶奶在生命的最后一瞬间所闪耀的人性光辉。桑桑在死亡的体验中，对生命深切而唯美的领悟，大人们之间充满诗情画意的情感纠葛……这一切，都在桑桑幼小而简单纯真的心灵里印下了深刻的烙印。</p>
<p>这本书留给我印象最深的，并非是特定一个人物，也不是某件事，而是每一个孩子的正直性格。书里每一章里写到的人物，都有一段非凡的经历，都展示了他们善良的品质、童稚的内心、顽强的意念，就像纸月怕让奶奶操心，在自己受欺负时默默无闻；红门落寞后坚强地面对孤独、饥饿、寒冷、生病、狂风暴雨等种种困难的杜小康；开始不爱学习后来又浪子回头、撑起家庭的细马；包括得了病却坚持上学的桑桑……在他们的心中永远都装满了甜蜜美好的事物，就像是纯洁的天使，在油麻地这片宁静的天空尽情飞翔。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/grass-house-thumb.jpg" alt="草房子"></p>
<p>我认为，每个人都要在心里保留一座草房子，一座充满善良、温暖的草房子，一座充满勇敢、坚强的草房子。《草房子》用这些最纯真的爱告诉我们：每个人的一生都不是一帆风顺的，都充满了酸甜苦辣，困难和幸福犹如白昼和黑夜一样，永远与我们相伴，<strong>当苦难来临的时候，我们不能逃避，要满怀希望，像油麻地的孩子们，微笑着去面对。</strong></p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>个人介绍</title>
    <url>/posts/19608/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0e499d57839a4a17844da8c1fdddf066093f301a1e27ddb71d7601d967d3cda3">fb9485e9b3db22a0b31c2c272a92e2cc6a9ca25ea7de9761ab9b1e137bd75bcd2a9612d9cc31ad3d7c91d04f05d8475dedecb590bfdd1269d523d9e1b3398ae563e1161cee06e5245c06c82c56ad197241898f732d8868631aa2a01e103ce1efa0742854121c67465ba6ded7a85a4e5b6d9cae734c10c092b6b0513c72c55c33ea5b5c4cc005d8887532654d500e7c1222b134654c12099653eb2912ac7949d16387d53506c89f013062bee2278f5737d84ec646307b92f935d3f95d2d71ac3e96f06635474dbf36bc2ac9f9f61590fde241c25be1d48353d4f5a5f18db6974e9490d6118f439219c4abef10238a580a69dee8378786f70ad94167fb23efa45506ef449483822ca95cac85649cdeccf74bb5ffa2c32ec1bc0d0a626a44922622ba6dbe8340ad63ed4c0b894d4cb89a0941374d49383c9ca7ce8cef3e205262c30e83dcae4a94d64996546d9b31905dbc0940cdb61d6403081ec436db72bb471a9598f253f2cda0af848dedb2f8eb23bb98f43c7334aad2f9bcdfd8efdc753147426855d4e55682e59e8442cdbe6543737a7839f5ebc00a19735823c634692c3465a52a398c23009a2e841e04b3016e5cdeb572b67e02531e746c6240aa826f9130f6476a43a66f0670c0758883c3756b430c1cf9292fac33dc7638c92f6073a3719977628c7ebb67e75eee8b7e7f90e3e43ec1601a83ec4e443cf7923e49caf7ad996de23a1849ebeff570492398e18ae08abe31198bc1d334dd7b50100e99ffed67b94f86a67e497669e3cf25c73cc13c5c0609e41d15058955cc3a0215fe078553a26c0a7d068ca0f438865e12a31cd23f92809c7cf78345d5edd31088b3ec04b2f91bb7d043af8ffcaea4f0597ecd3999deeeff7065d547ece4e94eeb00be45ce83276b58eb24bda499d47e093e82c0f96973859ce11814fedc6655496191acf215f5256693521b53c3d695b24565e21b8f585fa241ee3c3bf1ecdb89443e1ee11bbd40031beeca22fcb1b26962ffdd9aacaa3eaade87f0e72eef2737f747bc2869f3dd61c4bb919975310a3ccab052cafa36fd9bce2d801ffc48a97efc1ec1ab28982e71b8ce7b27d835c4a23cd3d5a4842c5c515fc2470b51b9a2e39f62a3284e912908840c8aa0faa6b5fddea5442003599cf39f20dd4dffcb43ab26a6f84cebcd83db1322874792ed4abedfb2e321b2085324fc1fda61f0a7db9aedb832579c93d1fe745b71523d6dd870520168040edd7d578ef68fa30f892fe25898133eb4eaea44434882bb29fa8f60ce6a1a9e27676a6709454099d0c7c77a5fbc107670cdf28214aeb31bc4fce69f985fef7d3cf3dec620303d7d7562f20f6219ba53ae80deb323f29259e373d64058bebecc07907c2884f2346da79b238be730e7b3c0daa665261533d8d994ef986a8838c07f7a4fc6a09d0c84a4baac9127db62e5ed041f1d4803a3518cb860662c40d77a49be3dea9a0c285b29b8b18c1b9fa67367d56059efca93d34661207fce3e1eefa0795dcc0b396d20c77b41beaab96bbe7d51a465ed9e28d74c12e4de8ca62f227309f14fdaea84f4491c76186fce9f59959640e6a3cef6dc704a5eadfaaae19b1b5dbdb9c36b294bed237be2292cf7151e9c4c7b190ec49304aecae83cea9a9d5d9bbf7a37ef89aa408ba76a41f701960d1dbd17f3c2d9c9eb0ccef2be40db8adb5d8ccb6ebc295a45b5cedadd84e87bd0ee25de67da8e162f7ad67a1ce1fcbd0fdf594141af2f47eaf8e1b84729043e0df633a243d2b40ca3108ef524310b370e4ea4339999b7623b983bb62687555967df1e85d5db1b6d8729122ba89ebaade06c0092bd9196cee741d1c6be043920790815b6d98df760bd8dac22024e3ea1a72f347082f03a25842edfdec7cb74ffae81c1f21e585e41de8d4d09f6140d069fae298c7a6e1c73dce5fbc58fd8c79279e2c3db154f04907be67b521aed3b6422ec2c119d8b8e88218667453a7f0f088d38d2da49c63ae1db9655b12f1ca4d6b0e68c27ecedd8530309c641b5d85a8ab1117fa5d322b54a236a3ea23b36be512bfdc290b24b5a6a769e734a69cdd34e5979a8f7a2cacb100d33b28f27a4d0b9a981c75bd93391208a44bc5c148c84ec61b903a8db168823f0a79b08efed78a383d736180437d46869146729e302345732cba1e1f1773e88d6cb1929e9b1128c9a68d5bae647104f53dfe47fb99941afd72aea4bde959e1ee234f243cc75cace050d171560d44121b2430ed883256ffe817ca56ace18064e0bd7f0374e02349b24c7694777921fa4e36366b0f345d04274279e5a6d425011fc80872687cc1caa285f9b5d6403c2f57a878b7af33ba849b3f6f47f364cc4b68c8f5f8a10fbc07a2d957613d346a916f59e71dec428792fde1eb46aabe37c1357501bc0347d5315fbbf57cd7d083c5e659d098302f49e7c6771e93d3ef6109e32eaef731af357ed0324f2012702d8f99affe80f73e043841f6481a0f4392cad87f1f6de5828f7f1abfa02b2bff0dd2d396f17ec199c72565b6410600ca3954efffc7b787a36cc0f5868120b29468ac29d2981b9b50dc800b6df08bd653e9e6d1903f5e4052af95efb295d4a806ac6e6aeccd6f319f01852c0fd90cc2133755a7325f80d42365c8b8f73a5a1956f1e60281c6c35cc4b2f3d11cc8dac95e4581452831f5ac5eb978f15279cfe97966b3bf2e7937a4b3daf7f777c24672724610cba207afbda0c8d78541f214998f75cc9141ef09df63547e8e7f875a231182f539ddd1434f3aa8026ecc069942317985a475bd4dafe29f7eecd168c328d86fa223cc1be5500cefa623d6a8c94080729bd67556989b143e5c3af95645b35ca87aa45de7056185497de2665bcb98a8a98343e5a3d067b553d7459752dc05c1936ff0c128f2e9d844c5eb1f29c6c631c35605ad71596ce5b417ab61c6a5fcfdc97b101f21afd184b278a71c88cc0b6853b603e36c614c28e4a6d64ce15981ac24932e02425f080f3d4e9ad3d3f29fb889364ca0cd23fa27ba2cbb21d8be468fe6634f4fcaba34f25d215d44b4f5e15210c4375c5834fb7f461a15e07c333638dfea0e4217f91863c0453a6f1f3492a2bb6bfb8e6761a0dd1fbd311baeacc596c1316cf7313a58219788b9957857c144ac254aebc9b0e6c74f8b8badb323bab60cf3a1a638e514cb14830e31034586f017b27c757f4a25b5e306b81ef139baded210927439de88a32bdd043a1f05d262774d72945435dfe54aba30f48b9b8791ce186b16ff0bf6dbd8b66d1631a2a7a0c8521ec0a7797595267342f15af77a451f1a1df22f78ca5415c015e5bed0afc30b6b306f1e6952d251dc70c921e99e5b362dc84a1a7edaf255297cd6f834aedfe77d27cae694e831f6b2f57f4436e1e1ced8952d009d092de665dd90f8d7a3eae967c74c1f1b3533a89081a37d829131736c1d1692a2bc1206e022a3fb165eff13e99f4f6bbcb3c569911b858f98547ab97ba830666f1f421644477465020243f7bcbd4894f95e264bfb5137f55fc20b946df46d166e0e2b550a6ccdced3bcf3e74d23bb439c0f976ab20766689eab1ee86c498f17ca0a666bff50e1ca031001d6d98032942b64e5cee99756f0b7b25edc99641efb330b70cef13676a71112fcb55f6c40baa8c97ec89bdfeaaa68f7adc03cccf629e3156d0edaf32a5e4ae6f9586f30a25cec03276418952c6e5d14fc515f8287d91874dab54c3eea6ed96c18d2c64b5350aa62614f84c34f1fc117e55e5ec54b773174bf1693355fd1788927b3d05b2e80fcd90da95afb04981c87461ab80468957bdffec4b4007ffbbd20206ed02c8f4560ced7021facc4869ea91ccca4fd0dfa24c22577bcb5a2ef422cfc6fa3b333b9d03cd5ca1a13d7a0baf985d1784cf8892611b8ee4cc2aadaa30ea3496200a7569ed4aee3199c8821f05e558c8bdc3eba7775b3d05520f208f5da6e5dd5663c32618a723abccfeafdc5929af39bd367c06b7ee8c2be813afc282ede67a736a2e37875e3fe658e015f700e6d69dfb1de649b4a5fc8e5d59eef57ae29b764f5e7920d80df866f4bf8b789041c420f9ab2cdfb6ca91b81a10e6a70896e1f583a80c267ea5cc37e570584d8e9f91cace633e577710c01bcfc672285bb7ba98526d93261aa55d8da22ffefbf86935c4f8e4bb0d63a16a0354878b1adabaef21cc94c7792e3bfd9827930c49d82d2eba769a7e7a6df51a274f451b5a501ad7e57dd72ad3a38c14ce8288c9fcb81703ff8174b74a408205c0a88b70ed9646ab23f3c72a5b8b2cd7002a8b5e6885657b08295c9cfd829827b0bff7688b905e043b19ba3a8cefd25cfbafad5a8fe860d3799bd0aa829b770c15bcd2ef50a12922980ff97d7bac3ca452627b50f696636ba408e3fb766a8d4343ebb0b7e0343806296c7aaa035660a9110782869cb5299735ceaec41604c8d09bc13377b975a30899b18b643e7854e522998133af57dee4db3cd37b49a17bd1fca1b82d3f4dc99a896226ca502a0e1c35a852eecf946cade11525ba43cb3c63558a5c0ebae2f3d7d79a1f5ff12d2e4ffde9ef6f92c0b22a7da5ec045c1fe5a0e1998131ae9f23299b32a72fcac1874acec5bf88fffeba4c50078661177176074845591febdb26c71fcea4e2c699066947eb446e503ea83db995d9a47556ec5b5cae4a17d1455f215c51ff7036427ed2b0abdd62d3b7265f1f82b254da6127ac9c4d1e30bb9d60cc2cd06c3e6772e47d32188743998a4f65e33c4d8e1e553320dc5c672067e59512c2bd534d9127b918c27fa0fdda6bb46c63f14b825daf2e5073a25ad45f3c4307ecb1439767e27a39e64cc0d1641712bddc9c1014f352a0b3e886c5c463abdbf5ac9735f45ad3f6001fedaf575a0597f84c27c6b3b896cad4e04fa9c78cea1764a248d26d9530053ce004a1b4c582623f92d515e5fd4188a1d9bda32c4f64423ecf89ca0b42efe8d32c9656653963ab2e78790361d29ede8faf0c7fd679a1636def18059d96a1ce99c21bc834aa5760c22819238eac792a7c07d86a92c94ba735494f3a3c0896aec8180cbf070ab3efe8cc1a1467258a5cccada490df782e21b46205d205e6554c8bca440fdc0c5c69b84ed59547ccb346d523b8ae98533e3f6b05a84662a2ecc03bdeb70ff41ee56d09e3b25373bb002315f0acc94b4b8669b3c743f82a95054208</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>说明文</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋月</title>
    <url>/posts/c25a8065/</url>
    <content><![CDATA[<p>中秋节到了。一年中最圆的月，就在我眼前。它圆得硬朗、圆得结实，白得明亮、白得柔和。几丝灰色的瘢痕，淡去了冷清平白，增添了一分粗糙的触感。我紧紧贴着窗户，盯着，但它急着往高楼的后头躲——看不到，也就罢了。但是，脑海里闪现出刚刚去姥姥姥爷家串门的画面告诉我，这轮明月对长辈来说却无比重要。</p>
<p>到达姥爷姥姥家。推开门，脱掉鞋子，往旁边随意的一踢，却发现毯子上，三双拖鞋，整整齐齐，朝着大门的方向已经摆好。红的、蓝的、白的，三种颜色，三种大小，与我和父母脚完全吻合。升降椅一个、小方凳一只、纸箱子一个，无疑是为我们换鞋做准备。</p>
<p>我初来客厅。茶几上的水晶垫，光滑油亮，仍保留着抹布的水迹。桌子上的果盘，是用来“祭”三个神仙的：钢盆上是前几天妈妈送的西梅，十九颗黑宝石，冻出一层白色的冷霜；紧接着是黄色的浅盘，三个猕猴桃分半，新鲜的空气使它着凉，透出深入果肉的墨绿；最高级的陶瓷盘上，铺满刚切开的梨，有棱有角、方方正正，都是清一色的白翡翠，并无任何瑕疵；甚至成袋成袋的酸奶也要摆在盆里，温水嘟嘟吐着哈气，酸奶围成一圈躺在盆壁上，仿佛泡着温泉，整齐划一。水果刀、叉子、牙签，整齐地站在三个塑料小盒里，梨皮规整地倒入桌上的垃圾桶中，所有事物一应俱全。</p>
<p>月色入户，时间不早。鞋厅里我们的那盒芒果成了争吵的对象。“妈，那盒芒果你赶紧拿走吧！”“哎呀，你别拿那么多，我这里还有一堆呢，都快放坏了！”“这芒果都软了，盒底下潮着呢。”“那你让天来赶紧吃了啊！”“他和他爸都不吃，剩下的就光我一个人了……”姥爷二话不说，拎起芒果直接塞到妈妈的手里，触电一般，妈妈立刻将它塞回姥爷的手。古铜色的手、白皙一点的手、皱皱巴巴的手，拧在了一起，坚决要把礼品推让给另一方。无奈的声音、严厉的声音、坚决的声音，互相纠缠着，誓不让步。</p>
<p>我只好孤零零地坐在一旁，看着天边最圆、最亮的月亮，忽然明白了姥姥姥爷在月圆之夜的期盼与希望：长辈一年到头，就指望着这一轮明月、一缕月光，在他们的眼里，别无他物，只有对儿女最真切的爱。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>什么？不用中间变量也能交换两个变量的值？</title>
    <url>/posts/4976cae6/</url>
    <content><![CDATA[<p>什么？不用中间变量也能交换两个变量的值？当然可以。本文就来深入讨论一下交换变量的那些事。</p>
<h1 id="使用中间变量"><a href="#使用中间变量" class="headerlink" title="使用中间变量"></a>使用中间变量</h1><p>假设有两个变量a和b，如何交换变量的值？<code>a = b; b = a</code>？不可以。因为计算机的特点是一个周期只能执行一个指令，不可能有两个操作同时发生。所以我们要借助一个中间变量，使两个变量在交换的时候，一个变量有地方等待另一个变量交换完毕，再进行交换。为了行文方便，变量的类型为整数。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/07/19/swap_var.gif" alt="使用中间变量（本图原创，严禁盗用）"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_var(int *a, int *b) &#123;
    int c &#x3D; *a;
    *a &#x3D; *b;
    *b &#x3D; c;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的代码简洁易懂，是编程的最佳选择。作为一名爱好者，让我们继续探索……</p>
<h1 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h1><p>能不能使用简单的加减运算交换数值呢？将a、b两数相加，得到的和减去a得到b，减去b得到a。带着这个理论实践一下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_add(int *a, int *b) &#123;
    int c &#x3D; *a + *b;
    *a &#x3D; c - *a; &#x2F;&#x2F; *a &#x3D;&#x3D; *a + *b - *a &#x3D;&#x3D; *b
    *b &#x3D; c - *a; &#x2F;&#x2F; *b &#x3D;&#x3D; *a + *b - *b &#x3D; *a
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述代码中，给<code>*a</code>和<code>*b</code>赋值的都是<code>c - *a</code>，这是因为两次<code>*a</code>的值不同。第一次<code>*a == *a</code>，第二次a的值变为b，即<code>*a == c - *a == *b</code>。</p>
<p>我们现在想把第三方变量<code>c</code>省去，解决办法是将a与b的和加到a一个人身上。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_add(int *a, int *b) &#123;
    *a +&#x3D; *b; &#x2F;&#x2F; a的值等同于上面的c
    *b &#x3D; *a - *b; &#x2F;&#x2F; 这里的a是a与b的和，减去b自然等于a，将a赋值给b
    *a -&#x3D; *b; &#x2F;&#x2F; 这里的a仍然是a与b的和，减去b自然等于a
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>减法与加法原理相同，符号不同，故不再阐述。</p>
<h1 id="乘除法"><a href="#乘除法" class="headerlink" title="乘除法"></a>乘除法</h1><p>加减法可以实现，乘除法必定也可以实现数值交换。将加减法的原理稍加改变可得：将a、b两数相乘，得到的积除以a得到b，除以b得到a。带着这个理论实践一下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_mul(int *a, int *b) &#123;
    int c &#x3D; *a * *b;
    *a &#x3D; c &#x2F; *a; &#x2F;&#x2F; a &#x3D;&#x3D; a * b &#x2F; a &#x3D;&#x3D; b
    *b &#x3D; c &#x2F; *a; &#x2F;&#x2F; b &#x3D;&#x3D; a * b &#x2F; b &#x3D; a
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们将b乘到a上，得：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_mul(int *a, int *b) &#123;
    *a *&#x3D; *b;
    *b &#x3D; *a &#x2F; *b; &#x2F;&#x2F; 积÷b&#x3D;a
    *a &#x2F;&#x3D; *b; &#x2F;&#x2F; 积÷a&#x3D;b（这里b值已经变为a）
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除与乘大同小异，不再阐述。</p>
<h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><p>让我们进一步提问：逻辑运算可否实现功能呢？用加减乘除交换数值的原理，是算得与两数都有关的一个结果，已知一数可以求另一个数。那么逻辑运算是否可行？哪种逻辑运算有这一特性？</p>
<p>为了方便理解，应当使用二进制。我们来观察一下二元逻辑运算的真值表：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">与</th>
<th align="center">或</th>
<th align="center">异或</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>我们首先排除与运算。因为当结果为0时，无法通过一个参数推断出另一个参数的真假性。</p>
<p>再排除或运算。当结果为1时，只要有一个参数为1即满足结果，与另一参数无关。</p>
<p>然而异或值得探讨。异或规定，相同为1，不同为0。我们只有两个参数，所以如果知道一个参数，还知道另一个参数与这个参数是否相同，我们即可求出另一参数。代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void swap_xor(int *a, int *b) &#123;
    *a ^&#x3D; *b; &#x2F;&#x2F; a存储的是a与b每一位是否相同
    *b ^&#x3D; *a; &#x2F;&#x2F; b依据相同性还原出a
    *a ^&#x3D; *b; &#x2F;&#x2F; a依据相同性还原出b
    &#x2F;&#x2F; 上述代码可简写：*a ^&#x3D; *b ^&#x3D; *a ^&#x3D; *b;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="进一步探讨"><a href="#进一步探讨" class="headerlink" title="进一步探讨"></a>进一步探讨</h1><p>为什么上述方法能实现两个值的交换？它们有什么共同点？</p>
<p>从代码上来看，每一个方法都是使用了不同的量互相推导，因为一步不能做两件事情是必然的；从逻辑上来看，待交换的数值不管怎样需要一个贮存点，可以是一个第三方变量，也可以与其中一个变量一起储存，前提是一起储存的两个变量可以被第三个变量分离。</p>
<p>我觉得我们的认知已经达到一个新的高度上了。</p>
<h1 id="本文代码"><a href="#本文代码" class="headerlink" title="本文代码"></a>本文代码</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void swap_add(int *a, int *b) &#123;
    *a +&#x3D; *b;
    *b &#x3D; *a - *b;
    *a -&#x3D; *b;
&#125;

void swap_mul(int *a, int *b) &#123;
    *a *&#x3D; *b;
    *b &#x3D; *a &#x2F; *b;
    *a &#x2F;&#x3D; *b;
&#125;

void swap_xor(int *a, int *b) &#123;
    &#x2F;&#x2F; *a ^&#x3D; *b;
    &#x2F;&#x2F; *b ^&#x3D; *a;
    &#x2F;&#x2F; *a ^&#x3D; *b;
    *a ^&#x3D; *b ^&#x3D; *a ^&#x3D; *b;
&#125;

void swap_var(int *a, int *b) &#123;
    int c &#x3D; *a;
    *a &#x3D; *b;
    *b &#x3D; c;
&#125;

int main() &#123;
    int a &#x3D; 0b101101;
    int b &#x3D; 0b1010010101;
    time_t start, end;

    printf(&quot;------xor-------\n&quot;);
    printf(&quot;a1: %d\n&quot;, a);
    printf(&quot;b1: %d\n&quot;, b);
    start &#x3D; time(NULL);
    swap_xor(&amp;a, &amp;b);
    end &#x3D; time(NULL);
    printf(&quot;a2: %d\n&quot;, a);
    printf(&quot;b2: %d\n&quot;, b);
    printf(&quot;time&#x3D;%d\n&quot;,difftime(end,start));

    printf(&quot;------add-------\n&quot;);
    printf(&quot;a1: %d\n&quot;, a);
    printf(&quot;b1: %d\n&quot;, b);
    start &#x3D; time(NULL);
    swap_add(&amp;a, &amp;b);
    end &#x3D; time(NULL);
    printf(&quot;a2: %d\n&quot;, a);
    printf(&quot;b2: %d\n&quot;, b);
    printf(&quot;time&#x3D;%d\n&quot;,difftime(end,start));

    printf(&quot;------mul-------\n&quot;);
    printf(&quot;a1: %d\n&quot;, a);
    printf(&quot;b1: %d\n&quot;, b);
    start &#x3D; time(NULL);
    swap_mul(&amp;a, &amp;b);
    end &#x3D; time(NULL);
    printf(&quot;a2: %d\n&quot;, a);
    printf(&quot;b2: %d\n&quot;, b);
    printf(&quot;time&#x3D;%d\n&quot;,difftime(end,start));

    printf(&quot;------nor-------\n&quot;);
    printf(&quot;a1: %d\n&quot;, a);
    printf(&quot;b1: %d\n&quot;, b);
    start &#x3D; time(NULL);
    swap_var(&amp;a, &amp;b);
    end &#x3D; time(NULL);
    printf(&quot;a2: %d\n&quot;, a);
    printf(&quot;b2: %d\n&quot;, b);
    printf(&quot;time&#x3D;%d\n&quot;,difftime(end,start));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>从最简单的程序开始教你怎么破解（一）</title>
    <url>/posts/2615/</url>
    <content><![CDATA[<p>28号我发了一篇关于破解迅雷的文章，如果你看到了，你就会先被那上千的字数吓住。但是破解（反编译）真的有那么难吗？作为一个不太“菜”的“菜鸟”，我想告诉你，其实破解一个软件只是找到思路后，改改二进制的逻辑罢了。但是真的又有这么简单吗？也不是。</p>
<p>如果你刚接触反编译、破解软件，那就从自己开发的最简单的小程序开始破解。今天这篇文章所讲的，是关于如何在MacOS Catalina系统里，使用Hopper Disassembler破解二进制文件。希望我可以通过这篇文章能帮到你。</p>
<h1 id="入手程序"><a href="#入手程序" class="headerlink" title="入手程序"></a>入手程序</h1><p>我们想要破解，可以先从最简单的程序开始——<code>Crackmes</code>。<code>Crackme</code>都是一些公开给别人尝试破解的小程序，制作<code>Crackme</code>的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位<code>Cracker</code>，想挑战一下其它<code>Cracker</code>的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。<code>CrackMe</code>简称<code>CM</code>。有不少论坛的<code>CM</code>大赛就是指这个。我用<code>Swift</code>语言做了几个简单的<code>Crackme</code>，来教你们怎么破解。先看看第一个CM：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm1-thumb.png" alt="CM #1"></p>
<p>我的这个程序首先会用中文打印出说明书和破解要求，然后要求你输入一个固定的序列号，才能激活，如果错误，会提示让你再输入一遍，直到输入正确为止。而你的工作，就是把程序改成输入任意序列号都能激活。</p>
<h1 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h1><p>将这个二进制拖入 Hopper （关于 Hopper 的使用，《破解迅雷》那篇文章有所涉及，不过有时间我可以专门出一篇文章讲 Hopper 的使用，这里不再阐述）分析。分析完成后， Hopper 应该会跳转到<code>_main</code>函数。类似下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-mainfunc.png" alt="main函数"></p>
<p>有人说，不对啊，<code>Swift</code>语言没有<code>main</code>主函数这一说啊，为什么会有它呢？因为，<code>Swift</code>中，写法里没有主函数，但是<code>Swift</code>代码是从上往下依次执行的，因袭编译器在编译中，自然会解析到一种进程，但它不能称作主函数，只能用<strong>主进程</strong>这样的词<strong>形容</strong>。因此，所有代码都会出现在这里。</p>
<p>面对这么多复杂的汇编指令怎么办？自然是要瞧一瞧伪代码：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _main(int arg0, int arg1) &#123;
    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1);
    rsi &#x3D; *type metadata for Any;
    *Crackme__1.serial : Swift.String &#x3D; rax;
    *qword_100002050 &#x3D; 0x1;
    var_20 &#x3D; Swift._allocateUninitializedArray(0x1, rsi + 0x8);
    rax &#x3D; Swift.String.init(\xE8\xAF\xB4\xE6\x98\x8E\xEF\xBC\x9A\xE6\xAD\xA4\xE7\xA8\x8B\xE5\xBA\x8F\xE8\xA6\x81\xE6\xB1\x82\xE4\xBD\xA0\xE8\xBE\x93\xE5\x85\xA5\xE4\xB8\x80\xE4\xB8\xAA\xE5\x9B\xBA\xE5\xAE\x9A\xE7\x9A\x84\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xEF\xBC\x8C\xE6\x89\x8D\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n\xE8\xA6\x81\xE6\xB1\x82\xEF\xBC\x9A\xE6\x8A\x8A\xE7\xA8\x8B\xE5\xBA\x8F\xE6\x94\xB9\xE6\x88\x90\xE8\xBE\x93\xE5\x85\xA5\xE4\xBB\xBB\xE6\x84\x8F\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xE9\x83\xBD\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n, 0x89, 0x0, 0x0);
    *(int64_t *)0x19 &#x3D; *type metadata for Swift.String;
    *(int64_t *)0x1 &#x3D; rax;
    *(int64_t *)0x9 &#x3D; 0x0;
    var_28 &#x3D; default argument 1 of Swift.print();
    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0);
    swift_bridgeObjectRelease(0x0);
    swift_bridgeObjectRelease(0x0);
    swift_bridgeObjectRelease(var_20);
    Crackme__1.verify(var_20, var_28);
    return 0x0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然我不太懂OC，也不太懂这代码说的是什么，但是至少知道了如下几点（看代码注释）：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _main(int arg0, int arg1) &#123; &#x2F;&#x2F; main函数
    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1); &#x2F;&#x2F; Swift的字符串初始化。从字符串看，很可能是注册码：82mal9-29anyw-9msfz6
    ...
    rax &#x3D; Swift.String.init(\xE8\xAF\xB4\xE6\x98\x8E\xEF\xBC\x9A\xE6\xAD\xA4\xE7\xA8\x8B\xE5\xBA\x8F\xE8\xA6\x81\xE6\xB1\x82\xE4\xBD\xA0\xE8\xBE\x93\xE5\x85\xA5\xE4\xB8\x80\xE4\xB8\xAA\xE5\x9B\xBA\xE5\xAE\x9A\xE7\x9A\x84\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xEF\xBC\x8C\xE6\x89\x8D\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n\xE8\xA6\x81\xE6\xB1\x82\xEF\xBC\x9A\xE6\x8A\x8A\xE7\xA8\x8B\xE5\xBA\x8F\xE6\x94\xB9\xE6\x88\x90\xE8\xBE\x93\xE5\x85\xA5\xE4\xBB\xBB\xE6\x84\x8F\xE5\xBA\x8F\xE5\x88\x97\xE5\x8F\xB7\xE9\x83\xBD\xE8\x83\xBD\xE6\xBF\x80\xE6\xB4\xBB\xE3\x80\x82\n, 0x89, 0x0, 0x0); &#x2F;&#x2F; 这一大长串的东西也是字符串初始化，应该是中文，可能是“说明”和“要求”的字符串
    ...
    var_28 &#x3D; default argument 1 of Swift.print();  &#x2F;&#x2F; 打印了那一长串中文
    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0); &#x2F;&#x2F; 打印了那一长串中文
    ...
    Crackme__1.verify(var_20, var_28); &#x2F;&#x2F; 调用了一个叫verify的函数
    return 0x0; &#x2F;&#x2F; 程序结束
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最吸引人的是<code>verify()</code>函数，它有两个参数：<code>var_20</code>和<code>var_28</code>。这个函数把这两个参数做比较，最后打印出结果。因为函数后面没有打印结果的操作，所以这个打印结果的操作应该在函数里。</p>
<p>双击这个函数，就能查看。这个函数不短（其实源代码很短），我们来看关键点：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">int _$s10Crackme__16verifyyyF(int arg0, int arg1) &#123;
    ... &#x2F;&#x2F; 定义了一些东西，还打印了说明和要求
    if ((var_89 &amp; 0x1) &#x3D;&#x3D; 0x0) &#123; 
        &#x2F;&#x2F; 判断语句
    &#125;
    else &#123; 
        &#x2F;&#x2F; 判断语句
    &#125;
    rax &#x3D; outlined consume of Swift.String?(var_70, 0x1);
    return rax; &#x2F;&#x2F; 执行一些结束用的代码
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们只要让程序执行正确的语句就行了。但是怎么判断条件语句中<code>if</code>是正确的，还是<code>else</code>是正确的呢？经过仔细观察，我们看见了<code>if</code>中有一个代码：</p>
<pre class="line-numbers language-objectivec" data-language="objectivec"><code class="language-objectivec">Crackme__1.verify(var_D0, rsi);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按照程序的思路，用户输错了，程序会提示你错误，然后再次调用函数，让用户重新输入序列号。函数中会嵌套一个同样的函数，不难看出这是<strong>递归</strong>，按照思路走，递归一般会使用在用户序列号错误的情况，因此：<code>if</code>中是用户输错的情况，<code>else</code>是输对的情况。只要让程序执行<code>else</code>代码块即可。</p>
<h1 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h1><p>随便在<code>else</code>中选一段代码，切回<code>CFG Mode</code>，可以看到，这段代码在<code>loc_100000ba2</code>里，因此<code>loc_100000ba2</code>是正确代码。沿着上面的箭头找，就会发现上面的主程序是<code>_$s10Crackme__16verifyyyF</code>函数，只需把函数下的<code>jne</code>做一个硬性跳转，换成<code>jmp</code>：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">jmp loc_100000ba2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-jmp.jpg" alt="换成jmp"></p>
<p>之后按回车。</p>
<h1 id="修改完成"><a href="#修改完成" class="headerlink" title="修改完成"></a>修改完成</h1><p>回车后，你的 Hopper 可能会出现这个诡异的画面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-cfgbug.png" alt="CFG bug"></p>
<p>不用怕，这只是 Hopper 的 CFG bug。之所以它显示这个画面，是因为你在CFG模式下，然而你的光标自动跳转到了白色区域的代码，这段代码已经不存在了（被<code>ret</code>了）。因此随便点击 Hopper 的任意位置（白色区域代码外），就可以回到 CFG 了。接下来，让我们在纵观一下 CFG：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-cfg.png" alt="纵观 CFG" style="zoom:50%;" />

<p>怎么样？刚才的两个分支变成了一个分支了。运行一下程序，无论输入什么，都可以成功激活。这么鼓捣下来，还是挺有趣的。</p>
<blockquote>
<p>再次声明：<strong>无论任何人使用文章中的技术破解任何软件造成的后果，请自行承担</strong>。  </p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，小雀儿们</title>
    <url>/posts/55334894/</url>
    <content><![CDATA[<p>我亲爱的小雀儿们：</p>
<p>&emsp;&emsp;你好！你们还好吗？</p>
<p>&emsp;&emsp;实在抱歉，我把你们孤零零丢在这个院子里，已经有一周了。我仍然有许多事要做，不能天天看望你们。<strong>我多么希望你们允许我爬上高大的柿子树，抚摸你们光滑的羽毛，并给你们一个热情的拥抱啊！</strong></p>
<p>&emsp;&emsp;我们之间的故事还得从我上六年级时说起。<strong>那个冬夜，明月别枝，没能留住绿蓝色的喜鹊；那个冬夜，你们出现，温暖了我们一家人的心；那个冬夜，谁没料到，这片土地成了你们的家。</strong>在寒冷破晓时雾霾的笼罩下，你们从葡萄架上的凌霄乱枝中，探出头来，好奇地望着石家庄，好像刚出生的婴儿，渴望得到一点依靠。</p>
<p>&emsp;&emsp;<strong>你们知道，那天中午，你们饿坏了，停在凌霄上；你们肯定不知道，是我拿起餐桌上的那块干馒头，加热，一块一块掰开，撕碎</strong>——既不想让你们悻悻而去，也不想拖延你们的用膳时间，更不想使你们撑坏了胃。妈妈将馒头渣放到托盘里，端到院子里的木桌上。然而实际上，她前脚还没迈出大门，你们就一哄而散，警惕地转移到更高的柿子树稍上，躲着我们。时间一分一秒地过去，一只小鸟飞进了托盘，嗅一嗅，望一望；然后是第二只、第三只……我紧紧贴在玻璃窗上观察你们的一举一动：你们兵分两路，一队飞到凌霄架上，另一队停在托盘里，有秩序地围成两三个同心圆环，亲着木桌，啃着食物，还不忘记时不时交换一下里环和外环的位置；再过一会，两个小分队竟然交换工作，原先吃食的小鸟改在凌霄架上放哨，放哨的小鸟，也围城几个圈，井井有条地用起膳来……一个扰乱公共秩序的人，但凡看到你们此景，必然感动得掉下眼泪。</p>
<p>&emsp;&emsp;<strong>你们知道，你们中的一员，一个下午，天气晴朗，遭遇了民心河边一个拿弹弓打鸟的、可恶的社会闲散人员的袭击；你们肯定不知道，那个下午，我站在门口，黑压压的一块颜色如同炮弹忽地摔到地上。</strong>那竟是你们的同伴！我们没有能力给它上药，我们没有条件请医生救治。是我把它小心翼翼地放在一个干净的快递盒中，只能祈求奇迹的发生。它的血染湿了盒子的每个角落，殷红中透着深棕。这是无辜者的血，这是凶手手上肮脏的血！日落西山，你们中的这一员，在这世界的一隅，安静地睡着了。在这世上最不重要、又最重要的生命，就这样殒落了。那个凶手，是会受到道德的谴责呢，还是法律的制裁？</p>
<p>&emsp;&emsp;<strong>你们知道，我寒假的一个中午，你们正吃着饭，突然看到院子外橙色的炸弹被掷来掷去，听到的声音振聋发聩，只见战火纷飞；你们肯定不知道，那几天的中午，为了锻练身体，我爸爸多少次催我投实心球，而我又是多少次因为不甘心打扰你们用膳，而没有履行了爸爸的命令。</strong>我很抱歉，只是我那天迫不得已，还是——投了。但是，我深深认识到，你们一次次受到惊吓，简直比长途飞行还劳累……</p>
<p>&emsp;&emsp;你们陪伴我度过了初中的第一个学期，正是石门好风景，无业时节又逢君。我在此真诚地给你们问声好，与你们第一次会心交谈；同时也请求你们，不要害怕，接受我的问候，主动接近，消除隔阂，飞下柿子树，与我热情地拥抱。为什么我对这土地饱含感情？因为我对你们爱得深沉。</p>
<p>&emsp;&emsp;敬祝</p>
<p>安好</p>
<p align="right">你的家人 M.T.L.<br>2021年3月6日</p>]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>书信</tag>
      </tags>
  </entry>
  <entry>
    <title>你没看错：动手开发GUI简单操作系统（一）</title>
    <url>/posts/88254ba6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我终于想好发布这篇文章，以前自己一直在摸索开发，保证100%原创。这个操作系统异常简单，没有Windows的高级，没有OS X的华丽，更没有Linux的强大——也别指望了，<strong>对于个人来说根本没多少生产力，只能用来学习知识，自己整着玩。</strong>但是，OS开发的资料太少了，“你没看错”系列中的每一行代码，确实是作者我本人摸滚打爬才得来的。</p>
<p>或许我的文字在各位大佬眼中会很简单。所以说，我尽力吧，简明易懂，不加废话。如果有不专业的地方，直接留言改正，谢谢。</p>
<p>我准备出一系列“你没看错”文章，一定会有后续的。OS一篇文章讲不完，我的写法是理论和实践相辅相成，一点点讲。</p>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><p>第一天我们的目标很简单，主要是写启动扇区：</p>
<ol>
<li>实现在启动扇区打印字符串</li>
<li>在启动扇区打印地址</li>
<li>添加读取磁盘的功能</li>
</ol>
<p>这些实现主要是为以后加载内核、出现错误调试做准备。</p>
<h1 id="要求知识"><a href="#要求知识" class="headerlink" title="要求知识"></a>要求知识</h1><ol>
<li>汇编语言不要求精通，但一定要熟悉，有基本了解；</li>
<li>C语言要会，写内核要用；</li>
<li>shell必须会敲命令，没得说；</li>
<li>可以先修一些附加技能，比如gdb、Makefile等，也可以先了解相关概念。</li>
</ol>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>在开发之前，我们需要配置开发环境。我使用的是Mac，终端用的是zsh。如果有能力，可以用Linux，因为Linux包含开发过程中大部分的工具。如果是Windows……那就去论坛下载个虚拟机，使用Linux吧。为了不让诸位一上来就被各种安装震慑住，我们开发一点安装一点。首先（假设你有<code>Homebrew</code>，一定要<strong>换源</strong>）：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew install qemu nasm # 怎么样？很简单吧<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>简单认识一下：<code>qemu</code>是个开源的模拟器，<code>nasm</code>是Netwide汇编编译器。</p>
<h1 id="加载启动扇区"><a href="#加载启动扇区" class="headerlink" title="加载启动扇区"></a>加载启动扇区</h1><p>我们的操作系统，从<code>bootsector</code>写起。这个<code>bootsector</code>是个启动扇区。<strong>当这个分区被识别有效后，系统就会启动。</strong>我们的首要目标是创建能被识别的bs。</p>
<p>为了检测磁盘是可启动的，BIOS会检测第511和512字节是否为十六进制AA55。记住0xAA55，这个数字是硬件开发者所设置的。</p>
<p>新建你的项目文件夹，给你自己的系统起个名字，比如我的叫<code>Venus</code>。创建<code>bootsect.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">loop:
    jmp loop ; 开始递归，在这里做无限循环。其实也可以用hlt或者jmp $实现。

times 510 - ($-$$) db 0 ; 在bs前放上510个0
dw 0xAA55 ; 在第511字节处，定义0xAA55，覆盖两个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们编译、模拟两步走：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ nasm -fbin boot_sect.asm -o boot_sect.bin 
$ qemu-system-x86_64 boot_sect.bin # 如果错误，改成qemu boot_sect.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-hlt.png" alt="bs-hlt"></p>
<p><strong>至此，你迈开了第一步！</strong>系统在引导之后，进入了无限循环。</p>
<h1 id="输出至屏幕"><a href="#输出至屏幕" class="headerlink" title="输出至屏幕"></a>输出至屏幕</h1><p>先来了解一下中断：</p>
<blockquote>
<p>在点击鼠标或键盘时（正如我现在在做的事情），计算机会立即给我反馈处理结果，计算机与我们之间是在进行实时交互的。<strong>而实时性的实现便是依赖了中断</strong>，中断是为了顺应人们对实时性交互的需求而产生的技术。中断之所以有用，是因为它会立刻停下当前的程序（软件）去做另外一件事。</p>
</blockquote>
<p>我们希望启动后，让系统在屏幕上输出几个字符：’Venus’。<strong>我们需要用到<code>int 0x10</code>。这个中断用于控制屏幕输出，它好比一个约定俗成的函数，有两个参数，ax寄存器的低位al就是要输出的字符，高位ah就是控制输出模式的指示符。</strong>代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ah, 0x0E ; 指示符为0x0E代表tty模式（你应该知道tty是什么，TeleTYpe）
mov al, &#39;V&#39;  ; 把al赋值&#39;V&#39;
int 0x10     ; 终端输出
mov al, &#39;e&#39;  ; 重复以上流程
int 0x10
mov al, &#39;n&#39;
int 0x10
mov al, &#39;u&#39;
int 0x10
mov al, &#39;s&#39;
int 0x10

jmp $

; BIOS识别的数字
times 510 - ($-$$) db 0
dw 0xAA55 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们编译、模拟两步走：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-print.png" alt="bs-print"></p>
<h1 id="完善打印功能"><a href="#完善打印功能" class="headerlink" title="完善打印功能"></a>完善打印功能</h1><p>为了方便我们今后的调试，我们需要完善打印功能，这样出了什么差错直接print就OK了。我们的打印分为两种：打印字符串和打印地址。</p>
<h2 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h2><p>都知道，C语言中的字符串结构长这样：</p>
<pre class="line-numbers language-none"><code class="language-none">&quot;Venus&quot; -&gt; &#39;V&#39; &#39;e&#39; &#39;n&#39; &#39;u&#39; &#39;s&#39; &#39;0x0&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>都是几个字符再加上一个空字节0x0。如果要打印字符串，而不是单个字符，在汇编里面，可以对应成一个栈来处理。同目录新建一个<code>print.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print:
    pusha ; 将所有东西压入栈

; 记住：一直循环打印栈的字符，直到碰到字符串末0x0
; while (string[i] !&#x3D; 0) &#123; print string[i]; i++ &#125;

start:
    mov al, [bx] ; bx相当于字符串参数，是字符串的首位
    cmp al, 0    ; al和0比较
    je done      ; 如果相等，就到了字符串末尾，跳转到结束done

    mov ah, 0x0E ; 如果不相等，开始打印，先进入tty模式
    int 0x10     ; 直接中断。因为al参数已经有字符了

    add bx, 1    ; 如果你把这个栈+1，相当于地址后移一位，这样再打印就是下一个字符串
    jmp start    ; 递归

done:
    popa         ; 弹出栈  
    ret          ; 返回主程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们再空几行，实现一个附加功能——换行：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print_nl:        ; print NewLine
    pusha
    
    mov ah, 0x0E ; tty模式
    mov al, 0x0A ; 把0x0A和0x0D合起来相当于\n
    int 0x10
    mov al, 0x0D ; 把0x0A和0x0D合起来相当于\n
    int 0x10
    
    popa
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="打印地址（4位）"><a href="#打印地址（4位）" class="headerlink" title="打印地址（4位）"></a>打印地址（4位）</h2><p>打印地址也很有用的。但它涉及到一个把指定字符转换为ASCII的问题。因为传入的参数不是带引号的字符串，而是譬如0x1234这样的地址，那到底应该打印什么呢？转换方法如下：</p>
<blockquote>
<h3 id="字符与ASCII对应关系"><a href="#字符与ASCII对应关系" class="headerlink" title="字符与ASCII对应关系"></a>字符与ASCII对应关系</h3><p>数字转换：0<del>9是0x30</del>0x39，所以<strong>把数字加上0x30</strong>即是ASCII；</p>
<p>字母转换：A<del>F（当成1</del>6）是0x41~0x46，所以<strong>把字母加上0x40</strong>。</p>
</blockquote>
<p>代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">print_hex:
    pusha
    mov cx, 0 ; cx在循环指令和重复前缀中，作循环次数计数器

; 参数dx：要打印的地址
hex_loop:
    cmp cx, 4 ; cx是不是已经循环了四次？
    je end    ; 如果是，跳转到end结束
    
    ; 如果不是：开始处理

    mov ax, dx     ; 在ax上对字符处理，（dx是我们的地址参数）
    and ax, 0x000F ; 先把这个地址只保留最后一位。比如0x1234就变成0x0004
    add al, 0x30   ; 加上30，这样4就会变成ASCII：34（别忘了这个al是ax的一部分，是一个寄存器——
    cmp al, 0x39   ; 如果发现这个数字&gt;9，不是0～9，那么这个数字就是字母，加上7，就会是A~F中的一个
    jle step2      ; Jump if Lower or Equal：al小于等于0x39跳转至step2
    add al, 7

step2:
    ; 第二步：我们的ASCII字符应该放在哪个地址呢？
    ; 地址BX：基地址+字符串长度（5位，别忘了还有最后的0x0）-字符索引
    mov bx, HEX_OUT + 5 ; 基+长
    sub bx, cx          ; -索引
    mov [bx], al        ; 把al中的字符移到[bx]，中括号表示地址的内容
    ror dx, 4           ; ROll Right：0x1234 -&gt; 0x4123 -&gt; 0x3412 -&gt; 0x2341 -&gt; 0x1234. ror帮我们实现类似遍历字符串的效果。你可以去掉这行指令，看看会发生什么

    add cx, 1           ; 循环计数器+1
    jmp hex_loop        ; 回到循环

end:
    mov bx, HEX_OUT     ; 把HEX_OUT设置到bx里，作为下一个call的参数
    call print          ; 调用写好的print.asm

    popa
    ret

HEX_OUT:
    db &#39;0x0000&#39;, 0 ; 这是我们输出的地址，先定义下来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="尝试使用打印功能"><a href="#尝试使用打印功能" class="headerlink" title="尝试使用打印功能"></a>尝试使用打印功能</h2><p>编写<code>bootsect.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]

mov bx, GREETINGS ; 设置参数
call print        ; 打印
call print_nl     ; 换行

mov dx, 0x4567    ; 设置参数（地址）
call print_hex    ; 打印十六进制


mov bx, SHUTDOWN  ; 同上
call print
call print_nl

jmp $             ; 挂起程序，无限循环（hlt也行）

%include &quot;boot_sect_print.asm&quot;
%include &quot;boot_sect_print_hex.asm&quot;

; 定义两个数据，注意末尾一定要带0字节
GREETINGS:
    db &#39;Welcome to Venus&#39;, 0

SHUTDOWN:
    db &#39;Shutdown&#39;, 0

times 510-($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说明两个地方：</p>
<ol>
<li><code>[org 0x7C00]</code>：org是用来设置程序基址的。因为BIOS将bs加载到0x7C00的位置，所以我们设置基址为0x7C00。这行指令的中括号去掉也行。</li>
<li><code>%include</code>：用来引用文件，后面跟上空格和双引号，双引号里写文件名称。值得注意的是，**<code>%include</code>命令相当于把引用的文件直接替换到程序中**，不做任何操作。</li>
</ol>
<p>还是按老办法编译、模拟：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/bs-final.png" alt="bs-final"></p>
<h1 id="读取磁盘"><a href="#读取磁盘" class="headerlink" title="读取磁盘"></a>读取磁盘</h1><p>好了，最枯燥却最有用的功能来了，读取磁盘。我们总不能神经质地把整个系统都放在启动扇区。我们先了解一下磁盘（这个部分必须看）：</p>
<h2 id="磁盘基础"><a href="#磁盘基础" class="headerlink" title="磁盘基础"></a>磁盘基础</h2><h3 id="盘片、片面和磁头"><a href="#盘片、片面和磁头" class="headerlink" title="盘片、片面和磁头"></a>盘片、片面和磁头</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct1.png" alt="dsk-struct1" style="zoom:50%;" />

<p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。</p>
<h3 id="扇区（sector）和磁道（track）"><a href="#扇区（sector）和磁道（track）" class="headerlink" title="扇区（sector）和磁道（track）"></a>扇区（sector）和磁道（track）</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct2.png" alt="dsk-struct2" style="zoom:50%;" />

<p>上图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）。</p>
<h3 id="磁头（head）和柱面（cylinder）"><a href="#磁头（head）和柱面（cylinder）" class="headerlink" title="磁头（head）和柱面（cylinder）"></a>磁头（head）和柱面（cylinder）</h3><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-struct3.png" alt="dsk-struct3" style="zoom:50%;" />

<p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 </p>
<h2 id="开始读取吧！"><a href="#开始读取吧！" class="headerlink" title="开始读取吧！"></a>开始读取吧！</h2><p>我就直接放代码了，没什么技术含量，只不过有一些关键的寄存器数值与中断号码需要明白：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 参数：
;   - dh：扇区个数
;   - dl：磁盘
; 读取的数据存入es:bx

disk_load:
    pusha              ; 压入栈
                       ; 将dx也压入栈
    push dx            ; dx一会会被读取磁盘的操作覆盖，所以先压入栈保存

    mov ah, 0x02       ; BIOS 读取扇区的功能编号
    mov al, dh         ; AL - 扇区读取个数，也就是我们的dh
    mov cl, 0x02       ; CL - 从哪里开始读取，因为第一个扇区是启动扇区，所以这里是0x02
    mov ch, 0x00       ; CH - 柱面编号(0x0-0x3FF)
    mov dh, 0x00       ; DH - 磁头编号(0x0-0xF)

    int 0x13           ; 读取磁盘的中断标号
    jc disk_error      ; Jump if Carry：如果CF被设置，就是出现了错误，跳转
    
    ; 如果没有错误
    pop dx             ; dx我们用完了，弹出栈
    cmp al, dh         ; 此时bios会把al设置为扇区个数，对比一下
    jne sectors_error  ; 如果两者不一样，读取扇区出现了错误，跳转
    popa               ; 如果一样，停止程序
    ret

; 剩下的是错误处理部分，大家都明白
disk_error:
    mov bx, DISK_ERROR
    call print
    call print_nl
    mov dh, ah
    call print_hex
    jmp disk_loop

sectors_error:
    mov bx, SECTORS_ERROR
    call print

disk_loop:
    jmp $

DISK_ERROR: db &quot;Disk read error&quot;, 0
SECTORS_ERROR: db &quot;Incorrect number of sectors read&quot;, 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们将启动扇区代码<code>bootsect.asm</code>做出如下更改：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]
mov bp, 0x8000 ; 把栈顶设成0x8000，这样不与BIOS相干
mov sp, bp     ; 同上
mov bx, 0x9000 ; es:bx &#x3D;&#x3D; 0x0000:0x9000 &#x3D;&#x3D; 0x09000

; 现在我们要设置disk_load参数
mov dh, 2 ; 读取两个扇区
; 此处不用设置dl，BIOS已经帮我们设置过了
call disk_load ; 调用

mov dx, [0x9000] ; 获取第一扇区
call print_hex
call print_nl

mov dx, [0x9000 + 512] ; 获取第二扇区（注意偏移地址，跟下面数据对应）
call print_hex

jmp $

%include &quot;print.asm&quot;
%include &quot;print_hex.asm&quot;
%include &quot;disk.asm&quot;

times 510 - ($-$$) db 0
dw 0xAA55

; 上面是bs（第一个扇区）
times 256 dw 0x1234 ; 第2
times 256 dw 0x5678 ; 第3
; 上面的第二第三也不一定，因为有的磁盘一个扇区512，现在有的4096
; …………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/10/dsk-final.png" alt="dsk-final"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>别着急，这只是第一天呢，离加载内核还远着呢。我给大家指指路，我们已经可以读取磁盘，接下来我们需要：</p>
<ol>
<li>加载启动扇区</li>
<li>读取磁盘，加载内核</li>
<li>从命令行转成GUI图形界面</li>
<li>设置GDT（代码最简单，但是最困难的部分，也消耗了我的大部分研究时间）</li>
<li>切换到32bit保护模式</li>
<li>执行内核：kernel_main</li>
<li>正式切换到C语言！</li>
</ol>
<p>剩下的几个步骤我会划分成几天的内容，发布文章讲解。</p>
<p>其实我写着写着突然想到这不就跟革命斗争一样吗，在执行内核前是多么煎熬，执行内核切换C语言后跟解放了一样。</p>
<p>一点点来吧。</p>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>《你没听错：动手开发GUI简单操作系统》系列</tag>
      </tags>
  </entry>
  <entry>
    <title>使用零宽字符对文本加密的实现</title>
    <url>/posts/a1f4eeb7/</url>
    <content><![CDATA[<blockquote>
<p>本文为 <a class="link"   href="http://www.52pojie.cn/" >www.52pojie.cn<i class="fas fa-external-link-alt"></i></a> 首发</p>
<p>《使用零宽字符对文本加密的实现》</p>
<p>@TLHorse</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说来话长。其实就是前几天我看到了一篇介绍Unicode的文章，里面介绍Unicode字符的广泛性。其中有一类字符叫做零宽字符，它们在电脑上输入，不可见，也不可打印，甚至输入都不会占空间，作用是控制文字排列或解决个别语言中的排版问题。</p>
<p>常见的零宽字符有以下六种：</p>
<table>
<thead>
<tr>
<th>中文名</th>
<th>英文名</th>
<th>U+</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>零宽度空格符</td>
<td>zero-width space</td>
<td>U+200B</td>
<td>用于较长单词的换行分隔。</td>
</tr>
<tr>
<td>零宽度非断空格符</td>
<td>zero width no-break space</td>
<td>U+FEFF</td>
<td>用于阻止特定位置的换行分隔。</td>
</tr>
<tr>
<td>零宽度连字符</td>
<td>zero-width joiner</td>
<td>U+200D</td>
<td>用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果。</td>
</tr>
<tr>
<td>零宽度断字符</td>
<td>zero-width non-joiner</td>
<td>U+200C</td>
<td>用于阿拉伯文、德文、印度语系等文字中，阻止会发生连字的字符间的连字效果。</td>
</tr>
<tr>
<td>左至右符</td>
<td>left-to-right mark</td>
<td>U+200E</td>
<td>用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右。</td>
</tr>
<tr>
<td>右至左符</td>
<td>right-to-left mark</td>
<td>U+200F</td>
<td>用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左。</td>
</tr>
</tbody></table>
<p>使用这些零宽字符可以实现发空白消息、发空白朋友圈等效果。不妨动脑筋一想，我们可以把这几种字符组合起来，就可以实现加密字符串的效果。</p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>这篇文章咱们只介绍一个初步实现，说不定以后我会出后续，给应用添加更多功能。下面是加解密的流程图。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/04/zwe-graph.jpg" alt="ZWE流程图"><br>总之我认为解密过程较为繁琐。</p>
<h1 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h1><p>激动人心的时刻到啦。让我们一步步编写。<br>首先在全局定义三个常量：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">ZW_ONE &#x3D; u&quot;\u200b&quot; # 用来翻译1
ZW_ZERO &#x3D; u&quot;\u200c&quot; # 用来翻译0
ZW_SEP &#x3D; u&quot;\u200d&quot; # 用来翻译字符之间的间隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="加密函数-str2zwstr-origin"><a href="#加密函数-str2zwstr-origin" class="headerlink" title="加密函数 str2zwstr(origin)"></a>加密函数 <code>str2zwstr(origin)</code></h2><p>首先我们新建一个空数组，用来存储字符串每一项，并且遍历明文，使明文的每个字符<strong>先用<code>ord()</code>转换成十进制数字，再用<code>bin()</code>转换成二进制。再转换成字符串格式，最后去掉<code>0b</code>前缀</strong>：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_text &#x3D; []
for char in origin:
    bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>再创建一个空字符串，用来存储最终的结果：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">final_str &#x3D; &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后进行两次遍历，先浅层遍历<code>bin_text</code>，然后为每一项深层遍历：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">for item in bin_text: # 遍历大数组每一项
    for binchar in item: # 遍历每一项中的0和1
        final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO # 把0、1分别翻译成两种零宽度字符串
    final_str +&#x3D; ZW_SEP # 每一项（字符）结束后，插入一个分隔符号
final_str.rstrip(ZW_SEP) # 去掉
return final_str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后返回<code>final_str</code>即可。<br>整体代码：</p>
<pre class="line-numbers language-none"><code class="language-none">def str2zwstr(origin):
    bin_text &#x3D; []
    for char in origin:
        bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))

    final_str &#x3D; &quot;&quot;
    for item in bin_text:
        for binchar in item:
            final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO
        final_str +&#x3D; ZW_SEP
    final_str.rstrip(ZW_SEP)
    return final_stry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="解密函数zwstr2str-enc-str"><a href="#解密函数zwstr2str-enc-str" class="headerlink" title="解密函数zwstr2str(enc_str)"></a>解密函数<code>zwstr2str(enc_str)</code></h2><p>首先我建议大家再看看基本思路中的流程图。解密不大相同。因为一开始我们要把翻译后的数据存储到第一个字符上，但是遇到分隔符后，我们又得新建一个字符，并把接下来的翻译后的数据存储到第二个字符串上，因此我们要编写一个函数<code>apponlast(arr, sth)</code>，每次运行，都将sth拼接到arr的最后一项中，如果arr的项数为0，即新增一个元素。</p>
<p>我这里用的代码极为简洁：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def apponlast(arr, sth):
    la &#x3D; len(arr) # la 是 arr 的长度
    if la: arr[la-1] +&#x3D; sth # 如果长度不为0，那么就把 arr 的最后一项与 sth 字符串拼接
    else: arr.append(sth) # 如果数组里没有元素，新建一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后编写解密函数：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def zwstr2str(enc_str):
    arr_oz &#x3D; [] # 由0和1构成的字符串构成的数组
    for char in enc_str: # 在密文里遍历
        if char &#x3D;&#x3D; ZW_ONE: apponlast(arr_oz, &quot;1&quot;) # 如果是\200b，翻译成1
        elif char &#x3D;&#x3D; ZW_ZERO: apponlast(arr_oz, &quot;0&quot;) # 如果是\200c，翻译成0
        elif char &#x3D;&#x3D; ZW_SEP: arr_oz.append(&quot;&quot;) # 如果是分隔符，把数组新建一项，重新开始循环
        else: print(&quot;Input contains non-ZW string. Aborted.&quot;); getinput() # 如果密文中有非零宽字符，终止解密并回到程序主函数（我们一会要编写）

    for idx in range(0, len(arr_oz)-1): # 遍历这个由0和1构成的字符串构成的数组
        arr_oz[idx] &#x3D; chr(int(arr_oz[idx], 2)) # 把每一项先转换为int（注意二进制参数），然后用chr转换为字符

    return &quot;&quot;.join(arr_oz) # 拼接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="完善程序"><a href="#完善程序" class="headerlink" title="完善程序"></a>完善程序</h1><p>接下来我们为程序添加一个主函数，并且加些花哨的功能。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pbanner()
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>pbanner()</code>用来打印banner：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">
def pbanner():
    banner &#x3D; colored(f&quot;&quot;&quot;
      ______
     &#x2F;___  &#x2F;\\  Zerowidth String Encoder | @TLHorse from 52pojie
    &#x2F;&#x2F;  &#x2F; &#x2F; \\\\ Type in then ENTER. The encoded string
    \\\\ &#x2F; &#x2F;__&#x2F;&#x2F; will be copied &amp; printed.
     \&#x2F;_____&#x2F;  Commands | ::openweb:: ::banner:: ::quit:: ::switchmode::
    &quot;&quot;&quot;, &#39;yellow&#39;)
    print(banner)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要说明一下，上面的<code>colored</code>函数需要依赖一个第三方库<code>termcolor</code>，可以打印出彩色字符串。</p>
<p>我们在全局设置两个变量：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">MODE_ENCODE &#x3D; True # 用来记录模式是加密还是解密
LAST_RESULT &#x3D; &quot;&quot; # 用来记录上次操作的结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>getinput</code>是一个递归，可以像命令行一样获取用户输入，代码比较复杂，功能很多，本来是有注释的，结果浏览器编辑的时候不小心给关了，没有恢复成功。大家自己摸索吧：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def getinput():
    global MODE_ENCODE, LAST_RESULT
    info &#x3D; &quot;&quot;
    if MODE_ENCODE: info &#x3D; colored(&quot;ENCODE&quot;, &#39;red&#39;)
    else: info &#x3D; colored(&quot;DECODE&quot;, &#39;green&#39;)
    input_str &#x3D; input(f&#39;[&#123;info&#125;] &#39;)
   
    if   input_str &#x3D;&#x3D; &#39;::openweb::&#39;:    os.system(&#39;open https:&#x2F;&#x2F;www.52pojie.cn&#39;) # 打开吾爱网页
    elif input_str &#x3D;&#x3D; &#39;::banner::&#39;:     pbanner() #打印banner
    elif input_str &#x3D;&#x3D; &#39;::quit::&#39;:       sys.exit(0) #退出程序
    elif input_str &#x3D;&#x3D; &#39;::switchmode::&#39;: MODE_ENCODE &#x3D; False if MODE_ENCODE else True #切换加解密
    elif input_str &#x3D;&#x3D; &#39;::cp::&#39;:         os.system(f&#39;echo &#123;LAST_RESULT&#125; | pbcopy&#39;) #复制结果

    if input_str.startswith(&quot;::&quot;) and input_str.endswith(&quot;::&quot;): getinput() #检测是否为命令
   
    out &#x3D; str2zwstr(input_str) if MODE_ENCODE &#x3D;&#x3D; True else zwstr2str(input_str)
    print(colored(&#39;     &gt;&gt;&gt; &quot;&#39;, &#39;green&#39;)+ out + colored(&#39;&quot;&#39;, &#39;green&#39;))
    LAST_RESULT &#x3D; out
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>别忘了import进类库：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import os, sys
from termcolor import colored<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>大功告成！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首先，想说明一点，文中的结果复制功能是基于pbcopy命令的，这个只有Linux和Unix有，Windows没有。所以Windows小伙伴们记得使用<code>pyperclip</code>库实现复制功能。</p>
<p>其次，我也不是计算机专业人士，所以代码的繁琐与不妥当之处欢迎在评论区指正。</p>
<p>所有代码长这样：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import os, sys
from termcolor import colored

ZW_ONE &#x3D; u&quot;\u200b&quot;
ZW_ZERO &#x3D; u&quot;\u200c&quot;
ZW_SEP &#x3D; u&quot;\u200d&quot;

MODE_ENCODE &#x3D; True
LAST_RESULT &#x3D; &quot;&quot;

def pbanner():
    banner &#x3D; colored(f&quot;&quot;&quot;
      ______
     &#x2F;___  &#x2F;\\  Zerowidth String Encoder | @TLHorse from 52pojie
    &#x2F;&#x2F;  &#x2F; &#x2F; \\\\ Type in then ENTER. The encoded string will be printed.
    \\\\ &#x2F; &#x2F;__&#x2F;&#x2F; Commands | ::openweb:: ::banner:: ::quit:: ::switchmode::
     \&#x2F;_____&#x2F;  ::cp::
    &quot;&quot;&quot;, &#39;yellow&#39;)
    print(banner)

def apponlast(arr, sth):
    la &#x3D; len(arr)
    if la: arr[la-1] +&#x3D; sth
    else: arr.append(sth)

def str2zwstr(origin):
    bin_text &#x3D; []
    for char in origin:
        bin_text.append(str(bin(ord(char))).lstrip(&#39;0b&#39;))

    final_str &#x3D; &quot;&quot;
    for item in bin_text:
        for binchar in item:
            final_str +&#x3D; ZW_ONE if binchar &#x3D;&#x3D; &quot;1&quot; else ZW_ZERO
        final_str +&#x3D; ZW_SEP
    final_str.rstrip(ZW_SEP)
    return final_str

def zwstr2str(enc_str):
    arr_oz &#x3D; []
    for char in enc_str:
        if char &#x3D;&#x3D; ZW_ONE: apponlast(arr_oz, &quot;1&quot;)
        elif char &#x3D;&#x3D; ZW_ZERO: apponlast(arr_oz, &quot;0&quot;)
        elif char &#x3D;&#x3D; ZW_SEP: arr_oz.append(&quot;&quot;)
        else: print(&quot;Input contains non-ZW string. Aborted.&quot;); getinput()

    for idx in range(0, len(arr_oz)-1):
        arr_oz[idx] &#x3D; chr(int(arr_oz[idx], 2))

    return &quot;&quot;.join(arr_oz)

def getinput():
    global MODE_ENCODE, LAST_RESULT
    info &#x3D; &quot;&quot;
    if MODE_ENCODE: info &#x3D; colored(&quot;ENCODE&quot;, &#39;red&#39;)
    else: info &#x3D; colored(&quot;DECODE&quot;, &#39;green&#39;)
    input_str &#x3D; input(f&#39;[&#123;info&#125;] &#39;)
   
    if   input_str &#x3D;&#x3D; &#39;::openweb::&#39;:    os.system(&#39;open https:&#x2F;&#x2F;www.52pojie.cn&#39;)
    elif input_str &#x3D;&#x3D; &#39;::banner::&#39;:     pbanner()
    elif input_str &#x3D;&#x3D; &#39;::quit::&#39;:       sys.exit(0)
    elif input_str &#x3D;&#x3D; &#39;::switchmode::&#39;: MODE_ENCODE &#x3D; False if MODE_ENCODE else True
    elif input_str &#x3D;&#x3D; &#39;::cp::&#39;:         os.system(f&#39;echo &#123;LAST_RESULT&#125; | pbcopy&#39;)

    if input_str.startswith(&quot;::&quot;) and input_str.endswith(&quot;::&quot;): getinput()
   
    out &#x3D; str2zwstr(input_str) if MODE_ENCODE &#x3D;&#x3D; True else zwstr2str(input_str)
    print(colored(&#39;     &gt;&gt;&gt; &quot;&#39;, &#39;green&#39;)+ out + colored(&#39;&quot;&#39;, &#39;green&#39;))
    LAST_RESULT &#x3D; out
    getinput()

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pbanner()
    getinput()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a class="link"   href="https://share.weiyun.com/PyUOPC6F" >下载.py格式代码｜密码：zsetlh<i class="fas fa-external-link-alt"></i></a></p>
<p>最后我先说明，当我把论坛上的文章贴到博客里，我惊奇地发现论坛阅读量少得可怜。但我写文章终究不是给别人看的。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>其实我也很自信</title>
    <url>/posts/3ab4db58/</url>
    <content><![CDATA[<p>我从小就是一个薄脸皮、腼腆的人。参加演讲比赛，不知藏匿了双腿多少次颤抖；在户外活动，不知掩盖了多少拘束；就是上网课开摄像头，我也总要“犹抱课本半遮面”。然而今天的《木兰诗》表演却告诉我，其实我也很自信。</p>
<p>马老师让每个组改编《木兰诗》为一首歌，当我们得知要轮流上台表演时，我慌了。1组？没人。2组？没人。3组？没人……<strong>我的心濒临冰点。</strong>没想到，台下掌声雷动于8组，偏偏两位平常再平常的同学刘泽阳、刘世昊，端着稿子，没有背景音乐，在掌声的衬托下，昂首阔步，走上讲台，给大家带来一段说唱。<strong>幸好有两位哥们“身先士卒”，替我蹚一蹚水！我的背狠狠地靠在了椅子上。</strong></p>
<p>首先表演的是刘泽阳。他仿佛面戴京剧脸谱：羞怯的微笑，咧着嘴，两颊各凹陷一个酒窝；笔墨浓重的双眉，几乎连结一处。他身子微侧，头微低，想将激情挥洒给观众，又欲把胆怯藏匿于身后，有所挽留。节奏感超强的木兰歌词，出其不意从他嘴里噼里啪啦蹦出来，那张脸谱，也随之复活。<strong>我近乎笑出声来：一个五音不全的人都比他唱得好。</strong>他没理我，双眸依旧如同两只小手，紧紧抓着文稿，又时不时扫向观众。他上下唇似一个粉红的粗皮筋，伴着节奏，拉伸到极限，又收缩成一个梭形，时不时还闪出一丝腼腆的微笑，缓和一下心里的紧张情绪。</p>
<p>这段唱完了，那段就接着唱！同学们的目光立刻聚焦到刘世昊一人。毫无间隙地，他气冲斗牛蹿上了讲台。这回，更有勇气；这回，更加带劲！<strong>我在台下，听着断断续续的台词，却若有所思。</strong>但是，节奏如同钉子般，在我的心里早已打好了孔，<strong>我喜欢这音乐。</strong>伴随着高涨的热情，来自每个同学的拍子给他打了起来。然而他依旧目不转睛地盯着稿子，身体随着节奏晃过来、晃过去，晃过来、晃过去。<strong>好哇！</strong>台下的每个人被他视空，他彻底沉浸在自己的作品中！<strong>我仿佛也跟他一样热情高涨，我仿佛在他们的身上看到了我的影子！</strong></p>
<p>表演结束。当老师无奈地询问还有哪些组要上来表演时，我<strong>大胆</strong>地拉着我12组的成员举起了手！</p>
<p>其实，我也很自信！</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>从最简单的程序开始教你怎么破解（二）</title>
    <url>/posts/39501/</url>
    <content><![CDATA[<p>今天，我们还讲Hopper反编译，不过用的还是昨天的<code>CM</code>。我今天准备告诉大家，怎样替换程序里的字符串，这样就可以为所欲为了。</p>
<blockquote>
<p>目标：把程序修改成，只有使用自己规定的注册码，才能激活成功。  </p>
</blockquote>
<h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><p>首先，程序拖入 Hopper 解析。完成后，在左边的搜索视图中选择<code>Str</code>，查看程序里的字符串。因为程序比较小，所以字符串只有5个。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm2-search-str.png" alt="查看字符串"></p>
<p>这五个字符串，前面一个是激活码（怎么判断出来的上篇文章讲过），中间四个其实是中文的十六进制编码（对应的是“说明”“要求”和“输入错误”几个字符串），最后一个是定义用来处理换行的。既然要修改第一个，我们就点进去。</p>
<h1 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h1><p>修改字符串有两种方法。</p>
<h2 id="方法一：修改十六进制"><a href="#方法一：修改十六进制" class="headerlink" title="方法一：修改十六进制"></a>方法一：修改十六进制</h2><ol>
<li><p>把视图切换为<code>Hex Mode</code>，这个模式已经自动给你高亮了对应激活码的16进制码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm2-16bit.png" alt="16进制码"></p>
</li>
<li><p>例如，你要把激活码改成<code>111111-111111-111111</code>，那么，十六进制里，<code>1</code>对应<code>31</code>，而连字符<code>-</code>对应着<code>2D</code>，所以你就要把对应的十六进制改成：</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">31 31 31 31 31 31 2D 31 31 31 31 31 31 2D 31 31 31 31 31 31<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里我要说明一点，如果你的激活码比以前的激活码要短，那么你就尽管从头开始修改，最后剩下几位，你就在相应的位置上填写<code>00</code>即可。如果激活码比以前的长，那么会出现一个修改文件偏移量的问题，比较复杂，再次不阐述。</p>
<p>例如，你的激活码是：<code>helloworld!</code>，对应下来就是：<code>68 65 6c 6c 6f 77 6f 72 6c 64 21</code><br>2.  如果你嫌麻烦，可以在右边对应的字符串一个个修改成<code>1</code>和<code>-</code>， Hopper 会自动为你生成十六进制填在左边。<br>3.  <kbd>command</kbd>+<kbd>shift</kbd>+<kbd>E</kbd>，导出，完工！</p>
<h2 id="方法二：修改汇编代码"><a href="#方法二：修改汇编代码" class="headerlink" title="方法二：修改汇编代码"></a>方法二：修改汇编代码</h2><p>这个方法要比修改十六进制简单得多，我把它放在后面，是因为修改出来， Hopper 显示得有些让人迷糊，看不懂。我开始也用的这个方法，感觉错了，后来才知道这是最简单的方法。如果你用的是修改十六进制的方法，不妨撤回，然后用这个方法试试。</p>
<ol>
<li><p> 把视图切换回汇编代码，确保在激活码的地方。汇编代码应该长这样：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">                		a82mal929anyw9m:
0000000100000e80         db         &quot;82mal9-29anyw-9msfz6&quot;, 0                   ; DATA XREF&#x3D;_main+8
0000000100000e95         db         &quot;&quot;, 0
0000000100000e96         db         &quot;&quot;, 0
0000000100000e97         db         &quot;&quot;, 0
0000000100000e98         db         &quot;&quot;, 0                                       ; DATA XREF&#x3D;_$s10Crackme__16verifyyyF+118, _$s10Crackme__16verifyyyF+653
0000000100000e99         db         &quot;&quot;, 0
0000000100000e9a         db         &quot;&quot;, 0
0000000100000e9b         db         &quot;&quot;, 0
0000000100000e9c         db         &quot;&quot;, 0
0000000100000e9d         db         &quot;&quot;, 0
0000000100000e9e         db         &quot;&quot;, 0
0000000100000e9f         db         &quot;&quot;, 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>鼠标选中第一行。我的第一行是指：<br> <code>0000000100000e80         db         &amp;quot;82mal9-29anyw-9msfz6&amp;quot;, 0                   ; DATA XREF=_main+8</code><br> 如果你不是这一行，会发生不好的结果。</p>
</li>
<li><p> <kbd>option</kbd>+<kbd>A</kbd>修改，输入指令：<code>db “你想要的激活码”, 0</code></p>
</li>
<li><p> 之后，你的那行代码就会改成这样：</p>
<pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">0000000100000e80         db         6 dup (0x31), 0x2d, 0x31                    ; DATA XREF&#x3D;_main+8
0000000100000e88         db         5 dup (0x31), 0x2d, 2 dup (0x31)
0000000100000e90         db         4 dup (0x31), 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>很奇怪吧！这就是一个坑：这段代码看起来怪怪的。为什么呢？<br>我提醒一下大家：</p>
</li>
<li><p> <code>db</code>命令是定义字节，基本上常量和变量的定义都会出现，不必纠结。</p>
</li>
<li><p> <code>dup</code>是复制的意思，对应英文单词<code>duplicate</code>。那么<code>6 dup (...)</code>是什么意思，就可想而知了。</p>
</li>
<li><p> <code>0x31</code>和<code>0x2d</code>都是刚才说过的十六进制。<br>现在你就会明白，这段代码是没有问题的。</p>
</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>提醒大家注意几点：</p>
<ul>
<li>  十六进制码<strong>不区分大小写</strong>；</li>
<li>  汉字也可以转化为十六进制。如果你在程序中看到类似<code>x98\xH7\x2B\x..\x..</code>这样的东西，是中文的十六进制编码，不是乱码。你可以到<a class="link"   href="http://tools.jb51.net/tools/base64_decode-gb2312.php" >相关解码网站<i class="fas fa-external-link-alt"></i></a>解码成中文。</li>
<li>  如果你需要十六进制的加解密，可以试试<a class="link"   href="http://www.bejson.com/convert/ox2str/" >BeJson<i class="fas fa-external-link-alt"></i></a>等工具。</li>
<li>  在HDA里输入命令时，用不着纠结汇编指令与参数之间的空格，空一个格就好， Hopper 会自动给你补充的。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>再战CleanMyMac X完美暴破</title>
    <url>/posts/a5950fc/</url>
    <content><![CDATA[<blockquote>
<p><strong>因为<code>CleanMyMac X</code>的破解屡次被代理商投诉，并且有被黑心网站挖掘文章的可能，故不能发布成品。文章这么长，其实是就是几个<code>frida-trace</code>和<code>Hopper</code>，更多的是分析，再说论坛上的同志都不是白给的，肯定搞得定。</strong></p>
</blockquote>
<p>自从写了<a href="https://tlhorse.github.io/posts/16190/">《一次意外的 CleanMyMac X 破解》</a>后，在手的CleanMyMac X 4.5.3就一直没更新换代。笔者撰写此文，CleanMyMac X 已经发展到4.7.4了，于是便想着重新破解一遍。如果还未读过上篇文章的，建议读一遍。</p>
<h1 id="Hopper分析"><a href="#Hopper分析" class="headerlink" title="Hopper分析"></a>Hopper分析</h1><p>按照上一篇文章的思路，我们先找<code> -[CMActivationManager isAppActivated]</code>这个函数。竟然还在：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/cmmnew-search-sym.png" alt="cmmnew-search-sym"></p>
<p>但是，为了避免像我破解4.6.7时频繁输密码的问题，安装<code>frida</code>，我们使用<code>frida-trace</code>进行调试修改：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">frida-trace -m &quot;-[* isAppActivated]&quot; &quot;CleanMyMac X&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令我需要解释一下。<code>-m</code>是trace（跟踪）<code>OBJC_METHOD</code>的参数，后面第一个字符串参数是一个搜索关键词，其中*是通配符，不论是哪个class的<code>isAppActivated</code>都会被我们监视到。后面的<code>&quot;CleanMyMac X&quot;</code>是进程名称。</p>
<p>但是可惜的是在激活命令之前，我们需要把CMM打开，这样<code>frida</code>才能attach到进程。也就是说，CMM和命令几乎要同时打开。我在调试的过程中一直是把app和回车同时按下去，很麻烦，知道写文章才发觉自己好可爱，为什么不用下面的命令呢：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">open &#x2F;Applications&#x2F;CleanMyMac\ X.app &amp;&amp; frida-trace -m &quot;-[* isAppActivated]&quot; &quot;CleanMyMac X&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>之后我们会看到下面的输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Instrumenting...                                                        
-[CMActivationManager isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMActivationManager&#x2F;isAppActivated.js&quot;
-[CMSubscriptionStatusManager isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMSubscriptionStatusManager&#x2F;isAppActivated.js&quot;
-[CMSubscriptionRequestSchedule isAppActivated]: Auto-generated handler at &quot;&#x2F;Users&#x2F;alex080318&#x2F;Developer.localized&#x2F;CMMTweak&#x2F;__handlers__&#x2F;CMSubscriptionRequestSchedule&#x2F;isAppActivated.js&quot;
Started tracing 3 functions. Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到有三个函数被调用，也就是说这是三个函数都得被hook，终于不用像以前傻呵呵只改一个函数了。</p>
<h1 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h1><p>为了省时间，在这里就不用Hopper了。我们在<code>frida</code>生成的<code>__handlers__</code>文件夹（位于当前目录，也就是在trace之前要<code>cd</code>到一个准备好的目录）中，分别将三个函数的<code>onLeave</code>改成1：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">onLeave</span><span class="token punctuation">(</span><span class="token parameter">log<span class="token punctuation">,</span> retval<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  retval<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后再运行<code>frida-trace</code>，打开软件，提示信息消失。正当欣喜若狂开始清理垃圾时，突然停止清理，提示我买会员。噩耗传来：<strong>这是伪破解。不过别泄气啊。</strong></p>
<p>仔细观察软件会发现，有的地方是未注册的UI，有的地方是已注册的UI，也就是暴破函数没找全。我们查看一下<code>-[CMActivationManager isAppActivated]</code>伪代码，发现，里面的<code>sub_100334850</code>在做着不为人知的事情：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;* @class CMActivationManager *&#x2F;
-(char)isAppActivated &#123;
    rax &#x3D; sub_100334850(0x0);
    return rax;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sub_100334850</code>：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">int sub_100334850(int arg0) &#123;
    var_2E8 &#x3D; arg0;
    rax &#x3D; objc_autoreleasePoolPush();
    var_300 &#x3D; 0x0;
    var_2A0 &#x3D; &amp;var_300;
    var_318 &#x3D; rax;
    if (**_NSApp !&#x3D; 0x0) &#123;
            var_320 &#x3D; qword_1007a3b28(**_NSApp, 0x1007a3b70);
            var_328 &#x3D; var_320;
    &#125;
    else &#123;
            var_328 &#x3D; 0x0;
    &#125;
    var_2A8 &#x3D; var_328;
    sub_100392510(&quot;DM_ENABLE_DEBUG_LOGGING_ACTIVATION&quot;, @&quot;_get_: %p&quot;, var_2A8, 0x0, r8, r9, stack[-1704]);
    if ((var_2A8 &#x3D;&#x3D; 0x0) || (var_2A0 &#x3D;&#x3D; 0x0)) goto loc_1003349b4;
  &#x2F;&#x2F; ......
  &#x2F;&#x2F; Plethora ommitted...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码很长，就不全部展示了。<kbd>Shift</kbd><kbd>X</kbd>查看交叉引用，让我们“顺瓜摸藤”，结果让我眼前大吃一惊，好多啊……</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-subx.png" alt="搜索交叉引用"></p>
<p>原来，这个sub是个判断激活的进程<strong>，不止<code>isAppActivated</code>调用了它，还有许许多多的类和方法，包括<code>EntryPoint</code>。</strong></p>
<p>想要hook这个sub，还需获取在内存中的地址，着实麻烦，就不写<code>frida</code>了。<strong>Hopper直接改返回值。</strong>双击空格，切到ASM模式，让我们：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><kbd>Cmd</kbd><kbd>Shift</kbd><kbd>E</kbd>，生成可执行文件，给源文件改名，替换——三步走，之后打开<code>CleanMyMac X</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-ked-1.png" alt="1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/08/cmmnew-ked-2.png" alt="2"></p>
<p>祝大家新年快乐，牛年大吉，破解技术共获提升，软件使用快乐！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>制作一个 Deepin Linux 启动盘</title>
    <url>/posts/ed6c4c67/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux 乃是操作系统之王，其可玩性、扩展性、操作性和美化性远远超过了 Windows、OS X（Darwin）等传统操作系统。Deepin Linux 是 Linux 发行版中较好的一个。我们来比较一下 Linux 的安装方式：</p>
<ol>
<li>安装到双系统：将 Linux 与 Windows 或 OS X 并行安装，形成双系统，不过容易毁坏电脑或系统引导；</li>
<li>安装到虚拟机：这倒是没问题，但是你总不能走哪都带个虚拟机运行软件吧？；</li>
<li>安装到可启动 U 盘：说白了就是让电脑使用 U 盘里的操作系统进行启动。</li>
</ol>
<p>第三种很酷？这次教大家用第三种方式安装（思想不限于 Deepin Linux）。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 电脑一个；</li>
<li><input checked="" disabled="" type="checkbox"> 存储介质一个（硬盘、U 盘等，空间 ≥ 16GB）；</li>
<li><input checked="" disabled="" type="checkbox"> Parallels Desktop 15；</li>
<li><input checked="" disabled="" type="checkbox"> Deepin Linux <a href="https://www.deepin.org/download/"><code>.iso</code>镜像</a>。</li>
</ul>
<h1 id="新建用于安装的操作系统"><a href="#新建用于安装的操作系统" class="headerlink" title="新建用于安装的操作系统"></a>新建用于安装的操作系统</h1><p>选择 Deepin Linux <a href="https://www.deepin.org/download/"><code>.iso</code>镜像</a>，新建一个 Parallels Desktop 虚拟机：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-choose-iso.png" alt="选择iso"></p>
<p>当虚拟机被加载出来后，直接停止虚拟机：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-quit.png" alt="停止虚拟机" style="zoom:50%;" />



<p>插上你的存储介质，使用虚拟机右上角的⚙️按钮进入设置，作出如下配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-seq.png" alt="配置启动顺序"></p>
<blockquote>
<p>注：“外部引导设备”里，要选择你的存储介质，比如我的 USB 3.0。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-ram.png" alt="配置内存"></p>
<h1 id="启动虚拟机安装"><a href="#启动虚拟机安装" class="headerlink" title="启动虚拟机安装"></a>启动虚拟机安装</h1><p>存储介质保持插入状态。启动虚拟机后，会出现命令行界面的 BIOS。按下图操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-inst-bios.png" alt="进入bios"></p>
<p><strong>为什么要在 BIOS 里“绕一圈”呢？其实这个动作相当于在拖延 Deepin 安装程序的启动，让存储介质在 BIOS 里提前被识别，这样才能让 Deepin 安装程序启动后找到识别我们的安装介质。</strong>最后一步按下3后，即可进入安装程序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-inst-start.png" alt="安装程序启动菜单"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-sel-disk.png" alt="选择安装存储介质"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-installing.png" alt="安装过程"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-install-success.png" alt="安装成功"></p>
<p>安装成功后，直接强制停止虚拟机：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-quit.png" alt="停止虚拟机" style="zoom:50%;" />

<p>到此，安装成功。安装成功后，存储介质不会被电脑识别，因为 OS X 不能读取<code>ext4</code>分区。</p>
<h1 id="安装介质的启动"><a href="#安装介质的启动" class="headerlink" title="安装介质的启动"></a>安装介质的启动</h1><p>安装成功的存储介质，可以通过 Windows 电脑中的 BIOS 进行 Legacy Boot。问题是 OS X 系统（更适合说成 Mac 电脑上）并不支持 Legacy Boot，只支持 EFI 启动。也就是说无法直接使用硬盘启动（即使在启动时按下<kbd>option</kbd>键也不行）。怎么办？这回 Parallels Desktop又派上了用场。</p>
<ol>
<li>新建（虚拟机）；</li>
<li>从 DVD 或镜像文件；</li>
<li>继续；</li>
<li>手动选择；</li>
<li>没有指定源也继续（相当于创建空白虚拟机）；</li>
<li>选择操作系统 -&gt; 更多 Linux -&gt; 其它 Linux；</li>
<li>虚拟机名称：U Machine（随便起名）。</li>
</ol>
<p>创建完成后，直接停止虚拟机，在设置里作出如下配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-conf-ram.png" alt="配置内存"></p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/5/20/deepin-um-conf-seq.png" alt="配置启动顺序"></p>
<p>现在启动一下虚拟机（你的存储介质应该是插着的），虚拟机会自动检测出你的存储介质，并从中启动。这样不论是在什么电脑上，都可以从你的存储介质中启动系统了！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>系统底层</tag>
      </tags>
  </entry>
  <entry>
    <title>吃瓜</title>
    <url>/posts/46251/</url>
    <content><![CDATA[<p>为了欢送我们班将要出国定居的张同学，在这学期暑假，同学们和家长举办了盛大的欢送宴会。吃饭过程中，伙伴们进行了有趣吃西瓜比赛。</p>
<p>那天，我们热闹非凡地围坐在餐桌旁，个个手持着一块西瓜，表情激动，只等班里的“小吃货”张琛平一声令下开始比赛吃西瓜。随着一声“开始……”，同学们齐刷刷地低下头，大口大口疯狂地吃起西瓜来了。</p>
<p>发号施令的张同学（另一位姓张的同学），“始”字还没说完，就立即深吸一大口气，迫不及待地冲着那片西瓜的顶端咬去，几乎把整块三角形西瓜都吞进嘴里。没料到在他吞咽的那一瞬间，被削成尖的西瓜“顶角”，正好抵住了他的喉咙……这下可好了，想吐出那块西瓜不容易，而西瓜的“底边”也牢牢地撑住了他的狮子大嘴，动弹不得。只见琛平一脸囧样，“呜呜”地不停，眼中汪着泪水……“小吃货”费了九牛二虎之力，才把嘴里的西瓜含化了，导出一口气。</p>
<p>旁边的任同学不甘示弱，起劲地嚼着西瓜，腮帮鼓鼓的。左右开弓，朝着手里的一角西瓜的不同方向啃去。一口就咬下去三分之一，西瓜汁从嘴中间不停喷射出来，犹如一束喷泉⛲，溅落到洁白的桌布上。接着，第二口，他淡定了许多，并不着急咬，而是先使劲把嘴巴张到不能再张的地步，然后像榨汁机关闭填料口一般，快速地闭上嘴巴，以防果汁喷发，使劲咀嚼……结果西瓜汁还是源源不断地从嘴角渗了出来，滚落到下巴，形成道道亮丽的红色——而任同学也不顾了那么多，继续努力地啃着西瓜。西瓜汁都流到他脖子里了，才意识到自己吃西瓜太不像样了，便用衣服抹了抹钻进脖子里的瓜汁，继续消灭剩下的西瓜。大家一边带劲地吃着西瓜，一边欣赏着其他同学滑稽的吃相。吃声、笑声一片……</p>
<p>在作业多如牛毛的暑假，同学们能够欢聚一堂，还能有老师的陪伴……太开心了，以至于忘记了张同学的离开带我们的忧伤。而席间吃西瓜的游戏，让大家体验了少有的快乐。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态库注入优雅破解 CrossOver</title>
    <url>/posts/22833/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次我写过一篇叫做<a class="link"   href="https://www.52pojie.cn/thread-1126808-1-1.html" >Hopper 之 CrossOver 19 破解<i class="fas fa-external-link-alt"></i></a>的文章，那么今天，我再写一篇 CrossOver 19 的破文。上一篇文章里，我用了“直接修改二进制文件”的方法来破解应用，而这次，我则通过动态库注入的方法来破解 CrossOver 19——这是一个巧妙、新奇的方法，说白了就是 hook，你会喜欢上它的。我还要感谢<a class="link"   href="https://www.52pojie.cn/home.php?mod=space&uid=476930" >@云在天<i class="fas fa-external-link-alt"></i></a>大神在我的<a class="link"   href="https://www.52pojie.cn/thread-1132170-1-1.html" >CleanMyMac X 破解贴<i class="fas fa-external-link-alt"></i></a>里的指导，要不是她，可能我到现在还不知道什么是动态库注入。</p>
<p>前言的最后，我再说一下来意。我只是想教大家“破解方法”，而不是给大家“破解软件”。就拿例子说吧，我现在用的 Hopper Disassembler 可是正版的。因此，如果你喜欢 CrossOver 19，请购买正版。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>从<a class="link"   href="https://www.crossoverchina.com/" >CrossOver 官网<i class="fas fa-external-link-alt"></i></a>上下载最新版的 CrossOver 19 。</li>
<li><a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler v4<i class="fas fa-external-link-alt"></i></a> 一枚。</li>
<li>与上篇文章不同的是，我们需要 Xcode（我的版本是11）。 </li>
</ul>
<h1 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h1><h2 id="分析-UI"><a href="#分析-UI" class="headerlink" title="分析 UI"></a>分析 UI</h2><p>首先打开<code>CrossOver</code>，简单的看了一下，分析出几个信息：</p>
<ul>
<li><p>打开软件后弹出了一个要钱弹窗，弹窗里提示了试用剩余天数，并提示你购买软件或者进行使用；</p>
</li>
<li><p>要钱弹窗中有两个需要关注的按钮，一个是 <code>现在试用</code>，另一个是 <code>使用购买信息解锁</code> ;</p>
</li>
<li><p>按下 <code>现在试用</code> 按钮，可以直接跳转到App里，开始14天试用；</p>
</li>
<li><p>开始试用App后，在<code>CrossOver</code>里仍然可以进行App激活操作。</p>
</li>
<li><p>CrossOver 没有附加反调试工具。</p>
<p>于是，我们就有如下的破解思路：</p>
</li>
</ul>
<ol>
<li>Patch 剩余天数；</li>
<li>Patch 使用购买信息解锁的验证流程。</li>
</ol>
<p>本文中只讲述第一种方法。</p>
<h2 id="使用-Hopper-分析"><a href="#使用-Hopper-分析" class="headerlink" title="使用 Hopper 分析"></a>使用 Hopper 分析</h2><p>拖进 Hopper，先分析一波，看看有什么函数。本来想搜索UI中的字符串，字符串搜索无果后，根据“剩余天数”的英文“left”，搜索关键词：</p>
<p><img src="https://i.loli.net/2020/03/27/DhqpY65tncdk3fO.png" alt="搜索left"></p>
<p>我们发现，第一个函数<code>-[CXApplication daysLeft]</code>，于是打开伪代码发现，这个函数返回的是一个<code>int</code>，极有可能是剩余的天数。我们可以尝试 Patch 这里，使得该函数永远返回十六进制<code>0x8ef8</code>（等同于 36600 天）。</p>
<p>按照上一篇文章的破解方法，我们只需要：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rax, 0x8ef8
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后试用天数就永远是 36600 天了。但是别忘了，我们今天是要讲如何使用动态库注入来 hook 函数的，接下来，咱们就开始 hook。</p>
<h1 id="构建动态库"><a href="#构建动态库" class="headerlink" title="构建动态库"></a>构建动态库</h1><h2 id="动态库注入原理"><a href="#动态库注入原理" class="headerlink" title="动态库注入原理"></a>动态库注入原理</h2><p>在<code>macOS</code>下的应用程序，绝大多数都会用<code>Objective-C</code>或<code>Swift</code>进行编译（<code>Python</code>这类的先不谈）。</p>
<p>如果程序使用了<code>Objective-C</code>编译，我们可以仗着<code>Objective-C</code>的动态消息传送机制与<code>runtime</code>，在程序运行时进行函数的调换。</p>
<p>然而我们 crakers 都面对的是已经编译好的程序，所以我们要把函数调换的过程写到一个动态库中，然后再用动态库注入工具（<code>insert_dylib</code>之类的）注入到原来的二进制文件中。</p>
<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>首先，<a class="link"   href="xcode://" >打开 Xcode<i class="fas fa-external-link-alt"></i></a>（按一下这里你会神奇地发现 Xcode 打开了），新建项目，选择<code>macOS</code> &gt; <code>Library</code>，新建动态库项目，如图：</p>
<p><img src="https://i.loli.net/2020/03/30/bsBnRwa75o4zJu8.png" alt="选择类型"></p>
<p>动态库的名称可以随便起，此处叫做<code>CrossOverPatch</code>，<code>Framework</code>选择<code>Cocoa</code>，<code>Type</code>选择<code>Dyamic</code>（动态）。随便找个地方保存项目即可。</p>
<p>现在你会得到一个动态库项目。</p>
<h2 id="编写动态库"><a href="#编写动态库" class="headerlink" title="编写动态库"></a>编写动态库</h2><p>首先打开工程文件里的<code>CrossOverPatch.m</code>文件，输入：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#import &quot;CrossOverPatch.h&quot;
#import &lt;objc&#x2F;runtime.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们用两个<code>#import</code>语句，将<code>CrossOverPatch.h</code>文件与<code>objc/runtime.h</code>库引入。<code>CrossOverPatch.h</code>文件（头文件），是每个<code>.m</code>文件里必须引用的。而<code>objc/runtime.h</code>库就是大名鼎鼎的运行时类库。</p>
<p>之后我们在下面声明一个实现<code>@implementation</code></p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">@implementation CrossOverPatch

@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们在实现里定义一个 hook 方法：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">- (int)daysLeftHook &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 36600;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>我们在下面的步骤中要用这个方法来替换原函数<code>daysLeft</code>，实现 hook。</strong>这里需要注意一点，我们定义的这个函数的返回值（<code>int</code>）和参数列表（无）<strong>需要与原函数相同</strong>。<code>NSLog</code>则是打印语句，方便我们后期检测程序。最后的<code>return</code>语句，让函数返回了36600这个值。你当然也可以把36600写作0x8ef8。</p>
<p>我们在实现里添加一个<code>+ (void) load</code>方法，如下：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">+ (void)load &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;CXApplication&quot;), NSSelectorFromString(@&quot;daysLeft&quot;));
    Method newMethod &#x3D; class_getInstanceMethod([CrossOverPatch class], @selector(orphansArray:));
    method_exchangeImplementations(origMethod, newMethod);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们一行一行地讲解代码：</p>
<ol>
<li>函数<code>load</code>定义。<code>load</code>函数会在动态库<strong>被加载时</strong>触发；</li>
<li>打印日志；</li>
<li>同上；</li>
<li>定义变量<code>origMethod</code>，它的类型是<code>Method</code>，它的值是<strong>原程序的</strong><code>daysLeft</code>方法。<ol>
<li><code>class_getInstanceMethod::</code>函数可以获取一个类（第一个参数）的一个实例方法（第二个参数）；</li>
<li><code>NSSelectorFromString:</code>可以通过一个字符串（第一个参数）来获取一个类；</li>
<li><code>NSSelectorFromString</code>可以通过一个字符串（第一个参数）获取一个<code>Selector</code>；</li>
</ol>
</li>
<li>定义变量<code>newMethod</code>，类型是<code>Method</code>，它的值是<strong>我们刚才自定义的<code>daysLeftHook</code>方法</strong>，我们要用这个方法来替换第4行的<code>daysLeft</code>方法。</li>
<li>将第四行和第五行定义的新、旧两个函数通过<code>method_exchangeImplementations::</code>交换。这样的话，原程序的<code>daysLeft</code>就成了我们自定义的<code>daysLeftHook</code>，而我们自定义的<code>daysLeftHook</code>就成了原程序的<code>daysLeft</code>，也就意味着成功 hook 了。</li>
<li>打印日志。</li>
</ol>
<p><code>CrossOverPatch.m</code>写完了。别忘了打开<code>CrossOverPatch.h</code>文件，声明函数：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">@interface CrossOverPatch : NSObject
+(void)load;
@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>按下<code>Cmd</code> + <code>B</code>编译一下，最终得到动态库文件：<code>libCrossOverPatch.dylib</code>！</p>
<h1 id="注入动态库"><a href="#注入动态库" class="headerlink" title="注入动态库"></a>注入动态库</h1><p>离破解只差一步——注入。方法有许多：运行<code>bash</code>脚本、修改<code>info.plist</code>……不过我更倾向于使用<code>insert_dylib</code>工具注入。点击<a class="link"   href="xcode://clone?repo=https%3A%2F%2Fgithub.com%2FTyilo%2Finsert_dylib" >这个链接<i class="fas fa-external-link-alt"></i></a>即可将<code>insert_dylib</code>项目克隆到<code>Xcode</code>，编译得到<code>insert_dylib</code>可执行文件。</p>
<ol>
<li>把<code>insert_dylib</code>、<code>CrossOverPatch.dylib</code>和 CrossOver 19 应用程序的<strong>原来的二进制文件</strong>的<strong>绝对</strong>路径记录下来。</li>
<li>打开终端，输入命令： <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cd [insert_dylib的路径]
$ .&#x2F;insert_dylib [dylib的路径] [原来的二进制文件的路径]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
回车后，如果出现<code>LC_CODE_SIGNATURE load command found. Remove it? [y/n]</code>，那么就按下<code>y</code>，回车。</li>
</ol>
<p>如果出现<code>Added LC_LOAD_DYLIB to /Applications/CrossOver.app/Contents/MacOS/CrossOver_patched</code>，代表注入成功。</p>
<p>打开访达，进入<code>/Applications/CrossOver.app/Contents/MacOS/</code>位置，你还会发现有两个文件：<code>CrossOver</code>和<code>CrossOver_patched</code>。其中<code>CrossOver_patched</code>就是<strong>已经被我们注入的</strong>文件。将原来的<code>CrossOver</code>二进制删除或更改名称，将<code>CrossOver_patched</code>更名为<code>CrossOver</code>。</p>
<h1 id="改头换面"><a href="#改头换面" class="headerlink" title="改头换面"></a>改头换面</h1><p>通过下图找到电子权利信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-creditspath.png" alt="电子权利信息路径"></p>
<p>找到后，用文本编辑打开，在文件开头加上一句类似下面的话：</p>
<blockquote>
<p>这个版本的CrossOver已经由xxx破解。你可以放心使用。注意，请勿广泛传播……</p>
</blockquote>
<h1 id="验证破解"><a href="#验证破解" class="headerlink" title="验证破解"></a>验证破解</h1><p>双击<code>CrossOver</code>二进制文件，即可打开应用程序。可以看见试用天数已经破解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-36600.png" alt="剩余天数破解成功"></p>
<p>电子权利信息也被修改：</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-credits.png" alt="留下足迹" style="zoom:50%;" />

<p>与此同时，你的电脑应该会弹出终端窗口：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>唯心论</title>
    <url>/posts/912a529f/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c4f48c00bc405498690bffee19afdf9fabf0457ee0ef4c4f7ed3324d93644fc1">fb9485e9b3db22a0b31c2c272a92e2cc5035ff1dd42ac50a34f7117da1026898319829e11ac26fd2dcf632e6a2e9ac3032e33979b46672674512a802bfbd469ad1cce58166647f2738e96a41b375f539a0b4af250d035b4d29162c85f294d2ab68f6e51e065756aba0cee8b13800b459ec5b17b3deacc5d687f881ebc273ad9c17d9e50becdd5591f0ffeee4994b88fce20744c3bd1c57f9100b23d128cbac19fe18b98f824706dea61aa04621940e51df2d2aeffc2650309c16ca7a9689c72077c9f59d1fbfb8d52c19e2df5ea8271ff3dc8b59cc6803556d07c38128e9f9067d59cc951f23d9cec60a78096cd7b0385ad893e21ff5b5b083458c087bef5eb8aa72a003835011f597f3f000ef5e69f6f216fb24dadba562de46808fb3e353eca482c13a106c4cd830764943e1a976841a250b914926b996a77d9af0e717598b1cfb12f18efc36942de1f6f6164dbb0fe606060d1c6f6a6a3bd0114bfe9eb7e40bbb2111c5a56af57ff9e70814c8e23d478f2da037651085d9315838d2a1bf75782143b50283631f398d45c5995eeb23f5f4dd25c83ec8cffec64b30fbfde0b50bceb4c3f856f6dbcdb0e03cf0d316df11ce96ed0d51cef13a7db5f077f93ea26d693db6e46a6bd3f24cb118dad32ed5d21a4bd5cd95e2c0b501afef0802b241f19db00a05298f20163c5cf113e260a6f460210b7bd5288ce271e7ba432bf0aa57fd769a0843dfb68e2d4bbd37d6c5036f8ca13320c85c3625834f2b227c130aa6623c2777401c50efb3aa2ea7fd785a728c11fc34524ee9c0b48b925a921b144db0fac8b5e8ec4dda9fab20e290732d6b70efe959775d684c0e3f32acf6f18f71fe22e606a426a8069767a2b01a47c3a4e84b7940a2b334a3488685b9edde0e546bc5f7088a2e37591a82aaa0da56883b1c275f1792d8df0f5cf9b39dd4b0b387a6dfe44675e5209f1d04121782093f4fc8a0a5808d1d443bf813980021aa6ccce3ef743930fdeba1fc210f058e9204b9fbeb8aaf2c04ba8610b7dc4d17f415e8a333b7d4603e204d329d5bc0f04b78679f228aa5811f7242899dda6f2e8dc0e7ffb0e2de3becc9a0cd5c38eeafef68aa0a6e60b28b99c2263951b16535d1e377b4beefb531b2d4491d1c294d0cc922f13c3f0368c418e56477a13e505c66cef3f2a7cb08a3669c67d864debdd07ab7d19753e3376d18189c85c3d8d08294eb913890cafe93bc254680e5bd3cbf3e2ab9912fb02dcdd1cac4683585af3c4498b39433ba4258419a2d690658b19ed6e8b6445f4ca87c349db1df5b8cd9e0051aa167e1c4fbc127aad37e8cbc324f154d6c49d736dbf06cd74f357d9219000e7fddf6a972d2ea85716d466b25fb90f7ba8a8022d93cb9dba68567817fd1097e5dd3a62ffe62b475271d9c2736409ae9d0d008b2fa280387b3198b28c6f6537d6e86cee60b8fc11b10a5c0e0feac8cdbbfdb063b84435ba8bfb497382a1c9e263a37922dc8f82cedb125a32d317a01860cb215a6b202b6e1a6b6cdcf953a75f0da4f017fe64f378f208f83fde9be737b80d3d28f36e887aa5fc067e32545bbd2c530a713fb89d44ca595d67d1aaf6ec879dfa5b0422a3201424708ee0fd410fb5b15861357493f634605392013ae2b11af5746a67e0e57149ee58d4ae05ab96e3f4a0861bdc67414211a2471bf565ba6b57a2974899d6e658b92da9e18112643b71756fb8cb65ac8b22ece2069b909e61d27682218ea4aa467ff87e34d947847080f5d46b2cd333ea5532fdd06625aba9589bc742d052df50aa8dc51ef91e8071ad983f9b10c707fe6ac1d5d773ce24a554c74c1384ec1f1b6fd65e8870adb69dde8d0c26cca6de5eec568d9c7973b4aab3b9a813a2890f3987e37c464428dc80c7c13d69debcaa7faec6000758f3a3a79b2464c9d3355a19c1930d9a9e60cdbec20f19c5eaddccd23a6475daef286218e5a30648434d87bf0de8169dd5ec390b5cbb2703ab56c6cedd950f4d1a58d9e810e02cfbf03a39b5042b7f23875d0264ba4da5dc8ed3988628a09145b95574fa797c7ce2930046cc426cc8d0933d5ee87c945eee132fcf1eaf9d236fc91a47cab5d20671a6eb22546c81a1a848584e9d4d151647f53f53fc78662be84d1b405f5421285a6f84ccefb29ebec3f8c3f9c5fb334efb9a0db3ef2b9ff3153b44ecb78e9d88c1f597e10fbb49b2b272246aa989bfcbed59be937b9150bc95d02aeb3b1f0be1e42b3419d5551c4da6d2f62747af6c8aceb31d46fe7c3e62ad55045efdc9998fef8b5b0d1d4202d113e5d60e2b869102ada2d8b7b8a0057a4a2e5cdad6eb4417495112e4f71269e0b2d1e8800c1cf6d5c0d0d3b7ffc60d68fb78dd7139c6bda90c0b86427fcd8027b41ec6e6d5599956c7c8f1ca65cd80ae273f509c5cda40a92d6ff8e8bb3322450aee055edd1047098ec6e3040c445cdff374fbf0a0e2cbd816a700b7745212950806f015cbc8eab24b6073ec03ec3f7b9c83729bd2a04a540ca3ccddb63fd283905aadd6d40e790b4886c822c0ffe14dc52f4909a99cfc831c876024926a5ac5cc75174ad6c490d503f37df52ab8ffff7eeaec6ad8b352f8af6d2b40b8217a868ad8ee41c9b68fcab49a48e129195a3ca20b118b7445e3615d1ef5943d792bdb829b590318327a8ac75250960de13aa8f9104dae813c67968ed5c611575d5e209871327f525cb49744deb1a6e7532a6dcffa80ec918c01074eec2bf1cd3eaf4eab4c90ba8e2357dbb4b1786905aca91a6437d6a63957ba2ebaa25b3bfddb5bd9113193081886cbcf7bfcb035b6315c8a10dda992e51f8be010d1b2b34d7b35027c0e2662d7083eb4c9c2c12017626f97e231adab9a4b66a4a8e4cac9ec75d827ffa5fa75c36f97149183cafea115bd39a1ca73601511d7a4bd3723012144516efc129416cd03a8f47d7420f8af6346fed19243b9a4a331f3eb2eadae7aca935cf732b0aaacb5e11b0a586f2920876edf5e63a50dfb7826b06e41cd06f4109817a030bf50b90492321e28560e3f44aa5855d61be1010069f22be2890e3cb44bd57b4ae45b75f99572ad24045b824f592edf5ea4bfe1cf140beab68f12d3b43802ac6af931b38c67f3d90ef8b2706ba188bfd3a398bfe129eb12a589ed447d30856ed01b36b4cb62693d03479f5dde286fb6254e1fbe5468a9e46f1e3a50f5232e8c99857f2eac455831dce62222e7729475445f81029a28c65d65d6184f953b41b702e5ece34bb9c7526e4cf9a711da2a2a109d6d27520f7a50c78aa1ddcdbf0c47a8db707e069b398412e1fa2dc3ba9b62a9267b11e8665b317440215caa12e6a9762b8d1b08c57963fbc1e2378cac63589653177be09047f70840d39a8e6911f5fb51308df3100c39d694cfcaf4527c1442b49bd42bc9bda51af0e38cee82946314daa9233e4f473be85eb56c5beb2c5ff96884e1b4c88a3023b681a1370e05523b5c6b9724080ac94af4b22a9df597985858b4e3affb7ddec748913614d89191c1fc5480af54ad2f986b03e545d9a8646eeccf126e167021856397f26f4690db73c1fb74cd26abeebf8b02090db33478361c92edab59e4d506eaee649f32ff313f8531f5c0198a82e74fc8550f1a441e854492e4df2c92d7e7a046160e49581ce301bf3c1679e51a83d81c6eafb269e07bc3db965aa024bc0b662b32970cc1d40be0320fc3cb86bfd9e6722dbd9cd509d4c4e8532a4ca77b806b0b92683c295f9db09ec4dafd3e4cd43d86bdd7c6844a83ed24a92814b2fbfa4a30dfd41a90cb1709b6d8cef92fa92e50bf4a455a7cbb4fbc77b01658e8f9e82527182fd8823cdeb2c74bbaf7865b57aaf96071e454486bcb261f08f0817384d68950da1f27f021fdc89c388d22b6a2ba4421cd4993f4a3a38f095fd1be05a75eabe90848d373cc1d1589323d62faf33cb6e744dded478a0ea41e294907d270830c866f518bd6aee08a09338bc0da0bfd5f98bd4d71a5c1f66dfd1737db4ad38d9a0dc2c57d0ce0d940cb590a4ea9cdf223a311a1ba4def3ed7cdb8704bcaaeb62696d2fb1c8713c7a609bed2a71bee442c971670652328379b888a0163df2f57a1e547af6f30ddc2a4813e9081effe5a71ed94e40e2c767cea094316280452b332a73cf36b7e4b997ca2000d096ff40df4acb3a79b4a62f1f6979261964b66f286b9a5257c5c268b21e823ac688b0aca0a332ba5e3841e87384c1c75561c9632013ad4abc921a81d0a0dd131f0578eefb47da120e5bf070f94aec09e68f1f0e131dff34b3892f374d1181069ae3ca318a69cb56ba1e666a9e826e4ebd1dc99482f9b4cf1cd2a2caeb79e251dd1eb7562f21ef0aae2f31b40d5c15f4e3d9899c32ae2d34e1f56a7ca960debe3793c4093ec9300017fa6905987d07bc39c92372a2b18733f2633a761d9afb4bd602813d6793c6d5e428ad68ccce3532b5ec9bcc9c5239804a94d25392940344fec6bcc7229fe463511591764663e9a697b3cdbdaf43a260cca791990acc81a6edfca3b20d07ca36893bdd0481f3a9996a4253047f79799509e89589bea2f30ab35153634ac5baa2ae61c380d0ff9b8a9291c6bebc954a7aff3fa5f79e7095dc8e9e954c03216e697051e5a3fd9c5da46a5a9e5296d6a4d9dcef86b1981a243dabc6af83c54cfcc3409c61f0fdc8fbe55f1666c5bb8031469fc91492ab64089bca08b292fa6ff9ccdd571ceb173c2448771db3ed8fbbd885d58b9c05209ba195a374cc98256b8120b3d3a39096400565f56f0a1ef2f93c46b36ed9fd1c46c716c9f050831018f131de663984ce4e88a8edf6c76ffc6f654fcce2ac98e3d197f69f1070618a9e0a439e828764943745b6fd5788b92144f12aa4ddc433bcb11d59aaf20fef44c45c23d4b68cec0625b415a20239a9917908437f01b29520f9be0117e99bae71a065c1b678725a8a11cb1aa6709708fc42fa1a4bb9fa1c7e22049a8a028a6512befca2b533ae8735320d3e9c197838cd6cc48dd53506e9403713f644bed6c932d33edf3e9fe291708c7ac0dcd3fe8ebae85c0983c6a4d408de87be63a19ee0f1562c4d8f4a80916fadb8c528894a435024df3261492d525b7d1616ebbd18dabbde5063a53d589746913f153b25d83c3366fe39ffbca004494c25784a3518ae8709a55bf62466e102d29240bb4b0d89bc28caa3abd40f202b421a4081d3f04ee6d9013b08782da342bacb3ec10dfc5092f8dfdfe938f4f9b4ea1214e3de60cc1ecc5f270c721f369494a8e195b65c15b0ec9e949cc52e795404f0784fc44721b2b3fe6b87d95db351d5811d3b62af1fd2b555d18c201b37ad6e03dc55d7271e07756cf36fc8b3b920c2e16dd4d1373013d437f1292ebc47e5643d7a93b3337535d8a23702f8a017348d159d6409873048d35a83b781b6bfae5f9a0824e0613134925ea250952e621fe6e2b656896df2be42abdc090b0adca583a043abb21d64f3ac33f980409730800273b58baacff4da7b442e8841b035bb963c0d249448efa225f8f8d78334e4c7ede1c47ca6a68fd32906236b1003f1ff1a7ba171168af88b9364749b2d486eb34b733413cd9899ed2ca849cd6a753997158595ae8bbae3ecec6769e267f5a1fc111c637cc532eb03748c0f87e44c4ac6dc22648f12c821b06ca009cf16582e6c1488f4c622f5771eec2d0c10749a3962156951a6e627da5f83b67844824c46ca8cec1d7bfa72a60ebca13877426e5fcbad315accd6d070f0b3d6772c9efad481adb267639b677cba27906759f8cb41ff9c498c09f73fcb5a9d5c43e4ba22bf9dbdf8a141edfe97faadf8cfafe1a53028dd4e488b3b7e4ed748f0507ebff3b0f7f594a97a1471342f03570aea637a07d4a565faab0aa59b18ab077f658cb0f284086d2b39c41b125a27131c3af10cee54e32d735e8a4eb45376b0dcaa676ce669cd66641423a9111503749db52698bba70c4e14fbe37a14beb61c1ea910060927d3b53c2190fc3052753ae812fea462ba7d2db274f914848c22c718fe029e7e1df2c5a98e57008cb5b05536ba9a01f336568a00d6a796a0f4ef1f58388031c1e54e2fd67454794f06b36d4d1e74897431ab887a5cff47ac91dbedc4ec37f3de0e132d9602a3613198ae23cb8844973fc1b644f6f9ea7b9d6122c851f5d343970dc922a8d536f3d12096b733d8ba52c22237f95eddaa41eaa6876c4264e51017ffc03f8a9f3dbe073cd6f5896265fecc822493afae833e9dc6207b25bac4617fca0f1e2675896af6a7b169dca622cb11711b138dbb4712e09e12bca49a84bd2620ed470fffa7653dc11eee57aa4cd6cbcbf4b6f4e608a216790234613a2329a838a8c1d9530c1a610cb7eebb1d834e0ab9b5c3d9f02a5661e7a926730559b1acec92c76de45aa82b3a05364dd5e16d58400bd9dfaa1a3aa6f091cb4f3ee194d3328e7015d31589ffb0d8fd8778be7933c3c203f6ba9db26a46d54edd8160a1b020fe11ec605914aef7ce3564505d9e263dd0ac4efb6cb1c02feee1171cc9a50e8d8ef676d821babc9182c626432783ec704017fb1352b533878f0ee2c352f2093fdc4737abb0736dc211b515bcc170bc2bd093</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>回眸一视李少峰</title>
    <url>/posts/ea6e68d1/</url>
    <content><![CDATA[<p>盼望着，盼望着，上课铃响了，第一节历史课开始了。</p>
<p>“封建专制帝王”李老师已在讲台上候好。他右手轻轻一按电钮，刺眼的幻灯片立刻弹了出来：两个大号宋体字“历史”仿佛仿佛被贴在屏幕左上角，正文里用小字注释了“历史”二字的含义，右下角隐隐约约映上了一层国画。</p>
<p>“抬头！”他面朝屏幕，肚子却侧向同学们微挺着，胳膊笔直剑指“历史”二字，手耷拉着，“咱们这节是历史课。”，然而同学们，似乎陶醉于幻灯片的徘徊于现代、和上世纪90年代的艺术风格了。</p>
<p>李老师胳膊一耷接，头一扭，和同学们对视。</p>
<p>26度的室温突然冰冷宛若冬天；动植物的呼吸声戛然而止；空气中的饭味杂味不知去处，取而代之的是空调的氯气味。</p>
<p>李老师嘴唇颤抖了一下：“啧。”</p>
<p>教室瞬间苏醒过来。我和周围的同学立刻从桌子上弹起来，脖子设法收缩在前面同学的后脑勺，手死死钉在桌子边缘。几位“彪形大汉”不忘收紧自己滚圆的肚子，并在脸上挂一丝不怀好意的微笑。我则急忙调整坐姿，渴望老师对我刮目相看，正为自己的迅速反应而得意洋洋时，突然发觉在自己忘记挠痒痒，心中万匹野马匹腾而来…</p>
<p>李老师撂下口头禅：坐姿端正——腰版儿～挺直——目视前方——竖着耳朵认真听——“</p>
<p>李老师又面朝屏幕，肚子侧向同学们，微挺着，胳膊笔直剑指“历史”二字，手继续牵拉着——一切都结束了。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>夏季中的一点凉</title>
    <url>/posts/40635/</url>
    <content><![CDATA[<p>烈日当空，骄阳似火，一切万物好像都已熔化，平常在树上叽叽喳喳的小鸟热的不知去向。空中、地面，到处都是刺眼的阳光，让人睁不开眼。</p>
<p>拎着大包小包的我和妈妈疾步往家走，想赶快逃离蒸腾的热浪，走呀走……终于到家。一进家门，舒爽清凉的空气扑面而来，我像飞鼠一般窜进屋子，直卧进沙发里。空调的凉气，依旧难以消除酷暑带来的口干舌燥，我连倒杯水的力气都没有了，瘫在沙发上使劲喘着粗气。</p>
<p>这时，妈妈从冰箱里抱出半个西瓜，我眼盯着冰凉西瓜，跟进了厨房。只见瓜皮上布满了浅黄墨绿相交的条纹，瓜瓤红红的沙沙的，漆黑油亮的西瓜籽，镶嵌在红瓤里，偶尔可见几颗褐色瓜籽和白色未成形的籽宝宝。一看就知道，这是个不错的西瓜。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/watermelon-thumb.jpg" alt="西瓜"></p>
<p>看着冒凉气，透着清香的一角角西瓜，我已经迫不及待了。嫩嫩的瓤、丝丝的甜、喷喷的凉，红红的瓜汁让我直流口水。我拿起一个叉子，对着一块最诱人的西瓜插去，放进嘴里，霎时干燥的嘴唇冒火的喉咙，冰冰地、酥酥地，像过电一样。我悠哉地嚼着，香甜清凉的汁液，渗进了每一个细胞。啊，吃西瓜真是一件美事！</p>
<p>西瓜既不像甘蔗甜得跑了调、喉住了嗓，又不像梨子甜得只有单一的味道。西瓜可以解渴，吃多少不会腻，直到肚子鼓鼓没了缝隙；西瓜可以解馋，甜得自然香得穿心；西瓜可以养目，看着就爱人儿、提神醒眼。</p>
<p>不一会，一块又一块的西瓜填进嘴中，我越吃越带劲，越吃越不讲究，瓤里的瓜籽都顾不得吐出来……终于一盘西瓜进肚。嘴里的瓜香久久不散，甜滋滋的，不管是喝酸奶、吃葡萄，都不能遮去西瓜的味道。</p>
<p>夏天，人们多爱味道各样的雪糕，殊不知不寡不腻生津止渴、香甜可口的西瓜才是大自然赐给我们的最上解暑果品——甜蜜蜜、凉滋滋，爽歪歪。烈日炎炎，我们为什么不饱尝有益健康的西瓜呢？</p>
<p>什么时候才能到2020年的夏天呢？</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>小镇的桥</title>
    <url>/posts/1372/</url>
    <content><![CDATA[<p>土门关驿道小镇是个古香古色的地方。在驿道小镇，我被一座“桥”定住了神经，它有一个动人的名字，“同情桥”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/yidao-town-bridge-thumb.png" alt="同情桥"></p>
<p>桥由绳索与木板搭成，像一条晃晃悠悠的长长纽带，中间微微下垂，两头分别被系在小镇两边高起的地势上。桥上系着密密麻麻的红色祈愿丝缎，远望去“同情桥”就像天空上飘着一条红丝带。小桥身材很苗条且修长，只能同时容下两三个人并行的它，从这头延伸到那边，好长！</p>
<p>当我来到桥边，正是游客最多的时候，人在桥上走，桥在空中摇。长桥上整齐地塞满了人，不见空隙；人们前胸贴后背，一步一探，缓慢移动着。看着摇摇欲坠不堪重负的长桥，我没有上前凑热闹，静静地坐在一边欣赏驿道小镇的桥。</p>
<p>各种各样的人——胖的、瘦的、高的、矮的、男的、女的、老的、少的，在桥上走。老爷爷脸上带着一丝淡定的微笑，远望着桥对岸；年轻妈妈俯身刻意与小儿谈天讲故事，驱散孩子的恐惧；小孩子们时而露齿嬉笑，时而紧张地张着大嘴；小不点的婴儿不管那一套，想哭就哭想闹就闹。人们在空中的“红布条”上，在烈日下享受着惊险和刺激。</p>
<p>此时，“桥先生”看到了自己身上有那么多勇敢的大朋友和小朋友，也许想再添点佐料和大家逗乐？只见桥身微微荡漾，一阵惊叫，桥上的行人赶忙紧握绳索，停步不前，屏住呼吸；爸爸搀扶着爷爷奶奶；妈妈紧抱着哇哇大叫的婴儿；孩子大呼爸爸妈妈，再不敢淘气调皮……</p>
<p>桥上步子慢了下来，桥身晃动也随之变轻，过桥人和我心里都松了口气。孩子们恢复了生气，大人们表情不再紧张，桥上说笑声又响起。</p>
<p>桥先生用缓慢优雅的摆幅安抚着桥上紧张的心，用桥板吱呀呀的响声合着桥上有节奏的步伐。</p>
<p>一切都是那么地和谐——危险是假的，刺激是真的；害怕是假的，快乐是真的；通过桥是假的，通过心里的挑战是真的。</p>
<p>驿道小镇的桥，我在静静地读你，如果我给你起名，会叫你“同心桥”。有人行，才有你摇曳的优雅；长桥在，才有穿行的渴望和欢乐。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>执行一个优美的并行程序</title>
    <url>/posts/42d3b274/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>我最近用<code>Python</code>的<code>print</code>，通过打印一帧帧的进度条，实现了一个进度条样式，顺便跟大家分享一下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time

AT_PROGRESS_BAR &#x3D; [
    &quot;(                    )&quot;, 
    &quot;(@                   )&quot;, 
    &quot;(@@                  )&quot;, 
    &quot;(@@@                 )&quot;, 
    &quot;(@@@@                )&quot;, 
    &quot;(@@@@@               )&quot;, 
    &quot;(@@@@@@              )&quot;, 
    &quot;(@@@@@@@             )&quot;, 
    &quot;(@@@@@@@@            )&quot;, 
    &quot;(@@@@@@@@@           )&quot;,
    &quot;(@@@@@@@@@@          )&quot;,
    &quot;(@@@@@@@@@@@         )&quot;,
    &quot;(@@@@@@@@@@@@        )&quot;,
    &quot;( @@@@@@@@@@@@       )&quot;,
    &quot;(  @@@@@@@@@@@@      )&quot;,
    &quot;(   @@@@@@@@@@@@     )&quot;,
    &quot;(    @@@@@@@@@@@@    )&quot;,
    &quot;(     @@@@@@@@@@@@   )&quot;,
    &quot;(      @@@@@@@@@@@@  )&quot;,
    &quot;(       @@@@@@@@@@@@ )&quot;,
    &quot;(        @@@@@@@@@@@@)&quot;,
    &quot;(         @@@@@@@@@@@)&quot;,
    &quot;(          @@@@@@@@@@)&quot;,
    &quot;(           @@@@@@@@@)&quot;,
    &quot;(            @@@@@@@@)&quot;,
    &quot;(             @@@@@@@)&quot;,
    &quot;(              @@@@@@)&quot;,
    &quot;(               @@@@@)&quot;,
    &quot;(                @@@@)&quot;,
    &quot;(                 @@@)&quot;,
    &quot;(                  @@)&quot;,
    &quot;(                   @)&quot;,
    &quot;(                    )&quot;,
]
def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行效果如下：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-loading.gif" alt="进度条"><br>然而，我现在有一个函数，叫做<code>long_function()</code>，用来模拟一个执行时间很长的函数：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我想让<code>long_function()</code>执行的时候，让<code>print_progress_bar()</code>也一块伴随执行。但是如果我们直接使用如下代码：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    long_function()
    print_progress_bar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>两个函数是不会同时执行的。因此，我们就需要使用<code>multiprocessing</code>模块，使用并行程序<a class="link"   href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html" >^1<i class="fas fa-external-link-alt"></i></a>执行。</p>
<h1 id="需求一：2进程并行执行"><a href="#需求一：2进程并行执行" class="headerlink" title="需求一：2进程并行执行"></a>需求一：2进程并行执行</h1><p>代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process

AT_PROGRESS_BAR &#x3D; [
    &quot;(                    )&quot;, 
    &quot;(@                   )&quot;, 
    &quot;(@@                  )&quot;, 
    &quot;(@@@                 )&quot;, 
    &quot;(@@@@                )&quot;, 
    &quot;(@@@@@               )&quot;, 
    &quot;(@@@@@@              )&quot;, 
    &quot;(@@@@@@@             )&quot;, 
    &quot;(@@@@@@@@            )&quot;, 
    &quot;(@@@@@@@@@           )&quot;,
    &quot;(@@@@@@@@@@          )&quot;,
    &quot;(@@@@@@@@@@@         )&quot;,
    &quot;(@@@@@@@@@@@@        )&quot;,
    &quot;( @@@@@@@@@@@@       )&quot;,
    &quot;(  @@@@@@@@@@@@      )&quot;,
    &quot;(   @@@@@@@@@@@@     )&quot;,
    &quot;(    @@@@@@@@@@@@    )&quot;,
    &quot;(     @@@@@@@@@@@@   )&quot;,
    &quot;(      @@@@@@@@@@@@  )&quot;,
    &quot;(       @@@@@@@@@@@@ )&quot;,
    &quot;(        @@@@@@@@@@@@)&quot;,
    &quot;(         @@@@@@@@@@@)&quot;,
    &quot;(          @@@@@@@@@@)&quot;,
    &quot;(           @@@@@@@@@)&quot;,
    &quot;(            @@@@@@@@)&quot;,
    &quot;(             @@@@@@@)&quot;,
    &quot;(              @@@@@@)&quot;,
    &quot;(               @@@@@)&quot;,
    &quot;(                @@@@)&quot;,
    &quot;(                 @@@)&quot;,
    &quot;(                  @@)&quot;,
    &quot;(                   @)&quot;,
    &quot;(                    )&quot;,
]

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    p &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())
    p.start()
    long_function()
    p.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们首先在<code>__main__</code>（主程序）里面新建一个<code>Process</code>实例；其次，用<code>start()</code>启动这个程序；第三，运行父程序<code>long_function()</code>，最后再用<code>join()</code>函数等待到程序终止。</p>
<p>效果（因为两个<code>print</code>语句冲突，所以可能打印的效果不太好，但是是正常的）：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async.gif" alt="效果-需求一"></p>
<h1 id="需求二：2-进程并行"><a href="#需求二：2-进程并行" class="headerlink" title="需求二：2+进程并行"></a>需求二：2+进程并行</h1><p>对于2+进程的并行程序来说，我们使用进程池（<code>Pool</code>）来实现会更方便一些。代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process, Pool # 引入 Pool

AT_PROGRESS_BAR &#x3D; [...] # 为了观看方便，把这个数组省略了

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

# 我在这里新增了第三个函数：bfunc，作为第三个进程。
def bfunc():
    for i in range(30):
        time.sleep(0.5)
        print(&quot;bfunc&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    pool &#x3D; Pool(2) # 新建一个含有两个进程的进程池
    pool.apply_async(print_progress_bar, args&#x3D;()) # 添加 print_progress_bar 进程
    pool.apply_async(bfunc, args&#x3D;()) # 添加 bfunc 进程
    long_function() # 执行主进程
    p.close() # 进程池不再接受新进程
    p.start() # 启动进程池
    p.join() # 进程池等待结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>三个进程并行的运行效果（<code>print</code>语句还是有些冲突，不过运行正常）：<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-2.gif" alt="效果-需求一"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果你把<code>pool</code>里添加上4+个进程的话，程序的并行可能失败。这取决于你的电脑有几个 CPU（就是几核），可以通过如下<code>os.cpu_count()</code>命令查询：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">Python 3.8.2 (v3.8.2:7b3ab5921f, Feb 24 2020, 17:52:18) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import os
&gt;&gt;&gt; 
&gt;&gt;&gt; os.cpu_count()
4
&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="需求三：两进程并行中，其中一个进程停止，另外一个进程也停止"><a href="#需求三：两进程并行中，其中一个进程停止，另外一个进程也停止" class="headerlink" title="需求三：两进程并行中，其中一个进程停止，另外一个进程也停止"></a>需求三：两进程并行中，其中一个进程停止，另外一个进程也停止</h1><p>一开始我使用<code>Pool</code>进行并行，并且尝试捕捉<code>SIGCHLD</code>信号，来解决标题中的问题，但是这样好像行不太同。实际上我们可以使用两个<code>Process</code>实现，代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time
from multiprocessing import Process

AT_PROGRESS_BAR &#x3D; [...] # 为了读者方便，省略数组内容

def print_progress_bar():
    while True:
        for i in AT_PROGRESS_BAR:
            print(i, end&#x3D;&quot;&quot;)
            time.sleep(0.1)
            print(&#39;\r&#39; * len(i), end&#x3D;&quot;&quot;)
            
def long_function():
    for i in range(20):
        # 每隔一秒就 print 一下，以示函数正在执行。
        time.sleep(1)
        print(&quot;函数正在执行！&quot;)

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    p &#x3D; Process(target&#x3D;long_function, args&#x3D;())
    p.start()
    p2 &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())
    p2.start()
    p.join()
    p2.terminate()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中，我们希望<code>long_function()</code>执行结束后，停止<code>print_progress_bar()</code>进程。</p>
<p>代码中：首先，我创建了<code>p</code>和<code>p2</code>两个<code>Process</code>，分别代表<code>long_function</code>和<code>print_progress_bar</code>，再分别<code>start()</code>进程；其次，我通过<code>p.join()</code>等待<code>p</code>进程结束，却不等待<code>p2</code>结束；最后，我巧妙地在<code>p</code>结束（即<code>long_function()</code>结束后）后，通过<code>terminate()</code>停止<code>p2</code>进程。</p>
<p>这种方法的好处是，我们不用等待或传递任何信号，而只是通过<strong>代码的从上到下依次执行规律</strong>，解决标题中的问题。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战</title>
    <url>/posts/30893/</url>
    <content><![CDATA[<p>今天姥姥让我看了一个由『中国梦想秀 • 第十季』播出的、名为《少年挑战吉尼斯世界纪录——抛接还原魔方》的短视频。起初我不以为然，几秒种后，我惊呆了，心里充满了无限激动与惊叹。</p>
<p>节目一开始，首先映入眼帘的是容纳着几千名观众的挑战会场、台上主持人、两位吉尼斯认证官与12岁的“神童”阙剑宇。接着，放在桌子上的三个魔方很快被两位认证官打乱，用黑黑的布盖上。看着屏幕上写着的“倒计时5:20:00”字样，我心想，这也太离奇了吧，怎么可能在这么短的时间内复原三个魔方呢？当一切准备停当后，随着一声有力的“开始”，吉尼斯挑战赛启动了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/challenge-thumb.jpg" alt="还原魔方"></p>
<p>让人们目瞪口呆的时刻来了——挑战者阙剑宇没有只专注于一个魔方去努力地复原，而是两手抓起三个魔方，交错往高空抛掷，俨然像个杂技演员。当镜头放慢时，我被震住了，原来剑宇在每个魔方触手的瞬间转动着魔方，同时对三个魔方进行着复原！当摄像头转向观众，人们个个惊愕地张着大嘴，表情凝固，好像在说：“天呐，太神奇了。太不可思议了……这是真的吗?”</p>
<p>我紧盯屏幕，眼球随着三个魔方飞秒般地转动，担心这位神童出现闪失。阙剑宇继续小心翼翼地抛着魔方，同时快速地用另一只手接住另一个魔方，手接魔方的一刹那，飞速精准地用手指拨动色块，反复抛起反复拨动着……我几乎不敢相信眼前这一幕是真的。</p>
<p>“第一个魔方复原完成（用时2’ 01’’）”，一个大大的红色提示框出现在屏幕左下角。</p>
<p>此时，“神童”抛魔方的速度越来越快……越来越快，以至于画面都模糊了。不见魔方，只见一条条虚幻的彩色光带飘向空中，剑宇双手快速旋转的魔方像一个运动着的彩色风火轮。镜头被抬高，当看到阙同学紧锁眉头、紧咬牙关，台下的观众和我都心惊胆颤、惴惴不安。</p>
<p>3’ 39’’的字样在屏幕上闪烁着……</p>
<p>我快窒息了，还有两个魔方，阙同学能在这么短的时间内复原吗？又过了大概10秒钟，一个令人欣慰的提示框出现在屏幕下方。<br>“第二个魔方复原完成（用时1’44’’）”，我心中那块沉重的石头终于落地了。</p>
<p>“还有大约一分钟！”主持人宣布。</p>
<p>至关重要的一分钟！我紧张地盯着屏幕。阙剑宇越来越快地抛接魔方，魔方嗖嗖咔咔作响，这时魔方抛起的高度也降低了；他眼睛盯魔方越来越紧，手的转速越来越快……让人欣慰的是，到目前为止神童没有一次将魔方甩掉或者转错层。挑战者如此高超的技艺和强大的心理素质，让我佩服得五体投地。最后这60秒之内，阙剑宇究竟能不能打破吉尼斯世界记录呢？时间在一秒一秒钟过去。</p>
<p>只剩下20秒，倒计时颜色变红，红的跟血一样，让人热血沸腾。时间的闪烁疯狂了起来，我倒吸了一口凉气。</p>
<p>当阙剑宇抛、拨动作噶然停止，屏幕显示还剩下13秒钟。神童提前结束了挑战任务，到底成功与否呢？我的心已经卡在嗓子眼了。</p>
<p>“阙剑宇，你刚才挑战的是抛接还原魔方，获得了最短时间的吉尼斯世界荣誉，你的最终成绩是5分06秒61。这是一项新的吉尼斯世界纪录！”认证官当场宣布。</p>
<p>哇！全场为之欢呼沸腾，我被挑战者精彩绝技折服了，不敢相信的事情变成了现实。我相信阙剑宇的成功不仅仅来源于天赋，最重要的是背后无言的努力与付出！这是一次成功和精彩的挑战，让我难忘。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>教你过关吾爱破解游戏《圈小猫》</title>
    <url>/posts/32831/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我刚结识<a class="link"   href="https://wwww.52pojie.cn/" >吾爱破解<i class="fas fa-external-link-alt"></i></a>网站，就认识了网站的隐藏游戏《圈小猫》。我把《圈小猫》这个游戏吹爆——这个游戏确实好玩，但这是只有<strong>像我一样聪明的人</strong>才能玩得起的游戏。</p>
<p>因此，这篇文章将会教你如何篡改这个游戏，实现任何人，局局都能赢（如果说逆向这个游戏，未免有些太夸张了）。如果，你以前玩游戏的时候，小猫局局都逃掉，那么这一次你就可以痛打它了。</p>
<h1 id="游戏介绍"><a href="#游戏介绍" class="headerlink" title="游戏介绍"></a>游戏介绍</h1><p>如果你已经是《圈小猫》的忠实玩家，可以忽略这部分。</p>
<h2 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h2><p>这个游戏的打开方式都知道了吧！你只要在主站的URL后面随便输入一些可以让吾爱404的东西，就可以打开这个游戏。就像这样：</p>
<ul>
<li><a class="link"   href="https://www.52pojie.cn/1234567890" >https://www.52pojie.cn/1234567890<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.52pojie.cn/awdihgfbnkd" >https://www.52pojie.cn/awdihgfbnkd<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.52pojie.cn/helloworld" >https://www.52pojie.cn/helloworld<i class="fas fa-external-link-alt"></i></a></li>
<li>…</li>
</ul>
<h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><ul>
<li>点击小圆点，围住小猫；</li>
<li>你点击一次，小猫走一次；</li>
<li>直到你把小猫围住（赢），或者小猫走到边界并逃跑（输），游戏结束。</li>
</ul>
<h1 id="了解源码"><a href="#了解源码" class="headerlink" title="了解源码"></a>了解源码</h1><p>你或许不知道，这个游戏不是吾爱破解编写的，而是GitHub上的一个开源项目：<a class="link"   href="https://github.com/ganlvtech/phaser-catch-the-cat" >phaser-catch-the-cat<i class="fas fa-external-link-alt"></i></a>，作者是<a class="link"   href="https://github.com/ganlvtech" >glanvtech<i class="fas fa-external-link-alt"></i></a>。游戏的思路和小猫的图片来源于 <a class="link"   href="https://www.gamedesign.jp/" >GameDesign<i class="fas fa-external-link-alt"></i></a>，原来的游戏名叫 Chat Noir，原作者只是尝试用 JavaScript 重写一遍。</p>
<h2 id="README"><a href="#README" class="headerlink" title="README"></a>README</h2><p>我们先进入仓库，看一下README（下文是节选）：</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>首先引入游戏框架 <code>phaser.min.js</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后引入游戏代码 <code>catch-the-cat.js</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后在指定的 <code>div</code> 中新建一个游戏的 <code>canvas</code>，并开始游戏：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
    window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
        h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
        r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
        backgroundColor<span class="token operator">:</span> <span class="token number">0xeeeeee</span><span class="token punctuation">,</span>
        parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
        statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
        credit<span class="token operator">:</span> <span class="token string">'github.com/ganlvtech'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>CatchTheCatGame</code>的参数列表如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>w</code></td>
<td align="center">11</td>
<td align="left">横向格子数</td>
</tr>
<tr>
<td align="center"><code>h</code></td>
<td align="center">11</td>
<td align="left">竖向格子数</td>
</tr>
<tr>
<td align="center"><code>r</code></td>
<td align="center">20</td>
<td align="left">圆半径像素</td>
</tr>
</tbody></table>
<p>非必选参数如下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>backgroundColor</code></td>
<td align="left"><code>0xeeeeee</code></td>
<td align="left">背景颜色</td>
</tr>
<tr>
<td align="left"><code>parent</code></td>
<td align="left"><code>catch-the-cat</code></td>
<td align="left">父元素的 <code>id</code> 或 <code>DOM</code> 对象</td>
</tr>
<tr>
<td align="left"><code>statusBarAlign</code></td>
<td align="left"><code>center</code></td>
<td align="left">状态栏左对齐 <code>left</code> 或居中 <code>center</code></td>
</tr>
<tr>
<td align="left"><code>credit</code></td>
<td align="left"><code>github.com/ganlvtech</code></td>
<td align="left">右下角的备注信息</td>
</tr>
</tbody></table>
<h3 id="自定义算法"><a href="#自定义算法" class="headerlink" title="自定义算法"></a>自定义算法</h3><p>参考<a href="https://github.com/ganlvtech/phaser-catch-the-cat/tree/master/src/solvers"><code>src/solvers/</code></a>中提供的例子编写算法，并使用下列代码替换。</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span>solver <span class="token operator">=</span> yourSolver<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个 <code>solver</code> 的返回值即为猫要往哪个方向走一步，如果撞墙，则算玩家获胜。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-1</td>
<td align="left">猫主动弃权</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">左</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">左上</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">右上</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">右</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">右下</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">左下</td>
</tr>
</tbody></table>
<p>如果猫站在星号的位置，那么数字代表每个方向的编号：</p>
<pre class="line-numbers language-none"><code class="language-none">1 2
0 * 3
5 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>下面的例子可以让猫的每一步都向左走，直到撞墙：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p>既然知道了《圈小猫》的代码结构与自定义算法的编写，那我们就可以上代码了！</p>
<p>首先，我们要引入游戏脚本。获取脚本有如下方式：</p>
<ul>
<li>你可以在项目的<a class="link"   href="https://github.com/ganlvtech/phaser-catch-the-cat/releases" >Release 界面<i class="fas fa-external-link-alt"></i></a>下载；</li>
<li>你也可以引用吾爱的脚本链接：<a class="link"   href="https://down.52pojie.cn/.fancyindex/js/phaser.min.js" >phaser.min.js<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://down.52pojie.cn/.fancyindex/js/catch-the-cat.js" >catch-the-cat.js<i class="fas fa-external-link-alt"></i></a>。不过吾爱可能开启了防盗链，在我的<code>html</code>里无法引用。</li>
</ul>
<p>然后在文件中引入并且设置编码<code>utf-8</code>：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其次，写一个<code>body</code>，里面添加一个<code>div</code>和一组<code>script</code>标签：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
       
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>script</code>里仿照吾爱源码的设置编写<code>JavaScript</code>：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，仿照<code>README</code>文件编写自定义走步算法。我把游戏的<code>solver</code>属性设置为-1，这样一上来猫会主动弃权：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>总的来说，你的代码应该长这样（注<code>script</code>引用有能力的也可替换为网址，我这不知为何引用不了网址）：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>phaser.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>catch-the-cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之后，用浏览器打开，预览感受一下，猫咪不管身处何处，只要我在地图上随便点一个墙，猫咪就自动放弃了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/52-catgame.gif" alt="效果"></p>
<h1 id="修改浏览器代码"><a href="#修改浏览器代码" class="headerlink" title="修改浏览器代码"></a>修改浏览器代码</h1><p>我们先复制刚才编写的这段代码：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        window<span class="token punctuation">.</span>game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CatchTheCatGame</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
            w<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            h<span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>
            r<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
            backgroundColor<span class="token operator">:</span> <span class="token number">16777215</span><span class="token punctuation">,</span>
            parent<span class="token operator">:</span> <span class="token string">'catch-the-cat'</span><span class="token punctuation">,</span>
            statusBarAlign<span class="token operator">:</span> <span class="token string">'center'</span><span class="token punctuation">,</span>
            credit<span class="token operator">:</span> <span class="token string">'www.52pojie.cn'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span>game<span class="token punctuation">.</span><span class="token function-variable function">solver</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">blocksIsWall<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们进入浏览器，开一局《圈小猫》，之后我们按下F12、Ctrl + Shift + I或Cmd + Option + I打开网页审查元素（就是所谓的控制台），然后定位到图中的位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/3/28/hop-catgame-browser.jpg" alt="定位代码"></p>
<p>然后双击这行代码，或者右键 &gt; 编辑 HTML，将我们刚刚复制的代码粘贴进去。之后，就享受痛打猫咪的感觉吧——</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/52-catgame.gif" alt="效果"></p>
<p>……怎么突然感觉游戏没意思了！？</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行之美不在风景，在于人乎</title>
    <url>/posts/46252/</url>
    <content><![CDATA[<p>旅游对于小孩子来说是很开心的事，因为可以甩下一大堆让人头疼的作业，可以去那些没有去过的地方走走逛逛，甚至还可以和平日的小伙伴一路同行，一路欢歌欢闹。</p>
<p>旅游对于我们来说不在乎有没有风景，而在乎有没有玩伴，暑假我的同学辰辰就带给我一段快乐之行。</p>
<p>行程中我们俩在床上翻跟斗，还用一个电脑研究编程，路上坐在车里玩数学手指游戏，我们不仅给美景拍照，还给小动物小昆虫拍照。我们孩子旅行游记的主角很另类，是一只可爱的蜗牛和一只刚会蹦的宝宝青蛙。</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/snail-thumb.jpg" alt="snail-thumb" style="zoom:150%;" />

<p>这是一只大鸣大放在路上散步的蜗牛，虽然它穿着跟石灰地一样颜色的衣服，掉在路上就像掉个黑芝麻一样不显眼，但还是被我和辰辰敏锐的近视眼发现了，我们用手机录下了蜗牛优雅漫步的身姿。这只蜗牛的表现简直可以入选《国家地理》的封面了。</p>
<p>瞧！它昂首挺胸，威仪十足，丝毫不惧我们的闪光镜头，俨然像个见过大世面的王者。</p>
<p>宝宝青蛙是我和他发现的另外一个小可爱，它也许刚刚进化成功，只有一角硬币那么大，蹦起来特别灵活，小青蛙跳到哪我和同学就跳到哪。看到青蛙小小年纪，身手如此不凡，一个人没有爸爸妈妈和同类陪伴去闯世界，我一方面担心一方面又由衷地赞叹。</p>
<p>一路旅行，很多景色都淡忘了，我和同学在车里玩的手指游戏和小蜗牛、小青蛙却还是记忆犹新。</p>
<p>旅游之美真的不在景，因为有同学的陪伴，才有了旅行中更多的快乐。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>来自高层的烦恼</title>
    <url>/posts/ff646565/</url>
    <content><![CDATA[<p>搬进高层住宅曾是缩短我上学时间的宏图。但是如今看来，不仅没有解决我的麻烦，还给我每天的好心情泼了盆冷水。</p>
<p>星期一，7:20。天空此时还没有完全亮透，是一层涂着点灰色的蓝水粉，倒是挺透亮、挺好看，但阴暗的光，如同一个冰凉巴掌遮住视线，始终在我的心坎里留下一块深深的阴影。我讨厌这凄凉。时间所迫，沉重的书包还是压在了肩上。</p>
<p>电梯间没有灯光，比家里更黑暗。一部电梯在二十二楼，另一部在十五楼——住在八楼的我离它们都不远，只好轻触按钮，顿时浑身发凉：按钮是铁青的，光滑得能当一面镜子，似乎曾有许多人在它身上摸来摸去，跟他过不去；他见了我的手指，跟个傻瓜一样不带动弹。全身的力气被我发泄到它的身上，恼羞成怒的红光才从箭头吝啬地透露出一点来。</p>
<p>那个破按钮的短暂失灵，让我很不痛快，紧接着电梯也开始跟我开玩笑。红色的15在液晶显示屏上跳跃、变换，14、13、12……我默念着，和电梯的速度尽量一致，根本就是一个仆人，时刻提醒着主人该到第几层了。电梯异常平稳地运行着，对我视而不见，突然在第十一层凝固了！伴随着红色的数字的停顿，一丝诡异而可恶的戏谑顺着井道而下：“11层到了，请一路走好！”随着“砰”的关门声，电梯加快，十！九！八！……</p>
<p>七！？……</p>
<p>我在这两扇铁门前的存在感，简直不是零，而是没有。</p>
<p>又是平常的星期一。早晨的楼梯口，幽静而可怕。这几层的楼梯灯都死在了天花板上，留下千姿百态的遗容。只剩下指示安全出口的指示灯在墙角冷落着，散发着惨淡的绿光。水泥糊成的台阶上，蹭满了各种颜色的油漆；惨白的墙裙上，飞溅着奇怪的灰色污渍；头顶天花板的“印证”广告依然显眼，联系电话我都能背过。阴风不知从何席卷而来，让我上下打了个寒战。</p>
<p>终于到了单元门口，花白的天空上写满了我的无奈。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>爆胃的开花肠</title>
    <url>/posts/11466/</url>
    <content><![CDATA[<p>土门关驿道小镇不仅古香古色，而且小镇里各种民间饭铺更是让人目不暇接，大开胃口。这些小店铺干净且有特色，虽然没有高大上的门面，却充满了浓厚的乡土气息，这里的美食吸引了众多游人。</p>
<p>走在驿道小镇深长的巷子里，各种香味阵阵扑来，一时我隐隐约约感觉到一股诱人的奇香，越走那股香味就越浓。大约走了50米，果然看到了一家小小的香肠店铺——那美妙的香味就是从这里飘来的。</p>
<p>只见店铺前的几张桌子，都已经坐满了品尝香肠的游客。铺外摆放着一个大铁盘，上面放满了许多让人嘴馋的香肠，它们都是手工制作而成的，不添加任何色素。这家店铺的香肠有个好听的名字，叫“开花肠”。</p>
<p>开花肠看上去和城里的香肠很不一样：城里超市卖的各类香肠就像是一个个孤零零的“光棍”，而这里卖的开花肠，不仅个头比城里普通香肠粗了两倍，特别有派头，而且开花肠不像城里香肠，表面只有单一的肉色，表皮也不是那种一贯的光滑，开花肠看上去表面稍微粗糙。成品肠裹上五花八门的调料，再配上从香肠侧面切开而成的“花瓣”，造型实在别具一格。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/sausage-thumb.png" alt="开花肠"></p>
<p>我迫不及待地挤过去，买了一根开花肠。没料到价格竟然比市里的贵出5倍，15元一根！付了钱后，厨师叔叔便在盘子里拿了一根已经做好模型的生肠，往大油锅里一丢，炸到金黄透亮、花瓣卷曲了的时候，叔叔就用大夹子将香肠拣出来，往上面撒上叫不上名的调料，再放到一个防油的特制褐色牛皮纸卷里，开花肠就做好了。</p>
<p>我接过它，手里的开花肠就像是一件艺术品。黄色的调料、赤色的肠身、焦黄的“花瓣”……各种颜色错落很有层次；出锅的味道麻醉着我的鼻腔，辣香的、油香的、肉香的、咸香的……“十三”香的，绝对称得上色味俱佳。香肠拿在手里都是一种享受！更奇妙的是它入口的感觉。</p>
<p>我大口大口地吹着腾腾热气，小心地把开花肠凑到嘴边，用门牙轻轻试探香肠入口是否烫嘴，还没吃到呢，就有了飘飘欲仙的感觉。一点一点地咬，香味在嘴里散开，有可口的咸甜味、辛辣的胡椒味、浓浓的五香味……每一丝味道都在刺激着我的味蕾，不折不扣的纯粹肉香让我陶醉。</p>
<p>皮儿酥里嫩，香得让我停不住嘴——吃完第一根想着第二根，吃完第二根想着第三根，吃完第三根想着第四根……不一会，开心肠实实在在地进到肚里，香味从嘴里也跑到了胃里。</p>
<p>真没想到小小的香肠能勾起了那么多吃惯大餐的城里人的胃口，也让我这个对肉食不屑一顾的人吃胖了胃。可见独特的美食藏在民间，不一定五星酒店的东西才是天下无敌。啊，爆胃的开花肠！</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>理发师的温暖</title>
    <url>/posts/fd800af5/</url>
    <content><![CDATA[<p>一个碎片将时光远处的温暖带到了我的眼前，撞开了记忆中的一扇大门。</p>
<p>头发略长，我和妈妈走进了小街上偏僻的一家理发店。忘记了店名，只记得进去的场景：白炽灯嘶嘶地响着，天花板的一角已经熏得碳黑；墙上赫然贴着的“焗油 烫发”四个大字，间架结构显得十分不自然；瓷砖抓不牢墙壁和地板，一块一块的水泥裸露着；橱柜上站着满墙的美发用品，瓶身都很干净，摆放整齐。</p>
<p>“来，先到小板凳上坐一下，给妈妈也搬一个！”响起老板开朗、自信的声音。“给妈妈也搬一个”——这显得他有些可爱，馥郁的空气增添了一番亲切。</p>
<p>终于轮到我了。“小伙，剪成什么样的？”他半张嘴，等待着回答。我的心里好像有一群乌鸦在乱飞，有些不知所措。因为我第一次向理发师提出要求：“剪短点，也不用太短。”</p>
<p>这八个字，仿佛发条，“激活”了理发师。镜子中快乐的理发推，十分肆意，像一只小羊，在原野里疯狂地吃草；忽而又变得小心翼翼，变成一只年幼的小鸡，在水泥地上啄米，啄一粒，再啄一粒。闭一会眼睛，头顶发生了什么？是暴风雨、暴风雪，是强劲的大风，还是是一群飞鸟来袭？我不知道，只觉得这变化迅速，而又丝滑。</p>
<p>睁开眼睛，我才发现他鲜红的袖章，还有胸前闪耀的名片。眯起眼睛，隐隐约约地看到“xx禁烟督导员”“xx疫情防控志愿者”几个小字。事后才知道：他出生于一个发艺家庭，从小随父理发。进城就开了这家小店，二十年来从未涨价。如今，中年的他嫌事少，报名参加督导与志愿工作。</p>
<p>我终于从他的人生中发现——正是他为人的朴实、勤劳，造就了店铺的温暖、理发店的温暖、那段时光的温暖。正是生活中渺小的人，却有着高尚的人格、品质，点点滴滴地制造温暖，包围着我们，使生活多姿而美好。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>秋天的原野</title>
    <url>/posts/10e368c/</url>
    <content><![CDATA[<p>这个秋天、这个原野，给了我许多回忆。</p>
<p>车在山间飞速地穿梭，落下窗户，勇敢地探出头——我与秋天撞个满怀。山间的早风向我泼来，给枯萎已久的肺叶酌下清凉的啤酒，一杯又一杯。</p>
<p>秋天的原野是淡泊的。天空淡蓝而宁静， 灰白的水墨成片成片地点染在上面。田地空旷无比，灰色的玉米涂上了一丝浅浅的黄，低着头伫立着，深绿发黑的长叶呆愣愣地向下凝望，留下硬邦邦的折痕。两株不高不矮的树，突兀地站着。时不时，田地里闪现出孤独的阡陌，歪歪斜斜，裂缝一般。这一切，安静地躺在路边，久久都不离开。它们不壮观，不美丽，但是静静地待着，寂静而辽远。</p>
<p>秋天的原野是悲壮的。一个巨人脸朝上倒在了地上，额头、鼻子、下巴化成了山峰，好像记载了一个生命的陨落；灰白的峭壁向前欠着身，暗黑的锐草拦腰而生“砍了一刀”，仿佛是被刺杀之前，对万物的最后凝视；公路旁的桑田沉为沧海，犹如万丈深渊，干涸的河沟里萧条地生几丛杂草、涨几凼清水。眼前的一幕幕场景如同幻灯片闪过：宁静的原野，竟发生了如此悲壮的历史巨变。</p>
<p>秋天的原野是孤独的。我有时呆呆地望着迟钝的阳光出神，路灯柱嗖嗖地飞过，近处的小丘上的树木轻轻地晃着，似乎在彼此喁喁细语。风的长吟，唱着很高的音调，震耳欲聋。远处的大山在呼吸，很轻很轻。一切都很美好，但是没有时间感觉、没有期待，只有无尽的孤独。</p>
<p>秋天的原野，失去了春夏的生机活泼，孤独、寂寥地在乡下隐居，却充满的是孤独与寂寥之美。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>认识藏在石头里的村子</title>
    <url>/posts/1371/</url>
    <content><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>在太行山脉的深处，藏着一处小山村，它被绿树掩映，被山峦环抱。弯弯曲曲的山路带着我们来到村子里，哇！这是石头的世界。</p>
<p>石楼石阁，石房石院，石桌石凳，石磨石碾，石街石巷，石桥石栏，就连村路也是古老的石头铺成的，走在上面，既新鲜好奇又畅快淋漓。小村庄就是与众不同……</p>
<p><img src="https://i.loli.net/2020/01/29/xt6QNTCAsISXd8v.jpg" alt="石头村留念"></p>
<p>石头巷子，幽深宁静，一株柿子树从院子探出头来。斑驳的石缝里镶嵌着一撮撮青苔，深绿的、浅绿的、茂盛的、干枯的。不太规整的石头，一块块垒砌便成了墙，高高的，不知道什么年代啦，反正时间离我很远很远了。</p>
<p>石碑，石阶，石桌随处可见。对联、牌匾上烙着时间的印记。大门上灰瓦搭成的飞檐顶很漂亮，特别有乡土气息，拱形门洞即可通行，又可躲在那里乘凉，不同形状和大小的石头堆在一起，那么的严丝合缝和坚固，上面的石阁历经久远，风吹雨打巍然矗立。</p>
<p>一座座石屋石院亲切而古朴，不会因为石头坚硬的质地让人感觉冰冷。于家石头村3700多米的六街七巷十八胡同，4000多间街巷串连的房屋全部都是石头的呈现。脚下踩的、屁股坐的、开荒农具、炊饮餐具、满眼看到的，都是石头做的。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>于氏石头村之行，还让我对石头有了广泛和新鲜的认识：</p>
<ol>
<li> 石头不仅可以铺路，还可以建造出独具特色的房子、院落、小桥……原以为石头必须切割才可以用做建筑，然而到了石头村才知道，用无需加工、形状不一、大小不同、颜色各异，或圆滑或棱角的石头们竟然可以造出这么坚固、历经几百年不倒的房子。</li>
<li> 石头可以谱写历史，流传文化。500年前明代重臣于谦的后人裔用朴实坚贞的石头，在荒野深山抒写下不朽的生存史诗。于家石头村，穿越岁月沧桑、代代相传，存活至今，用朴素的石头谱写了一部古村落史。</li>
<li> 石头有值得我们学习的品格和精神石——不加装饰，朴实无华；坚硬无比，历经风雨，不失本色。</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过这次的行走，我认识到真正的价值往往蕴藏在平常和朴素之中，就像石头村。虽然石头遍山都是，寻常不稀有，虽然石头没有大理石漂亮的花纹，没有建筑木材的奢华，不被建筑师宠爱，但是石头村却因为石头而闻名，因石头其村落文化才得以传承。<strong>旅行真不必死死抓住风景名胜，只要留意，身边就有许多值得走访的地方。</strong></p>
<p>于氏石头村不愧是建立在石头上的历史文化村。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>这就是我</title>
    <url>/posts/98a4c96/</url>
    <content><![CDATA[<blockquote>
<p>七年级，遇到了一位新语文老师，马老师。第一次与她邂逅，第一次写初中作文。评论谓曰：“挺会描写，赞！书写一级棒！”</p>
</blockquote>
<p>这就是我——我叫 M.T.L.。</p>
<p>至于为什么叫这个名，我已经介绍了几遍了：天就是天空，赌空万里，燕夫白云，天外有天…………说到“天”字，我突然想起了我的一特点。什么特点？就是包容他人。</p>
<p>三年前，小学教室的窗台边，坐恶着十几盆同学们捐赠的绿植，下面是接近肉色的橱柜。阳光一照，透过叶子与花，转换成一种荧光绿，写在窗台上，简直是无比的高大上。结果偏偏是张同学，搞了一盆群仙人掌，摆在窗台上，一看心里就是一块疙瘩。不过这也没办法，可是人家一片好心啊。</p>
<p>下了课，我便陪着那些植物在窗台“玩耍”——也只不过是拈花惹草。我轻轻抚摸了一遍又尖又细的刺。</p>
<p>“你敢按吗？”张同学突然出现在了我的身旁。</p>
<p>又是典型的套路。我不碰，立刻把手缩了回去。</p>
<p>结果没想到的是，张同学一时激动，抓住我的手腕使往似人掌拍了上去。结果呢？别人在上课，我只好老老实实地在教师办公室里使用镊子“挑刺”。</p>
<p>“挑刺”是一项艰巨的任务，你需要将一个小小的、细微的、白色的、仅长三毫米的救软刺从一个比刺大无数倍的巨大的手中，一个个挤出来。我突然感觉到时钟的滴答声，身上的汗水，我比时间走得还慢。不干了！我一拍桌子，手上却是难言的痛苦。只因为有老师备课，没有喊出来。我拿出抽屉里的胶带，一钻、一斯，又仿佛是受被撕没了，刺还在……</p>
<p>讲完故事后，你可猜猜课间我和张同学在假什么。打架？这是我们的对话：</p>
<p>“练一练第三题怎么做？”</p>
<p>“你方法有问题吧…………答案挺怪的。”</p>
<p>“也是。”</p>
<p>“你这行程问题用方程解得了。”</p>
<p>乍一想，包容他人不也是”天“字的含义吗？</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>网站说明书</title>
    <url>/posts/32480/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是我的个人博客网站，与2020年1月28日建成并发布。其中，我导入了一些我以前写的的优秀散文，撰写了与现在编程与反编译相关的技术文章。在这个网站中，我会给大家呈现出我的最好内容，也会分享一些好文章。博客网站是一个很有趣的东西，有了它，就有了生活感；有了它，就有了时间感；有了它，就有了幸福感；有了它，就有了存在感。</p>
<p>我离开了我的诸多博客，创建一个自己的网站，现在正式来到这里，发布第1篇（文章其实是第二篇，第一篇是关于自我介绍的）。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我从没有博客开始，搬家到微信朋友圈（更专注生活），再搬到<a href="zi.com">字里行间</a>软件（专注于写作），再搬到<a href="csdn.net">CSDN</a>（专注于研究技术），原本想定居于此，但是最近发布了一个关于破解（反编译）的技术文章，审核却没有通过，因为CSDN出的新规“暂时不允许发布破解、激活类的文章”。这样也有道理，毕竟要保护开发者的版权，避免一些人看了这些文章误入歧途，做起盗版。CSDN帮助我提升计算机技术水平，我感谢CSDN，但是这条规定却不能给我自由的空间——我想，我应该搬家了。</p>
<p>我想把博客搬到<a href="52pojie.cn">吾爱破解</a>，但是只局限于技术（吾爱破解账号现在有了：@TLHorse）；我想把博客搬到<a href="jianshu.com">简书</a>，但是养一个账号太难；我想把博客搬到<a href="blog.sina.com.cn">新浪</a>，但是根本就无法与VIP竞争；我想……无论是什么网站，都与自己的心愿差那么一点点。因此，我选择了自己建一个博客。这不仅可以提高我的写作水平，还可以练一下自己的技术。</p>
<h1 id="反馈与改进"><a href="#反馈与改进" class="headerlink" title="反馈与改进"></a>反馈与改进</h1><p>人外有人，天外有天。这个博客肯定多多少少有一些缺陷，欢迎联系我，批评指正。可能是关于：</p>
<ul>
<li>  界面不美观；</li>
<li>  界面不协调，布局不恰当；</li>
<li>  界面互动不好；</li>
<li>  文章内容需要改进；</li>
<li>  图片过期、显示不清、无法显示、显示缓慢；<br>以上只是列了几条批评指正或提出建议的方面。坐在屏幕前的你，看到哪里不顺眼，也欢迎告诉我原因、吐槽一番。</li>
</ul>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><ul>
<li>无论任何人使用文章中分享的任何技术，做任何事，所造成的刑事责任，请自行承担。</li>
<li>博客中的任何文章及其内容，仅供学习、研究、参考使用，请勿商用，否则造成的刑事责任，请自行承担。</li>
<li>博客中涉及到反编译、破解的内容，尽量进行数据脱敏处理，并旨在教会读者破解方法与心得。除特殊情况，破解后的程序不提供成品下载。</li>
<li>本博客所有文章除特别声明外，均采用<a class="link"   href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" >CC BY-SA 3.0<i class="fas fa-external-link-alt"></i></a>协议。如需转载可以联系我。文章可否转载一般会在文章中标注。</li>
</ul>
<p>最后，欢迎来到我的博客。</p>
<pre class="line-numbers language-none"><code class="language-none"> _   _      _ _    __        __         _     _
| | | | ___| | | __\ \      &#x2F; &#x2F;__  _ __| | __| |
| |_| |&#x2F; _ \ | |&#x2F; _ \ \ &#x2F;\ &#x2F; &#x2F; _ \|  __| |&#x2F; _&#96; |
|  _  |  __&#x2F; | | (_) \ V  V &#x2F; (_) | |  | | (_| |
|_| |_|\___|_|_|\___&#x2F; \_&#x2F;\_&#x2F; \___&#x2F;|_|  |_|\__,_|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>PS：如果看不清楚上面写的是什么，可以在电脑观看。  </p>
</blockquote>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>说明</tag>
      </tags>
  </entry>
  <entry>
    <title>锥体体积公式的推导</title>
    <url>/posts/3d4e0587/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>计算锥形图形的体积与其所在柱体的体积的关系，可以使用微积分法. 将锥体微分为柱体后，求积分即可. 计算表明，锥形图形的体积是其所在柱体的体积的$\frac{1}{3}$.</p>
<h1 id="写出表达式"><a href="#写出表达式" class="headerlink" title="写出表达式"></a>写出表达式</h1><p>鉴于本计算过程与锥体的棱数无关，故使用圆锥进行计算.</p>
<p>任意柱体都是底面积分得到的，可以理解为无数个底面图形微元堆叠而成的。如果柱体体积为$V$​，高为$h$​，则<br>$$<br>V_{柱体}=\int_{0}^{h} Sdx<br>$$</p>
<p>不同于柱体的是，锥体在“堆叠”的过程中，每增加一层，微元将等比例缩小一点。若缩小系数$k\in[0, 1]$​​​​​，则<br>$$<br>V_{锥体}=\int_{0}^{h} Skdx<br>$$<br>而这个缩小系数，又与堆叠到哪一层有关。如果总微元数量$n$与缩小系数$k$的函数关系为$k=\lambda(n)$​​​，则<br>$$<br>V_{锥体}=\int_{0}^{h} S\lambda(x)dx\tag{1}<br>$$</p>
<h1 id="探究缩小系数"><a href="#探究缩小系数" class="headerlink" title="探究缩小系数"></a>探究缩小系数</h1><p>已知第$n$个微元与缩小系数$k$的函数关系为$k=\lambda(n)$，总微元数为$h$（因为这个数量就是锥形的高），那么$\lambda$的解析式是什么？</p>
<p>我们根据缩小系数的定义可知，从锥形底面到锥形顶点的缩小过程中，每一个微元都与底面相似，而这个相似比（$\frac{微元}{底面}$​）的平方（即面积比）就是缩小系数.</p>
<p>进一步我们发现，相似比也等同于图形的序号之比，即$\frac{n_{微元}}{n_{底面}}$​。但是，我们需要令较小的序号除以较大的序号，因此这个序号是从顶部标到底部的。所以图形微元的序号应当被总图形微元数减去.</p>
<p>$\therefore$对于第$n$个图形，有<br>$$<br>\lambda(n)=\left(\frac{h-n}{h-0}\right)^{2}=\left(\frac{h-n}{h}\right)^{2}\tag{2}<br>$$</p>
<h1 id="计算积分"><a href="#计算积分" class="headerlink" title="计算积分"></a>计算积分</h1><p>将$(2)$中的$n$替换为$x$，带入$(1)$​可得：<br>$$<br>V_{锥形}=\int_{0}^{h} S\left(\frac{h-x}{h}\right)^{2}dx<br>$$<br>先计算不定积分：<br>$$<br>\begin{align}<br>\int S\left(\frac{h-x}{h}\right)^{2} &amp;= S\int\left(\frac{h-x}{h}\right)^{2}dx \<br>&amp;= S\int\frac{h^2-2hx+x^2}{h^2}dx \<br>&amp;= \frac{S}{h^2}\int{(h^2-2hx+x^2)dx} \<br>&amp;= \frac{S}{h^2}\int{h^2dx}-\int{2hxdx}+\int{x^2dx} \<br>&amp;= \frac{S}{h^2}\left(h^2x-hx^2+\frac{x^3}{3}\right) \<br>&amp;= \frac{3Sh^2x-3Shx^2+Sx^3}{3h^2}<br>\end{align}<br>$$<br>写上积分极限，计算定积分：<br>$$<br>\begin{align}<br>\left.\frac{3Sh^2x-3Shx^2+Sx^3}{3h^2}\right|<em>0^h &amp;= \frac{Sh}{3}<br>\end{align}<br>$$<br>故$V</em>{锥形}=\frac{Sh}{3}$​.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>微积分</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>迅雷Hopper逆向初尝试</title>
    <url>/posts/19263/</url>
    <content><![CDATA[<blockquote>
<p>破解目标：迅雷v3.0.9，登陆即是会员！  </p>
</blockquote>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>这也不是第一次想着进行破解二进制了。以前用过IDA、OD、010等软件，才知道，破解既困难，又有趣。</p>
<p>为什么我要用Hopper Disassembler进行破解？因为Hopper是一款针对Mac&amp;Unix类系统的破解软件；那为什么又要选择迅雷呢v3.0.9.2892？我浏览过迅雷的所有版本，只有这个版本的迅雷是一个难度适中、易破解、成就感高而又实用的App。所以，今天写一篇破解迅雷v3.0.9的详细笔记，分享给大家。</p>
<p>但是——也确实是这样——总有那么些人通过不法方式修改别人的东西，我就很讨厌这类人。因此，<strong>此篇文章仅供研究学习，切勿商用或者广泛传播，否则后果自负</strong>！</p>
<blockquote>
<p>注：网站里的图片点开即可查看大图。</p>
</blockquote>
<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><ol>
<li> <a class="link"   href="https://www.hopperapp.com/" >Hopper Disassembler<i class="fas fa-external-link-alt"></i></a>，逆向工程工具，可让反汇编，反编译和调试应用程序。</li>
<li>迅雷（Thunder）v3.0.9.2892。以下迅雷简称XL。<a class="link"   href="http://down.sandai.net/mac/thunder_3.0.9.2892.dmg" >官方下载链接<i class="fas fa-external-link-alt"></i></a></li>
<li>一台Mac或iMac，能不用虚拟机就不用。最好是MacOS Catalina，为了保证Hopper与XL的正常运行。（其实Hopper也有Linux版本，但在虚拟机下不太好使）</li>
<li>思路清晰且冷静的大脑。</li>
</ol>
<h1 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h1><h2 id="导入分析"><a href="#导入分析" class="headerlink" title="导入分析"></a>导入分析</h2><p>首先，我们从应用程序里找到<code>Thunder</code>这个App，右键——显示包内容，之后进入目录<code>/Contents/MacOS</code>，可以找到<code>Thunder</code>这个可执行文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/find-exec.png" alt="查找可执行文件"></p>
<p>这个可执行文件包括着整个App的运行逻辑、顺序、程序等等内容，但是不包括应用的资源。这个文件就是应用运行的关键，也是我们破解的关键。</p>
<p>接下来，我们打开Hopper。进入应用界面后，把可执行文件拖拽到界面的中间部分。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-drag-analysis.png" alt="拖动"></p>
<p>接下来，Hopper会弹出提示，保持默认，一路OK即可。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-warning.png" alt="提示框"></p>
<p>等着进度条走完（观察窗口右下角的<code>Working</code>字样）。像迅雷这样的小软件，2秒钟就够了。接下来，一幅宏伟壮丽的景象会出现在你眼前。<br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-main-ui.png" alt="主页面"></p>
<p>这是Hopper的主页面。分为5个部分：上面是工具条：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-toolbar-usage.png" alt="工具条用法"></p>
<p>左边是搜索区，可以搜索函数、字符串、星标代码等；中间是主要工作区域，里面包含的内容可以通过工具条中按键调整；右边是检索区，可以设置/预览中间的内容，跟Xcode的检索区差不多；下面是Python控制台，可以输入命令操作反编译。</p>
<p>就先不多讲Hopper的使用了，有机会放在别的文章阐述。接下来，进入主题，开始破解！</p>
<h2 id="查找可能的函数"><a href="#查找可能的函数" class="headerlink" title="查找可能的函数"></a>查找可能的函数</h2><p>迅雷想要验证是否是会员，肯定得有函数。按照程序猿千古流传的命名习惯，不用想就猜得到函数名：<code>isVip</code></p>
<p>打开Hopper左边的搜索栏，上面的选择器选<code>Proc.</code>，就是搜索函数。然后搜索<code>isVip</code>，搜索出来，完全包含这个名字的函数有三个：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/search-isvip.png" alt="搜索 isvip"></p>
<p>我们先点开第一个（汇编指令区就会出现），然后在蓝色的那一栏单击，标“星”，方便以后查找。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/choose-and-add-star.png" alt="标星"></p>
<p>接着，点开剩下两个，进行同样的标“星”操作。注意看图中的标“星”位置。<br>现在，清空搜索框，然后在选择其中选择“星”：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-star-func.png" alt="选择标星的一栏"></p>
<p>好了！查找完了！</p>
<h2 id="汇编思路"><a href="#汇编思路" class="headerlink" title="汇编思路"></a>汇编思路</h2><p>首先点开第一个（一长串的），然后参照<code>按键作用解释</code>那幅图，打开伪代码。类似OC伪代码应该如下：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class ___4X2XLXH3O3STBRATSECONDT7R3OL4L34E1R___ *&#x2F;
-(char)isVip &#123;
    rbx &#x3D; [[UserController defaultUserController] retain];
    r14 &#x3D; [rbx isVip];
    [rbx release];
    rax &#x3D; sign_extend_64(r14);
    return rax;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然我不太懂OC，但是大致可以看出是一个函数，最后返回了<code>rax</code>。那<code>rax</code>是什么？</p>
<blockquote>
<p>AX(AH、AL)：累加器。有些指令约定以AX(或AL)为源或目的寄存器。输入/输出指令必须通过AX或AL实现，例如：端口地址为43H的内容读入CPU的指令为INAL，43H或INAX，43H。目的操作数只能是AL/AX，而不能是其他的寄存器；<br>BX(BH、BL)：基址寄存器。BX可用作间接寻址的地址寄存器和基地址寄存器，BH、BL可用作8位通用数据寄存器；<br>CX(CH、CL)：计数寄存器。CX在循环和串操作中充当计数器，指令执行后CX内容自动修改，因此称为计数寄存器；<br>DX(DH、DL)：数据寄存器。除用作通用寄存器外，在1/O指令中可用作端口地址寄存器，乘除指令中用作辅助累加器；<br>EAX、ECX、EDX、EBX：ax、bx、cx、dx的延伸，各为32位元。  </p>
</blockquote>
<p>那么，这个函数最终会被<code>return rax</code>，而rax是真是假取决于账号，怎么办呢？思路：我们只需强制把<code>rax</code>换成真（代表着用户是会员），然后终止下面的进程就可以了！</p>
<h2 id="修改程序"><a href="#修改程序" class="headerlink" title="修改程序"></a>修改程序</h2><ol>
<li> 把光标放在第一行（<code>push</code>的位置），按下<kbd>option</kbd>+<kbd>a</kbd>（或者到顶部Modify &gt; Assemble Instruction），输入如下代码：<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov rax, 0x1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>为什么这样改：mov是数据转移指令，这个操作会把0x1这个数据转移给rax，这样rax就被我们强制设为真了。  </p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-1.png" alt="修改1"></p>
<ol>
<li> 回车，输入<code>ret</code>。<br>为什么这样改：<code>ret</code>是<code>return</code>的缩写，意为“结束子程序并返回到主程序“，因此，这下面其他的乱七八糟的没用指令都不会运行了。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-2.png" alt="修改2"></p>
<ol start="2">
<li> 点击屏幕任意地方，关掉修改弹窗。下图为修改后：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-changed.png" alt="修改后"></p>
<p>这样，这个函数就被我们修改完了！用同样的方法，把剩下两个函数也修改成这样（patch）即可。</p>
<h2 id="有自校验，但是一碰就碎"><a href="#有自校验，但是一碰就碎" class="headerlink" title="有自校验，但是一碰就碎"></a>有自校验，但是一碰就碎</h2><p>自校验，顾名思义就是自己看自己，有没有什么毛病。程序当然也会这样啊，如果看到自己的五脏六腑都移位了，就不会给你运行。当然，还有许多程序保护机制，比如防<code>hook</code>、反调试。</p>
<p>接下来我们就要关闭这个系统。首先，做过苹果开发的都知道，在程序启动将要完成时，<code>AppDelegate</code>中的<code>applicationWillFinishLaunching</code>函数会运行。也就是说，迅雷想要启动时自检，必须通过这个函数。我们只要把这个函数里的脚本禁了就行了。</p>
<p>老样子，搜索<code>appdelegate applicationWillFinishLaunching</code>（无需区分大小写）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-search-anticrack.jpg" alt="搜索校验"></p>
<p>单击打开，然后选择函数的第一行，<kbd>option</kbd>+<kbd>a</kbd>修改，直接输入<code>ret</code>禁用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-change-anticrack.png" alt="修改自校验"></p>
<p>修改后：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-changed-anticrack.png" alt="去除自校验代码"></p>
<p>——一碰就碎！</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ol>
<li><p> 按下<kbd>control</kbd>+<kbd>shift</kbd>+<kbd>E</kbd>。</p>
</li>
<li><p> 在新弹出的窗口中，选择<code>Remove Signature</code>移除签名。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-rm-sign.png" alt="移除签名"></p>
<ol start="3">
<li> 在接下来的提示小窗中，选择保存位置，名字还是<code>Thunder</code>，如果Hopper给你加了类似<code>.exe</code>的后缀，那么一定要<strong>去掉后缀名</strong>。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-save-exec.png" alt="保存"></p>
<ol start="4">
<li> 用新的可执行文件替换掉旧的<code>Thunder</code>。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-exec-replace.png" alt="替换"></p>
<p>经过了这么多的操作，替换成功！</p>
<h1 id="破解完工"><a href="#破解完工" class="headerlink" title="破解完工"></a>破解完工</h1><p><strong>以非VIP的身份登陆迅雷</strong>，验证成果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-xl-crack-done-1.png" alt="破解成功1"><br><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-xl-crack-done-2.png" alt="破解成功2"></p>
<p><strong>欢呼吧！</strong></p>
<blockquote>
<p><strong>此篇文章仅供研究学习，旨教给读者修改程序的方法，切勿商用或者广泛传播，否则后果自负！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>院落伴我远行</title>
    <url>/posts/62d8e15f/</url>
    <content><![CDATA[<p>我们家的奢侈，不在于西洋家具，不在于开阔视野，不在于现代艺术，也不在于高端科技。但是，在高楼耸立、跟电梯打交道的今天，能有一个陪伴我13年的小院子，自然、古朴、清闲，我已经很知足了。</p>
<p>这个小院，竟牵起我的不少思绪，教会我不少道理。</p>
<p>与我同庚的房子并不豪华，当我寻思何要执着于此，我看见窗外：院落成矩形，比我矮的原木栅栏，一面贴墙，三面正巧框住家门和客厅的窗户，家门正对的栅栏开着一个小门。牡丹与海棠在这里挥洒笔墨；成片的绿草占了半个院子；攀着葡萄架的凌霄一树两用，春夏作蚂蚁蜜蜂之美食，秋冬作无家麻雀之鸟巢；<u>最具有特色的是一条小河连接的“南湖北湖”，鱼儿潜跃，由南湖水泵驱动的北湖瀑布“倾泻而下”</u>，仿木的小桥横跨而过，构成一种闲情逸致、自然的景观美。</p>
<p>我九十岁的一次冬月中旬，院子里洗车水枪被盗，我为院子安防干着急，想换上铁栅栏。妈妈指了指：院门只有简单的门闩，从外面就可以伸手打开。即使是小孩也可以轻松地窥进院里的景色，流浪的小猫小狗也可以从栅栏随随便进进出出。被盗的只是一个水枪，<strong>院里春色既然关不住，那何必要关呢？</strong></p>
<p>2019年冰冻的前一夜，因为种种原因，我们忘记把室外的鱼转移到室内的鱼缸里。第二天早上，池水出乎意料全部结冰，<u>所有的鱼儿被定格成了冰雕，姿态不一，有的仿佛飘逸的仙人，有的仿佛挣扎于绝境。</u>我一时不知是喜是悲，直到妈妈走进，才哭出声来。鱼儿们的结局，是我记忆中的一个断片，一片空白，但我至今想起都追悔莫及，<strong>是我没有尽到责任。</strong>自此，我家永不养鱼。</p>
<p>这个小院落，正在经受着时光的冲刷：夏天蚊子过多，池水被抽干；上了初中，只能一周见一次；院内的角角落落，也日渐腐朽……<strong>但院落确乎如母亲一般，偷偷在游子的行囊中，塞满了生活必需品。</strong></p>
<p>它与我的故事，将是一段永恒的记忆。</p>
<h1 id="阅读题"><a href="#阅读题" class="headerlink" title="阅读题"></a>阅读题</h1><ol>
<li><p>文中第二自然段起到了什么作用？（2分）</p>
</li>
<li><p>第二自然段“思绪”“道理”在文中指的是什么？（3分）</p>
</li>
<li><p>赏析文中划线的句子。<br>(1) <u>最具有特色的是一条小河连接的“南湖北湖”，鱼儿潜跃，由南湖水泵驱动的北湖瀑布“倾泻而下”。</u>（3分）</p>
<p>(2) <u>所有的鱼儿被定格成了冰雕，姿态不一，有的仿佛飘逸的仙人，有的仿佛挣扎于绝境。</u>（3分）</p>
</li>
<li><p>第一自然段中，“我已经很知足了”，为什么？（2分）</p>
</li>
<li><p>如何理解第六自然段的“但院落确乎如母亲一般，偷偷在游子的行囊中，塞满了生活必需品”一句？（4分）</p>
</li>
<li><p>文中“它与我的故事，将是一段永恒的记忆”。在你的生活中，是否也有伴你远行的信物或者回忆？按照本文的形式，简单说说，100字左右。（6分）</p>
</li>
</ol>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol>
<li>承上启下。承接上文“介绍小院子”，引出并概括下文“小院子教会我的道理”。<strong>解析：本题比较简单，回答关系后，再展开说即可。</strong></li>
<li>（1）品味生活真味比执着于“表面豪华”更好（2）不要过于吝啬，要学会分享（3）要对自己所爱的事物负责任。<strong>解析：关键在于总结3～5段所表达的思想，一条一分，相对简单。</strong></li>
<li>赏析题<ol>
<li>使用夸张和幽默的写作手法，将池子说成湖，体现出小小院落在作者心里所占的空间之大，表达出作者对院落以及院落水景的喜爱之情。<strong>解析：指出手法，写出手法直接作用，最后点名中心即可。</strong></li>
<li>使用比喻的手法，将冰冻的鱼儿比喻成仙人，写出冰冻下鱼儿飘逸的特点，侧面反映出作者内心的一片空白，表达出作者对鱼儿的喜爱与惋惜，以及对自己不负责任的痛心疾首之情。<strong>解析：比喻很好判断，关键是这里的感情一定要联系上下文体会，一条一分。</strong></li>
</ol>
</li>
<li>因为别人都在高楼大厦居住，很少能接近自然，然而我却得以在院子中畅游。<strong>解析：答出别人与我两点即可。</strong></li>
<li>使用了比喻的手法，意思是说院落像母亲一样，在作者变得繁忙、与院子疏远之际，不知不觉在我的记忆中，填充了难忘的回忆与做人道理，与我同行，伴我终生。<strong>解析：理解题关键要把每一个词语解释出来。</strong></li>
<li>略</li>
</ol>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>青春岁月，我与11点相约</title>
    <url>/posts/19eed9be/</url>
    <content><![CDATA[<p>晚上11点到了。</p>
<p>我钻在被窝里，脑子里昏昏沉沉，却浑身上下暖暖和和。屋内屋外仿佛凝成了一锭墨块，深沉得化不开。钟表里的指针在角落中无声地旋转着，没有给谁看的意思。夜灯在隐秘的角落孤独地闪烁着昏黄的灯光，也快睡着了。台灯是冰冷的；桌子早就入睡了，一动不动地沉寂着；铅笔、橡皮和几册童话仿佛是它的孩子，也盖着被子。</p>
<p>又是一个晚上11点，除夕晚上。</p>
<p>这次我是在客厅，大脑极度兴奋，我一边看着《春节联欢晚会》，一边朝着寒假作业上划拉。这是我第一次目睹临近午夜的表盘长什么样。客厅里灯火通明，昔日清净的土地，现在几乎变成一块舞池。电视闪烁着刺眼的霓虹，一颗颗像素仿佛小精灵，从屏幕中跳跃出来，再钻进瞳孔里。爸爸和妈妈反倒不如以往兴奋了，耷拉着头，盯着手机，诶、诶地回答着我的问题。我本打算跟风“跨年”，但是想到小孩熬夜不好，忍不住，还是躺到床上进入梦乡。</p>
<p>晚上11点悄然而至。</p>
<p>黑暗的书房，只有台灯与我。虽然那灯不怎么亮，却如同一颗恒星，指使我坚持下去。下面是作业与书本，我将自己埋在其中，丝毫没有察觉周围的变化。我不知道它们有多少，但是，一字落笔，我又将任务推进了百分之一。笔尖走过的地方，笔迹龙飞凤舞却不见脏乱差；手未经过的题目，一个个括号仿佛一张张饥饿的嘴巴，等着我塞满；我迫不及待将它们填上，更有一种爽快之感。</p>
<p>抬起头来，钟表上只剩下的一根指针，着实让我吓了一跳。</p>
<p>这些所有我经历过的11点，仿佛历经沧桑的皱纹，愈发清晰。这些过往，从稚嫩到成熟，见证了我生活的一点一滴。</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>记叙</tag>
      </tags>
  </entry>
  <entry>
    <title>硬核输密码</title>
    <url>/posts/a942e651/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写文章了，今天输出一篇。首先，为了防止误判我是标题党，先解释一下在这篇文章里我要做什么。</p>
<p>以前我在<a class="link"   href="https://www.52pojie.cn/thread-1132170-1-1.html" >《【Mac】一次意外的 CleanMyMac X 破解》<i class="fas fa-external-link-alt"></i></a>里破解过CleanMyMac X（注：这篇帖子已被移动），但是最近CleanMyMac X更新，所以我便把旧版本的CMM删除了，下载了新版本4.6.7的CMM。结果不破不知道，一破吓一跳，动态库注入破解，破解倒是成功了，但是可能因为签名等问题，CMM总会在清理时不断地让我输入root密码，获取我的权限，尽管我已经赋予了CMM完全磁盘访问权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/6/29/pwd-enter-box.jpg" alt="不断要求输入密码"></p>
<p>尝试过的解决方法：</p>
<ul>
<li><del><code>codesign -f -s - --deep /Applications/CleanMyMac\ X.app</code></del></li>
<li><del><code>AppleScript</code></del></li>
<li><del>每一次都手动输一遍密码</del></li>
<li><del>更换破解框架</del></li>
</ul>
<p>都不行。所以我准备写一段<code>Python</code>脚本，模拟键盘和鼠标，每当输入密码框弹出来时，自动输入密码并确认，你可以理解为一个轻量级的按键精灵。</p>
<h1 id="0x1-编写代码"><a href="#0x1-编写代码" class="headerlink" title="0x1 编写代码"></a>0x1 编写代码</h1><p>首先使用<code>pip install pyuserinput</code>安装<code>PyUserInput</code>，然后导入。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pymouse import PyMouse
from pykeyboard import PyKeyboard

# 定义键盘和鼠标实例
m &#x3D; PyMouse()
k &#x3D; PyKeyboard()

def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)):
    &#39;&#39;&#39;
    将输入密码流程封装成函数
    &#39;&#39;&#39;
    global m, k
    m.click(pos[0], pos[1])
    k.type_string(pwd)
    m.click(enter_bt_pos[0], enter_bt_pos[1])

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    enter_pass(pwd&#x3D;&quot;password123&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中输入框位置(1322, 705)和确认键位置(1425, 759)是我通过macOS自带的截图工具<kbd>Command+Shift+5</kbd>获取的。</p>
<p>之后我们打开CMM，选择操作&gt;身份验证，然后会弹出一个“安装帮助程序”的弹窗，运行脚本——你会发现，确认键成功被点击，但是脚本却没有成功输入密码。</p>
<h1 id="0x2-绕过漏洞"><a href="#0x2-绕过漏洞" class="headerlink" title="0x2 绕过漏洞"></a>0x2 绕过漏洞</h1><p>研究了一番后，发现输入密码弹框属于系统层程序，因此无法模拟键盘输入（顺便提一下，<code>PyUserInput</code>是通过<code>pyobjc</code>调用<code>Objective-C</code>代码模拟的）。又试了试，发现密码弹窗有一个漏洞，那就是可以进行粘贴操作（不能复制）。怎么办呢？我们的新思路就是使用<code>pyperclip</code>框架先复制密码，然后点击文本框，再模拟键盘进行<kbd>Command+V</kbd>粘贴操作。</p>
<p>代码改写如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from pymouse import PyMouse 
from pykeyboard import PyKeyboard 
import pyperclip as clip 
 
m &#x3D; PyMouse() 
k &#x3D; PyKeyboard() 
 
def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)): 
    global m, k 
    clip.copy(pwd) 
    m.click(pos[0], pos[1]) 
    k.press_keys([&#39;Command&#39;, &#39;V&#39;])  # 快捷键组合函数
    m.click(enter_bt_pos[0], enter_bt_pos[1]) 
 
if __name__ &#x3D;&#x3D; &#39;__main__&#39;: 
    enter_pass(pwd&#x3D;&quot;password123&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="0x3-优化速度"><a href="#0x3-优化速度" class="headerlink" title="0x3 优化速度"></a>0x3 优化速度</h1><p>上面的脚本运行后发现一切很好，但是太慢，原因是<code>pyperclip.copy()</code>占用的时间太长。怎么办呢？我便把<code>clip.copy(pwd)</code>改成了：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">if not clip.paste() &#x3D;&#x3D; pwd:
    clip.copy(pwd)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>检测剪贴板和密码是否相同，如果相同，就不复制了。效果还不错呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/6/29/pwd-enter-vid.gif" alt="效果"></p>
<h1 id="0x4-检测弹窗"><a href="#0x4-检测弹窗" class="headerlink" title="0x4 检测弹窗"></a>0x4 检测弹窗</h1><blockquote>
<p><strong>你坑谁呢？难道每一次弹出密码窗口时我都要运行一遍脚本？</strong></p>
</blockquote>
<p>对于以上问题，我准备使用<code>PIL.ImageGrab</code>来不断捕捉屏幕，如果识别到弹窗，再运行<code>enter_pass:pos:enter_bt_pos:</code>函数。代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import ImageGrab
from pymouse import PyMouse 
from pykeyboard import PyKeyboard 
import pyperclip as clip 
 
m &#x3D; PyMouse() 
k &#x3D; PyKeyboard() 
 
def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)): 
    global m, k 
    if not clip.paste() &#x3D;&#x3D; pwd: 
        clip.copy(pwd) 
    m.click(pos[0], pos[1]) 
    k.press_keys([&#39;Command&#39;, &#39;V&#39;]) 
    m.click(enter_bt_pos[0], enter_bt_pos[1]) 
 
if __name__ &#x3D;&#x3D; &#39;__main__&#39;: 
    print(&quot;Start grabbing:&quot;) 
    while True: 
        screen &#x3D; ImageGrab.grab().convert(&#39;RGB&#39;) # 捕捉屏幕
        print(f&quot;Screen grabbed.&quot;) 
        colorls &#x3D; screen.load() # 加载数据
        # 判断像素
        if colorls[2222, 1478] &#x3D;&#x3D; (236, 236, 236) and colorls[2153, 1206] &#x3D;&#x3D; (236, 236, 236):
            # 输入密码
            enter_pass(pwd&#x3D;&quot;password123&quot;)
            print(&quot;Password entered.&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，我们的自动填充密码脚本便编写完了。</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import ImageGrab
from pymouse import PyMouse
from pykeyboard import PyKeyboard
import pyperclip as clip

m &#x3D; PyMouse()
k &#x3D; PyKeyboard()

def enter_pass(pwd: str, pos&#x3D;(1322, 705), enter_bt_pos&#x3D;(1425, 759)):
    global m, k
    if not clip.paste() &#x3D;&#x3D; pwd:
        clip.copy(pwd)
    m.click(pos[0], pos[1])
    k.press_keys([&#39;Command&#39;, &#39;V&#39;])
    m.click(enter_bt_pos[0], enter_bt_pos[1])

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    no_passbox_count &#x3D; 0
    idx &#x3D; 1
    print(&quot;Start grabbing ------&quot;)
    while True:
        if no_passbox_count &gt; 4: break
        screen &#x3D; ImageGrab.grab().convert(&#39;RGB&#39;)
        colorls &#x3D; screen.load()
        if colorls[2222, 1478] &#x3D;&#x3D; (236, 236, 236) and colorls[2153, 1206] &#x3D;&#x3D; (236, 236, 236)
            enter_pass(pwd&#x3D;&quot;password123&quot;)
            print(&quot;Password entered.&quot;)
            no_passbox_count &#x3D; 0
        else:
            no_passbox_count +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行此<code>Python</code>脚本，之后启动 CleanMyMac X 清理，你就能看到脚本自动为你输密码的壮观景象了。由于截图时延迟比较大，在1秒左右，因此清理运行下来大概需要五分钟……</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>还是<del>去下载别人家的破解</del>买正版软件更好 : )</p>
<blockquote>
<p>如果贴友们有更好的方法解决 CleanMyMac 频繁让输入密码的问题（例：<code>codesign</code>），请跟帖留言。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>餐桌上</title>
    <url>/posts/141ccd9c/</url>
    <content><![CDATA[<p>我家的餐桌与我同庚，陪伴了我12年。这餐桌倒是挺大，阔气地一站，就占据了大半个厨房。然而样式却与别人家的大不相同。别人家是矩形的，我家却是圆形的；别人家的有四条腿，我家的却只有一条腿；别人家的高端大气时尚，而我家的桌边上仍挂着老掉牙的欧式木刻，里头绽开着一朵朵玫瑰。围在这餐桌旁的，似乎永远是那三个人：爸爸妈妈和我。</p>
<p>“餐桌上”似乎是这么一番情景：孩子被宠在爸爸妈妈中间，餐盘里不减反增。餐桌座次是一成不变的，爸爸在中间，妈妈守在左边，我守在右边：一是因为爸爸是家里的大国宝，固然要守着他；二是为了让爸爸从酒的陶醉中走出来。</p>
<p>饭点到了。随着爸爸的一声“用膳”，我和妈妈得到了暗号，动起筷来。餐桌上的菜主要以清淡为主，很少有大鱼大肉。粥是平白的，但开胃润肠； 菜是朴素的，但清淡香甜；姜是麻辣的，但解表散寒；豆是没味的，但营养丰富；一桌简朴的饭菜，一家独有的温馨。</p>
<p>饭点过了。餐桌上，一张张盘子浅了下去；桌上罩着的那层玻璃，映着天花板的亮光。妈妈将一只只空荡荡的盘子洗了去，我把吃剩的肉一块块挑到纸盒里，抱到院子里。栖息在葡萄架子上的那家喜鹊，看到纸盒，如下雨般落一群鸟围过去，享受饕餮大餐；数秒后，它们飞上架子，又一波鸟儿围下来，轮流不断……</p>
<p>餐桌上，是父母对我的关爱；餐桌上，是饭菜对我的给养；餐桌上，还是我对众生的博爱；餐桌上，是一家独有的温馨。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>秋日印象</title>
    <url>/posts/11f2f562/</url>
    <content><![CDATA[<blockquote>
<p>在一个常见的石家庄雾霾冬日，有感而发，拿来写学校随笔。</p>
</blockquote>
<p>走在通往小学的路上，我总是这样想：秋天，无论在什么地方总是最好的；可是啊，如今北国的秋，却特别地来的清、来得静，来得平淡，来得荒凉。</p>
<p>当茫茫夏日还沉醉于灼烧大地时，空中飘着的孤云看不惯了，便想挫一挫夏的锐气。它呼朋引伴：第一天还是它自己，第二天两朵云，第三天是三朵……日复一日，天被云层塞满了。用手遮住层层叠叠的楼宇，站在大街上，仰望着——那简直不是天，而是一张纯净的素描纸，一块巨大的电脑屏幕，一堵无边的石灰墙壁；灰得是那样朴素，白得是那样结实。</p>
<p>可惜“孤云”和他的朋友们仅仅想借此对夏日表示抗议，并非为地面上的众生带来好处。他们日复一日赖在天上，篡夺了玉皇大帝的王位，又对地面实施残暴统治：绿在一天天褪去，花朵开始蜷缩，鸟准备远离，连屋里的墙皮都抽巴抽巴的，好像是受着了惊吓，皱起了眉头。“国王”将一个个丧失人性的政策实施，聪明的人类却不管不顾。城外去，发电厂的大烟囱还在嘟嘟响，拿着颜料涂抹天空；高架桥上，一辆辆来回穿梭的棺材，震聋了人们的耳朵；电视塔顶，一束束电磁波仿佛喷涌而出，散布到四面八方，充斥着整个天空，若隐，若现……</p>
<p>可是人的智慧再”厚“，终究厚不过云层。白色染料、振聋发聩的棺材声、幽灵般的电磁波，日复一日，年复一年，在天与地的挤压中发着酵……最终，它们钻进管道，钻进房屋，钻进每个人的身子里。</p>
<p>时至今日，我依旧相信，”秋天，无论在什么地方总是最好的。“那个美丽的秋天，并非存在于记忆，只是躲到某一个角落里罢了。只希望日益减少的灰色，能将秋高气爽、金风玉露请回我们的生活当中。</p>
<p>我爱你，秋天！</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>描写</tag>
      </tags>
  </entry>
  <entry>
    <title>你没看错：动手开发GUI简单操作系统（二）</title>
    <url>/posts/b833a77e/</url>
    <content><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ol>
<li>编写GDT</li>
<li>切换到32位保护模式（32-bit protected mode，又叫PM）</li>
</ol>
<blockquote>
<p>我突然发现写到第二篇文章就难以启齿了，因为切PM、加载内核这些东西几乎是环环相扣的，有一点差错都不行。</p>
<p>另外劝大家一定要学好英文，怎么着也得七八千词汇量吧。</p>
</blockquote>
<h1 id="编写GDT"><a href="#编写GDT" class="headerlink" title="编写GDT"></a>编写GDT</h1><p>GDT是最难理解的部分，却不可避免，不好意思，我这次又整了一大段理论写在这里。我觉得下面说的还算比较全吧，如果我一下引入那么多名词，我都难以下笔。但是，必须看，如果实在读不进去，看<strong>加粗字体</strong>：</p>
<h2 id="认识全局描述符表"><a href="#认识全局描述符表" class="headerlink" title="认识全局描述符表"></a>认识全局描述符表</h2><blockquote>
<p>为了行文方便，下文使用缩写。</p>
<table>
<thead>
<tr>
<th align="center">中文名称</th>
<th>英文名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">全局描述符表</td>
<td>Global Descriptor Table</td>
<td>GDT</td>
</tr>
<tr>
<td align="center">保护模式</td>
<td>Protected Mode</td>
<td>PM</td>
</tr>
<tr>
<td align="center">真实模式</td>
<td>Real Mode</td>
<td>RM</td>
</tr>
</tbody></table>
</blockquote>
<p>GDT在PM下，是一个重要的必不可少的数据结构。</p>
<p>为什么要有GDT？我们首先考虑一下在RM（就是切PM之前）下的编程模型：在RM下，我们对一个内存地址的访问是通过<code>Segment:Offset</code>的方式来进行的，其中Segment是一个段的基地址，一个Segment的最大长度是64KB，这是16位系统所能表示的最大长度。而Offset则是相对于此段基地址的偏移量。<strong>基地址+偏移就是一个内存绝对地址。</strong></p>
<p>由此，我们可以看出，一个段具备两个因素：基地址和段的最大长度。而对一个内存地址的访问，则是需要指出两点：</p>
<ol>
<li>使用的是哪个段；</li>
<li>相对于这个段基地址的偏移：这个偏移应该小于此段的最大长度。</li>
</ol>
<p>当然对于16位系统，最大长度不用指定，默认为最大长度64KB，16位的便宜也永远不可能大于最大长度。而我们在实际编程的时候，使用16位段寄存器CS，DS，SS来指定段，CPU将段寄存器中的数值向左偏移4位，放到20位的地址线上就成为20位的基地址。</p>
<p>到了PM，内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的。也就是说，PM的内存管理模式事实上是：纯段模式和段页式。进一步说，段模式是必不可少的，而页模式则是可选的——如果使用页模式，则是段页式；否则这是纯段模式。</p>
<p>既然是这样，我们就先不去考虑页模式。对于段模式来讲，访问一个内存地址仍然使用Segment:Offset的方式，这是很自然的。由于PM运行在32位系统上，那么Segment的两个因素：基地址和最大长度也都是32位的。IA-32允许将一个段的基地址设为32位所能表示的任何值（最大长度则可以被设为32位所能表示的2<sup>12</sup>的整数倍的任何值），而不像RM下，一个段的基地址只能是16的倍数（因为其低4位是通过左移运算得来的，只能为0，从而达到使用16位段寄存器表示20位基地址的目的），而一个段的最大长度只能为固定值64KB。</p>
<p><strong>另外PM顾名思义，就是为段访问提供了保护机制</strong>，也就说一个段的描述符需要规定对自身的访问权限（Access）。所以在PM下，对一个段的描述则包括3方面因素：Base Address（基地址）、Limit（最大长度）、Access（访问权限），它们加在一起被放在一个64位长的数据结构中，被称为段描述符。这种情况下，如果我们直接通过一个64位段描述符来引用一个段的时候，就必须使用一个64位长的段寄存器装入这个段描述符。Intel为了保持向后兼容，但将段寄存器仍然规定为16位（尽管每个段寄存器事实上有一个64位长的不可见部分，但对于编程人员来说段寄存器就是16位的），那么很明显，我们无法通过16位长度的段寄存器来直接引用64位的段描述符。怎么办？<strong>解决的方法就是把这些长度为64位的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用（事实上，是将段寄存器中的高13位的内容作为索引）。</strong></p>
<p><strong>——这个全局的数组就是GDT。</strong>事实上，在GDT中存放的不仅仅是段描述符，还有其它描述符，它们都是64-bit长，我们随后再讨论。GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，C<strong>PU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器<code>gdtr</code>用来存放GDT的入口地址</strong>。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDT是PM所必须的数据结构，也是唯一的——不应该，也不可能有多个GDT。</p>
<p>另外，正像它的名字Global Descriptor Table所揭示的，它是全局可见的，对任何一个任务而言都是这样。除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT，但与GDT不同的是，<strong>LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。</strong></p>
<p><strong>另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。</strong>IA-32为LDT的入口地址也提供了一个寄存器LDTR，因为在任何时刻只能有一个任务在运行，所以<strong>LDT寄存器全局也只需要有一个</strong>。如果一个任务拥有自身的LDT，那么当它需要引用自身的LDT时，它需要通过LLDT将其LDT的段描述符装入此寄存器。</p>
<p>LLDT指令与LGDT指令不同的是，LGDT指令的操作数是一个32位的内存地址，这个内存地址处存放的是一个32位GDT的入口地址，以及16位的GDT最大长度。而LLDT指令的操作数是一个16位的选择子，这个选择子主要内容是：<strong>被装入的LDT的段描述符在GDT中的索引值</strong>——这一点和刚才所讨论的通过段寄存器访问段的情况是一样的。</p>
<p>现在你知道为什么要有GDT了吧……</p>
<h2 id="GDT结构"><a href="#GDT结构" class="headerlink" title="GDT结构"></a>GDT结构</h2><p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-table.png" alt="gdt结构"></p>
<p>这是GDT的结构。其中Flags和Access Byte部分又分为如下表格：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-detail.png" alt="gdt详细"></p>
<h2 id="编写GDT-1"><a href="#编写GDT-1" class="headerlink" title="编写GDT"></a>编写GDT</h2><p>我们先讲讲上面两个图每一项都代表什么，并且应该设置什么值。</p>
<table>
<thead>
<tr>
<th align="left">图中标签</th>
<th>中文</th>
<th>英文</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Pr</td>
<td>展示</td>
<td>present</td>
<td>1</td>
<td>段在内存中被展示</td>
</tr>
<tr>
<td align="left">Privl</td>
<td>访问权限</td>
<td>privilege</td>
<td>0</td>
<td>俗话说的ring级别。ring0 = 最高权限（内核）；ring3 = 最低权限（用户App）</td>
</tr>
<tr>
<td align="left">S</td>
<td>描述符类型</td>
<td>descriptor type</td>
<td>1</td>
<td>设为1，表示是CS/DS</td>
</tr>
<tr>
<td align="left">Ex</td>
<td>是否为可执行</td>
<td>Executable</td>
<td>1</td>
<td>1表示可执行，说明是代码；0表示不可执行，说明是数据</td>
</tr>
<tr>
<td align="left">DC</td>
<td>指示/遵循</td>
<td>Direction/Conforming</td>
<td>0</td>
<td>代码段中，0：代码只能被Privl权限执行，1：代码可以被≤Privil权限执行。数据段中，0：段从下到上，1：段从上到下。</td>
</tr>
<tr>
<td align="left">RW</td>
<td>读写性</td>
<td>Readable/Writable</td>
<td>1</td>
<td>对于代码段：1是可读（可以获取常量），0是可执行，不可写；对于数据段：1是可写，2是可读，不可执行</td>
</tr>
<tr>
<td align="left">Ac</td>
<td>已访问段</td>
<td>Accessed</td>
<td>0</td>
<td>设为0。当CPU访问段，access会设成1，由CPU控制</td>
</tr>
<tr>
<td align="left">Gr</td>
<td>粒度</td>
<td>Granularity</td>
<td>1</td>
<td>如果是1，我们的limit会扩大四倍</td>
</tr>
<tr>
<td align="left">Sz</td>
<td>大小</td>
<td>Size</td>
<td>1</td>
<td>1代表使用32位PM，0是使用16位PM</td>
</tr>
<tr>
<td align="left">0（第一个）</td>
<td>64位代码段</td>
<td>64-bit CS</td>
<td>0</td>
<td>32位处理器我们不用，0</td>
</tr>
<tr>
<td align="left">0（第二个）</td>
<td>系统可使用</td>
<td>AVailabLe for use by system software （AVL）</td>
<td>0</td>
<td>调试用，0</td>
</tr>
</tbody></table>
<p>我们根据需要的值写一个GDT。GDT有不止一种写法（也有许多比这高级的），我这种写法是定义了一个数据体，简单明了，但是可能不易于后期维护，项目里新建<code>gdt.asm</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">gdt_start: ; 在这里写一个标签，待会用来计算大小

gdt_null:  ; 这个叫做空段，是Intel预留的
    dd 0   ; DD &#x3D; double word  （此处也可以把两个dd合并为一个dq）
    dd 0   ;    &#x3D; 4 byte

gdt_code: 
    dw 0xFFFF    ; Limit            0-15 bits
    dw 0         ; Base address     0-15
    db 0         ; 同上              16-23
    db 10011010B ; 按照图二Access Byte从右至左（0-7）的顺序填写。注意Privl因为值可以是0-3，所以说占两字节，填两个0
    db 11001111B ; 按图二flags从右至左填写。我们再看图一，flags右边还有limits最后4位，不满8位编译不通过，所以把limits合并在flags右面，0xF&#x3D;0b1111
    db 0         ; Base             24-31

gdt_data:        ; 同上
    dw 0xFFFF
    dw 0
    db 0  
    db 10010010B ; 不同的是这里把Ex改成0，因为这里是数据段
    db 11001111B
    db 0

gdt_end:         ; gdt结束标签，

; GDT
gdt_descriptor:
    dw gdt_end - gdt_start - 1 ; 大小&#x3D;结束-开始-1（真实大小永远-1）
    dd gdt_start               ; 开始地址

; 常量
CODE_SEG equ gdt_code - gdt_start ; CS
DATA_SEG equ gdt_data - gdt_start ; DS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>GDT大功告成！<strong>如果你没有编译成功，出了问题，请留言跟帖或者私信，我一定会回复！</strong></p>
<h1 id="在32位保护模式下打印"><a href="#在32位保护模式下打印" class="headerlink" title="在32位保护模式下打印"></a>在32位保护模式下打印</h1><p>我们现在写一个文件<code>32bit-print</code>，用来在32位保护模式下打印，不过只用来测试，到时候加载了内核切了GUI就可以删了。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]

VIDEO_MEMORY equ 0xB8000 ; 这是VGA开始的地方
WHITE_ON_BLACK equ 0x0F  ; 是一个颜色代码，黑背景，白色字符

print_string_pm:
    pusha
    mov edx, VIDEO_MEMORY

print_string_pm_loop:
    mov al, [ebx]          ; [ebx]是字符串参数
    mov ah, WHITE_ON_BLACK ; ah颜色参数

    cmp al, 0 ; 是不是已经到末尾？
    je print_string_pm_done ; 结束

    ; 如果不是
    mov [edx], ax ; 在Vram中保存字符
    add ebx, 1 ; 下一个字符
    add edx, 2 ; 下一个Vram字符位置，+2

    jmp print_string_pm_loop ; 递归

print_string_pm_done:
    popa
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="切换到32位保护模式"><a href="#切换到32位保护模式" class="headerlink" title="切换到32位保护模式"></a>切换到32位保护模式</h1><p>简单说一下为什么会有所谓保护模式：仔细想一想就能知道，如果这个OS给用户用就是开玩笑，就好像用户和操作系统一块在计算机里玩，而不是用户在操作系统里玩，它没有安全性可言，可以随便访问内存，更别提什么ring0、ring3的了，所以说切PM是为了让OS得到保护。</p>
<p>新建代码<code>switch_pm.asm</code>，很简单。主要目标是认识并使用这个控制寄存器cr0：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 16] ; 代表在16位模式下。中括号可以去掉
switch_to_pm:
    cli                   ; 1. 一定要关掉CPU中断！让CPU专心干一件事
    lgdt [gdt_descriptor] ; 2. 还记得lgdt命令吗？加载我们的gdt_descriptor标签
    mov eax, cr0          ; 把cr0暂存到eax
    or eax, 0x1           ; 3. cr0设置为1，切到32位PM
    mov cr0, eax
    jmp CODE_SEG:init_pm  ; 4. 远跳转，跳到代码段（下面）

[bits 32] ; 32位！
init_pm:
    mov ax, DATA_SEG ; 5. 更新段寄存器
    mov ds, ax
    mov ss, ax
    mov es, ax  ; 把每个都刷一遍
    mov fs, ax
    mov gs, ax

    mov ebp, 0x90000 ; 6. 基址指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部，把它放到0x90000，待会加载内核
    mov esp, ebp

    call BEGIN_PM ; 跳到bootsect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cr0</code>全称叫做Control Register 0，这个控制寄存器专门用来在RM和PM之间切换。</p>
<p>我们编辑一下<code>bootsect.asm</code>，使用上面的“函数”：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7C00]
    mov bp, 0x9000
    mov sp, bp

    mov bx, MSG_REAL_MODE
    call print ; 在实模式下打印

    call switch_to_pm ; 切PM
    ; 这里不管加什么代码都不会被执行

%include &quot;print.asm&quot;
%include &quot;gdt.asm&quot;
%include &quot;32bit-print.asm&quot;
%include &quot;switch_pm.asm&quot;

[bits 32] ; 32位
BEGIN_PM: ; 切换后跳转到这里
    mov ebx, MSG_PROT_MODE ; 打印
    call print_string_pm ; 注意！！！这个信息会被打印到整个屏幕的最左上角，覆盖BIOS的打印
    jmp $ ; 挂起

MSG_REAL_MODE db &quot;Started in 16-bit real mode&quot;, 0
MSG_PROT_MODE db &quot;Loaded 32-bit protected mode&quot;, 0

times 510-($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译运行两步走：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/32pm-load-success.png" alt="32pm-load-success"></p>
<h1 id="加载并执行空内核"><a href="#加载并执行空内核" class="headerlink" title="加载并执行空内核"></a>加载并执行空内核</h1><p>切32位PM是为加载内核准备的，我就一块整了吧，不然切PM毫无用处。</p>
<p>首先我们得认识到，汇编作为底层语言的代价是功能太少，不方便我们编程。内核编程需要用到C。但是一个操作系统项目里，怎么能容得下两种语言编译呢？你别着急，我们的做法是将启动扇区和内核部分分开，启动扇区编译成一个bin，内核编译成一个bin，编译的过程中我们把ld命令做一些调整，使数据便宜到0x1000，之后把两个bin用cat合并。</p>
<h2 id="内核编写"><a href="#内核编写" class="headerlink" title="内核编写"></a>内核编写</h2><p>所以说咱们先开始写内核吧，新建<code>kernel.c</code>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">void main() &#123;
    char *video_memory &#x3D; (char*) 0xb8000;
    *video_memory &#x3D; &#39;V&#39;;
    char *video_memory1 &#x3D; (char*) 0xb8002;
    *video_memory1 &#x3D; &#39;e&#39;;
    char *video_memory2 &#x3D; (char*) 0xb8004;
    *video_memory2 &#x3D; &#39;n&#39;;
    char *video_memory3 &#x3D; (char*) 0xb8006;
    *video_memory3 &#x3D; &#39;u&#39;;
    char *video_memory4 &#x3D; (char*) 0xb8008;
    *video_memory4 &#x3D; &#39;s&#39;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它的作用就是到VGA的地址打印<code>Venus</code>。</p>
<h2 id="汇编编写"><a href="#汇编编写" class="headerlink" title="汇编编写"></a>汇编编写</h2><p>同级新建<code>kernel_entry.asm</code>，仅有四行代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]
[extern main] ; 像C一样，对外部函数得先声明。这个main就是kernel.c里面那个
call main     ; 执行
jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>是时候到<code>bootsect.asm</code>加载了：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[org 0x7c00]
KERNEL_OFFSET equ 0x1000 ; 定义常量，这个常量是内核的位置

    mov [BOOT_DRIVE], dl ; BIOS会自动把磁盘编号设置到dl。我们在下面间一个常量，先存起来，因为dl可能会被覆盖
    mov bp, 0x9000
    mov sp, bp

    mov bx, MSG_REAL_MODE ; 实模式打印
    call print
    call print_nl

    call load_kernel  ; 加载内核
    call switch_to_pm ; 切PM

%include &quot;print.asm&quot;
%include &quot;print_hex.asm&quot;
%include &quot;disk.asm&quot;
%include &quot;gdt.asm&quot;
%include &quot;print.asm&quot;
%include &quot;switch_pm.asm&quot;

[bits 16]
load_kernel:
    mov bx, MSG_LOAD_KERNEL
    call print
    call print_nl

    mov bx, KERNEL_OFFSET ; 读取到内核偏移地址
    mov dh, 2
    mov dl, [BOOT_DRIVE]
    call disk_load
    ret

[bits 32]
BEGIN_PM:
    mov ebx, MSG_PROT_MODE
    call print_string_pm
    call KERNEL_OFFSET ; 执行内核代码
    jmp $


BOOT_DRIVE db 0
MSG_REAL_MODE db &quot;Started in 16-bit Real Mode&quot;, 0
MSG_PROT_MODE db &quot;Landed in 32-bit Protected Mode&quot;, 0
MSG_LOAD_KERNEL db &quot;Loading kernel into memory&quot;, 0

times 510 - ($-$$) db 0
dw 0xAA55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/kern-exec.png" alt="kern-exec"></p>
<p>今天就到这里，<strong>以后更新可能会慢点</strong>，太累了，我还要干别的呢。我发现不少坛友貌似有点功利性质，说什么期待后续如果可以再下手，哈哈，我理解你们，毕竟项目要么就不做，要么就做成。我的个人理念是不做就不做，做就做大。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>《你没听错：动手开发GUI简单操作系统》系列</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态库优雅破解 AppDelete</title>
    <url>/posts/22340/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我最近一直在寻找如何使用动态库注入的方法完美 Hook <code>macOS</code> 应用程序的方法。像<code>MonkeyAppMac</code>、<code>EasySIMBL</code>这样的框架都找遍了，可就是找不到真正的香格里拉——要么就是版本太低，要么就是缺少文档。</p>
<p>我刷飘云阁论坛时偶然看到了 tree_fly 大神原创的<a class="link"   href="https://www.chinapyg.com/forum.php?mod=viewthread&tid=82610&highlight=mac" >这篇帖子<i class="fas fa-external-link-alt"></i></a>，介绍了如何破解<code>AppDelete</code>。它真正让我明白了 <code>macOS</code> 动态库注入的工作原理与注入方法，然而文章有些地方写的却过于跳步、不尽人意。我<del>有感而发</del>，把原帖的某些地方改了改，将不容易理解的地方进一步解释，然后改编成这篇文章。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li><a class="link"   href="http://www.reggieashworth.com/" >AppDelete<i class="fas fa-external-link-alt"></i></a>：<code>AppDelete</code>是Mac的卸载程序，不仅可以删除应用程序，还可以删除小部件，首选项窗格，插件和屏幕保护程序及其关联文件。 如果没有<code>AppDelete</code>，这些关联的项目将被留下来占用空间并可能引起问题。 下载完软件后没你可以先打开软件熟悉一下，</li>
<li>Hopper Disassembler v4</li>
<li>Xcode：此处用的版本是<code>Version 11.3.1 (11C504)</code>。</li>
</ul>
<h1 id="分析软件"><a href="#分析软件" class="headerlink" title="分析软件"></a>分析软件</h1><p>因为软件支持中文，所以我们可以通过字符串本地化文件来判断中文对应的英文。打开软件的资源目录中的中文目录：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;Applications&#x2F;AppDelete.app&#x2F;Contents&#x2F;Resources&#x2F;zh_CN.lproj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>找到本地中文资源文件 <code>Localizable.strings</code>，注意到如下信息：</p>
<pre class="line-numbers language-none"><code class="language-none">&quot;AppDelete Registration&quot; &#x3D; &quot;AppDelete 注册&quot;;
&quot;Registration Accepted&quot; &#x3D; &quot;接受注册&quot;;
&quot;Registration Rejected&quot; &#x3D; &quot;拒绝注册&quot;;
&quot;Register&quot; &#x3D; &quot;注册&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将软件载入Hopper，查找上面的英文字符串。通过寻找引用的方法（X），找到程序验证的核心：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class ADController *&#x2F;
&#x2F;* Address: 0x1000118add *&#x2F;
-(void)deletePaths:(void *)arg2 &#123;
    r14 &#x3D; [[self-&gt;plistOne stringValue] retain];
    r15 &#x3D; [[r14 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
    var_30 &#x3D; [r15 isEqualTo:@&quot;&quot;];
    [r15 release];
    [r14 release];
    var_38 &#x3D; self;
    r15 &#x3D; [[self-&gt;extensionMaster stringValue] retain];
    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
    rdx &#x3D; @&quot;&quot;;
    r14 &#x3D; [rbx isEqualTo:rdx];
    [rbx release];
    [r15 release];
    if (var_30 !&#x3D; 0x1) &#123;
            rdx &#x3D; @&quot;&quot;;
            if (r14 !&#x3D; 0x1) &#123;
                    r14 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                    rbx &#x3D; [[r14 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    rdx &#x3D; rbx;
                    r15 &#x3D; [var_38 orphansArray:rdx]; &#x2F;&#x2F; 1
                    [rbx release];
                    [r14 release];
                    if (r15 !&#x3D; 0x0) &#123;
                            &#x2F;&#x2F; 2
                            rbx &#x3D; [[NSBundle mainBundle] retain];
                            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Accepted&quot; value:@&quot;&quot; table:0x0] retain];
                            var_48 &#x3D; r15;
                            [rbx release];
                            intrinsic_movsd(xmm1, *double_value_0_607843);
                            intrinsic_movsd(xmm3, *double_value_1);
                            intrinsic_xorpd(xmm0, xmm0);
                            rax &#x3D; [NSColor colorWithCalibratedRed:@&quot;Registration Accepted&quot; green:@&quot;&quot; blue:r8 alpha:r9];
                            rax &#x3D; [rax retain];
                            rbx &#x3D; *ivar_offset(zipFiles);
                            [*(var_38 + rbx) setTextColor:rax, @&quot;&quot;];
                            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                            [var_38-&gt;zButton setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;qButton setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;plistOne setEnabled:0x0, @&quot;&quot;];
                            r15 &#x3D; *ivar_offset(extensionMaster);
                            [*(var_38 + r15) setEnabled:0x0, @&quot;&quot;];
                            [var_38-&gt;helpP setEnabled:0x0, @&quot;&quot;];
                            r13 &#x3D; [[*(var_38 + r15) stringValue] retain];
                            rbx &#x3D; [[r13 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            var_40 &#x3D; [[rbx dataUsingEncoding:0x4, @&quot;&quot;] retain];
                            [rbx release];
                            [r13 release];
                            rbx &#x3D; [[NSUserDefaults standardUserDefaults] retain];
                            r12 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                            [rbx setObject:r12 forKey:@&quot;ADFieldOne&quot;];
                            [r12 release];
                            [rbx release];
                            rbx &#x3D; [[NSUserDefaults standardUserDefaults] retain];
                            [rbx setObject:var_40 forKey:@&quot;ADFieldTwo&quot;];
                            [rbx release];
                            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x1;
                            *(int8_t *)&amp;var_38-&gt;undoList &#x3D; 0x0;
                            [var_40 release];
                            [rax release];
                            rdi &#x3D; var_48;
                    &#125;
                    else &#123;
                            &#x2F;&#x2F; 3
                            r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
                            [rbx release];
                            [r15 release];
                            r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                            NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
                            [rbx release];
                            [r15 release];
                            rbx &#x3D; [[NSBundle mainBundle] retain];
                            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
                            [rbx release];
                            intrinsic_movsd(xmm0, *double_value_0_921569);
                            intrinsic_movsd(xmm3, *double_value_1);
                            intrinsic_xorpd(xmm1, xmm1);
                            r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
                            rbx &#x3D; *ivar_offset(zipFiles);
                            [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
                            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                            [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
                            [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
                            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
                            [r14 release];
                            rdi &#x3D; r15;
                    &#125;
            &#125;
            else &#123;
                    r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
                    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
                    [rbx release];
                    [r15 release];
                    r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
                    rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
                    NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
                    [rbx release];
                    [r15 release];
                    rbx &#x3D; [[NSBundle mainBundle] retain];
                    r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
                    [rbx release];
                    intrinsic_movsd(xmm0, *double_value_0_921569);
                    intrinsic_movsd(xmm3, *double_value_1);
                    intrinsic_xorpd(xmm1, xmm1);
                    r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
                    rbx &#x3D; *ivar_offset(zipFiles);
                    [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
                    [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
                    [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
                    [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
                    [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
                    *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
                    [r14 release];
                    rdi &#x3D; r15;
            &#125;
    &#125;
    else &#123;
            r15 &#x3D; [[var_38-&gt;plistOne stringValue] retain];
            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
            NSLog(@&quot;AD Rejected Name ~ %@&quot;, rbx);
            [rbx release];
            [r15 release];
            r15 &#x3D; [[var_38-&gt;extensionMaster stringValue] retain];
            rbx &#x3D; [[r15 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;] retain];
            NSLog(@&quot;AD Rejected Serial Number ~ %@&quot;, rbx);
            [rbx release];
            [r15 release];
            rbx &#x3D; [[NSBundle mainBundle] retain];
            r15 &#x3D; [[rbx localizedStringForKey:@&quot;Registration Rejected&quot; value:@&quot;&quot; table:0x0] retain];
            [rbx release];
            intrinsic_movsd(xmm0, *double_value_0_921569);
            intrinsic_movsd(xmm3, *double_value_1);
            intrinsic_xorpd(xmm1, xmm1);
            r14 &#x3D; [[NSColor colorWithCalibratedRed:@&quot;Registration Rejected&quot; green:@&quot;&quot; blue:r8 alpha:r9] retain];
            rbx &#x3D; *ivar_offset(zipFiles);
            [*(var_38 + rbx) setTextColor:r14, @&quot;&quot;];
            [*(var_38 + rbx) setStringValue:r15, @&quot;&quot;];
            [*(var_38 + rbx) setHidden:0x0, @&quot;&quot;];
            [var_38-&gt;plistOne setStringValue:@&quot;&quot;, @&quot;&quot;];
            [var_38-&gt;extensionMaster setStringValue:@&quot;&quot;, @&quot;&quot;];
            *(int8_t *)&amp;var_38-&gt;archiveRun &#x3D; 0x0;
            [r14 release];
            rdi &#x3D; r15;
    &#125;
    [rdi release];
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><code>orphansArray:</code>函数应该是一个判断函数。如果你点进去，你可以看到函数声明中有严谨的判断流程；</li>
<li>如果代码执行到这里，那么就代表验证成功，可以使用App；</li>
<li>执行到这里，就是验证失败。</li>
</ol>
<p>此时如果你把<code>orphansArray:</code>的返回值修改为0x1：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, 0x1
ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那么你会发现软件运行、重启后，注册验证都通过了，同时注册按钮已经变灰，注册成功！你也可以根据<code>orphansArray:</code>的验证流程来写注册机。当然这些不是本篇文章的重点，接下来为大家介绍如何使用动态库注入来修改函数返回值。</p>
<h1 id="代码劫持"><a href="#代码劫持" class="headerlink" title="代码劫持"></a>代码劫持</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，在<code>Windows</code>下，很多时候我们在软件<code>.exe</code>同一目录下放置<code>version.dll</code>、<code>lpk.dll</code>等劫持文件，依照规则<code>.exe</code>优先加载了当前目录下<code>.dll</code>，可以偷偷摸摸做很多想做的事。</p>
<p>同理，在<code>macOS</code>下，思路是相同的，你可以想尽一切办法让App加载我们的动态库。加载完自定义的动态库，破解即成功。</p>
<h2 id="动态库编写"><a href="#动态库编写" class="headerlink" title="动态库编写"></a>动态库编写</h2><ol>
<li><p>首先，<a class="link"   href="xcode://" >打开Xcode<i class="fas fa-external-link-alt"></i></a>（你会神奇的发现如果你点击这个链接你的Xcode就会打开）。在<code>macOS</code>平台里选择 <code>Framework &amp; Library </code>&gt; <code>Library</code>。使用此模板新建一个项目，名称随便起，此处叫做<code>AppDeletePatch</code>，<code>Framework</code>选择<code>Cocoa</code>，<code>Type</code>选择<code>Dyamic</code>（动态）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ad-choose-temp.png" alt="选择模版"></p>
<p>这一步可以创建一个动态库工程。这个动态库就是我们要注入的动态库。</p>
<p>其次，我们打开<code>AppDeletePatch.m</code>文件。接下来我一步步带你编写动态库代码：</p>
</li>
<li><p>我们用两个<code>#import</code>语句，将<code>AppDeletePatch.h</code>文件与<code>objc/runtime.h</code>。<code>AppDeletePatch.h</code>文件（头文件），是每个<code>.m</code>文件里必须引用的。而<code>objc/runtime.h</code>库是什么？这就是很多小白不了解的地方之一。简单的解释，<code>runtime</code>是<code>C</code>类语言**”运行时”机制**的一个强大的库。通过这个库里的方法，可以在运行时实现对OC函数的 hook。</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &quot;AppDeletePatch.h&quot;
   #import &lt;objc&#x2F;runtime.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>现在，这两行代码明白了吧！</p>
</li>
<li><p>接下来，在两个引入语句的下面编写：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">@implementation AppDeletePatch



@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>Objective-C</code>语言中，可以使用<code>implementation</code>进行一个类的具体实现，类的实现代码以<code>@implementation</code>开始，以<code>@end</code>结束。这就类似于<code>Python</code>、<code>Swift</code>的<code>class</code>。<strong>这部分代码通常都是放在<code>.m</code>文件中</strong>。</p>
</li>
<li><p>然后，我们在<code>@implementation</code>的内部，声明一个函数：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">- (char)orphansArray:(NSString *)data &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 0x1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这又涉及了<code>OC</code>的语法，我们简单说一下。这样写，是实现了一个函数，函数名是<code>orphansArray:</code>。而冒号后面跟的是函数的参数列表<code>(NSString *)data</code>。这里声明了一个类型为<code>NSString</code>的参数<code>data</code>。而前面的<code>(char)</code>则代表函数的返回值。</p>
<p>如果你把原程序里<code>orphansArray:</code>的函数声明伪代码与这里的函数声明做对比，你会发现，这里的函数声明与原程序的函数声明一模一样。</p>
<p>你可能会疑问，函数前面的减号是干嘛的？类方法以<code>+</code>号开头，对象方法以<code>-</code>号开头。</p>
<p>函数里的两行代码就好解释了。<code>NSLog:</code>就是日志输出，相当于<code>Swift</code>和<code>Python</code>下的<code>print()</code>，这里我打印了一条信息以便记录；<code>return</code>就是返回的意思，此处返回了<code>0x1</code>一值。</p>
<p><code>orphansArray:</code>的实现就到此结束了。</p>
</li>
<li><p>在<code>orphansArray:</code>的实现后，空上几行，然后输入<code>load</code>。<code>Xcode</code>的自动补全功能会弹出列表。在列表第一行回车，之后在添上大括号：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">+ (void)load &#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个方法是干什么的？每当将类或类别添加到Objective-C的<code>runtime</code>时会被调用； 实现此方法以在加载时执行特定于类的行为。<code>load</code>方法的初始化顺序如下：</p>
<ol>
<li>您链接到的任何框架中的所有初始化程序。</li>
<li>图片中的所有<code> + load</code>方法。</li>
<li>图像中的所有<code>C++</code>静态初始化程序和<code>C</code> / <code>C ++</code> <code>__attribute __(constructor)</code>函数。</li>
<li>链接到您的框架中的所有初始化程序。</li>
</ol>
<p>我们在<code>load</code>里键入：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;ADController&quot;), NSSelectorFromString(@&quot;orphansArray:&quot;)); &#x2F;&#x2F; 1
Method newMethod &#x3D; class_getInstanceMethod([AppDeletePatch class], @selector(orphansArray:)); &#x2F;&#x2F; 2

method_exchangeImplementations(origMethod, newMethod); &#x2F;&#x2F; 3
NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>通过<code>class_getInstanceMethod</code>函数，获取程序里<code>orphansArray:</code>的原函数；</li>
<li>这一行代码与<code>3</code>同理，只不过是获取我们声明的替换函数<code>orphansArray:</code>；</li>
<li>通过<code>method_exchangeImplementations</code>函数替换刚才获取的两个新旧函数。</li>
</ol>
<p>其中：</p>
<ul>
<li><code>NSClassFromString</code>可以通过字符串获取类；</li>
<li><code>NSSelectorFromString</code>可以通过字符串获取方法；</li>
<li><code>[AppDeletePatch class]</code>代表<code>AppDeletePatch</code>类的<code>class</code>本身；</li>
<li>通过<code>@selector</code>直接获取一个函数。</li>
</ul>
</li>
</ol>
<p>到此，动态库的代码编写结束。整体的代码应该长这样：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &quot;AppDeletePatch.h&quot;
#import &lt;objc&#x2F;runtime.h&gt;

@implementation AppDeletePatch

- (char)orphansArray:(NSString *)data &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    return 0x1;
&#125;

+ (void)load &#123;
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
    Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;ADController&quot;), NSSelectorFromString(@&quot;orphansArray:&quot;));
    Method newMethod &#x3D; class_getInstanceMethod([AppDeletePatch class], @selector(orphansArray:));

    method_exchangeImplementations(origMethod, newMethod);
    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);
&#125;

@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="动态库注入"><a href="#动态库注入" class="headerlink" title="动态库注入"></a>动态库注入</h2><p>编写完动态库，就可以注入了。按下<code>Cmd</code>+<code>B</code>编译，得到<code>.dylib</code>文件。</p>
<p>之后我们要注入。原作者用的是<code>bash</code>脚本，但是这样做比较费事，容易发生权限错误，因此我们用<code>insert_dylib</code>工具注入。点击<a class="link"   href="xcode://clone?repo=https%3A%2F%2Fgithub.com%2FTyilo%2Finsert_dylib" >这个链接<i class="fas fa-external-link-alt"></i></a>将<code>insert_dylib</code>项目克隆到<code>Xcode</code>，并且编译，得到<code>insert_dylib</code>二进制文件。</p>
<p>我们将动态库、二进制文件和<code>AppDelete</code>应用程序的路径分别记录下来，然后打开终端，执行命令（记得替换路径）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ .&#x2F;insert_dylib xxx&#x2F;libAppDeletePatch.dylib xxx&#x2F;AppDelete.app&#x2F;Contents&#x2F;MacOS&#x2F;AppDelete<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注：<code>./insert_dylib</code>的用法是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;insert_dylib [要被注入的动态库的路径] [要注入的二进制文件]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意第二个参数，是要注入的<strong>二进制文件</strong>，而不是<code>.app</code>文件，或者其他。还要注意，路径要使用<strong>绝对路径</strong>。</p>
<p>回车后，如果出现<code>LC_CODE_SIGNATURE load command found. Remove it? [y/n]</code>，那么就按下<code>y</code>，回车。</p>
<p>如果出现<code>Added LC_LOAD_DYLIB to /Applications/AppDelete.app/Contents/MacOS/AppDelete_patched</code>，代表注入成功。</p>
<p>回到<code>/Applications/AppDelete.app/Contents/MacOS/</code>路径，会发现多出一个<code>AppDelete_patched</code>文件。这就是已注入动态库的二进制文件。把原先的<code>AppDelete</code>二进制更名或删除，然后将<code>AppDelete_patched</code>更名为<code>AppDelete</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-ad-chname.png" alt="重命名"></p>
<h1 id="验证破解"><a href="#验证破解" class="headerlink" title="验证破解"></a>验证破解</h1><p>我们现在不要用正常的方法打开软件。我们还保持上一步的目录（<code>MacOS</code>），然后双击已经被注入的二进制文件，应用也会打开。不过同时会打开一个终端窗口，在这个窗口中就可以看到我们在写代码时使用<code>NSLog</code>语句打印的内容了：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>成功破解！</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你玩转CrackMe破解五步走</title>
    <url>/posts/33a3e091/</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="http://www.52pojie.cn/" >www.52pojie.cn<i class="fas fa-external-link-alt"></i></a></p>
<p>作者：@TLHorse</p>
<p>原创作品，吾爱破解首发</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文所破解的CrackMe出自国外MSJ论坛的竞赛题目，原题估计找不着了，所以我共享在如下链载：</p>
<blockquote>
<p>链接：<a class="link"   href="https://share.weiyun.com/hGwzo5p4" >https://share.weiyun.com/hGwzo5p4<i class="fas fa-external-link-alt"></i></a></p>
<p>密码：5828dk</p>
</blockquote>
<p>这个app我已经打开并逆向过，确认没有病毒，如果你还不放心可以拉到虚拟机里。<strong>为了避免违规，我逆向去除了app里的MSJ链接（点击<code>Help me!</code>不会跳转）。</strong>我看也没有多少人破解，macOS CM也挺少的，就拿来分析一下。</p>
<p>题目中的五部走包括：</p>
<ul>
<li>分析</li>
<li>暴力破解</li>
<li>Hook</li>
<li>代码还原</li>
<li>写注册机</li>
</ul>
<p><strong>macOS下的逆向很少被人提及，似乎很冷门，我今天分析这个CrackMe，涵盖这四部分，希望对用macOS的朋友有帮助。</strong></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-view.png" alt="pie-view"></p>
<p>打开看一下主页面，这个CM和别的不太相同的是，它没有“确认”“验证”之类的按钮。随便输入几组值都都没有反应。 <strong>我们猜测这个CM会在表单变动时重复刷新验证</strong>，在符号表里搜索到的<code>serialFieldDidChange</code>验证了我们的想法：</p>
<pre class="line-numbers language-objective-c" data-language="objective-c"><code class="language-objective-c">&#x2F;* @class PieAppDelegate *&#x2F;
-(void)serialFieldDidChange &#123;
    &#x2F;&#x2F; init UserDefaults，Apple开发的都知道这是数据持久化
    r15 &#x3D; (@selector(standardUserDefaults))(@class(NSUserDefaults), &amp;@selector(standardUserDefaults));
    &#x2F;&#x2F; 设置UserDefaults
    (@selector(setObject:forKey:))(r15, &amp;@selector(setObject:forKey:), (@selector(stringValue))(self-&gt;nameField, &amp;@selector(stringValue)), @&quot;name&quot;);
    (@selector(setObject:forKey:))(r15, &amp;@selector(setObject:forKey:), (@selector(stringValue))(self-&gt;serialField, &amp;@selector(stringValue)), @&quot;serial&quot;);
    &#x2F;&#x2F; 验证
    (@selector(verifySerial:andName:))(self, &amp;@selector(verifySerial:andName:), (@selector(stringValue))(self-&gt;serialField, &amp;@selector(stringValue)), (@selector(stringValue))(self-&gt;nameField, &amp;@selector(stringValue)));
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以轻松发现，<code>verifySerial:andName:</code>就是验证用户名密码的关键函数。这个CM有反调试，我就拿<code>frida-trace</code>进行跟踪，<strong>发现每输入一个字符，就会将此函数调用一次</strong>，更印证了我们的猜测。</p>
<h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><p>话不多说，先考虑暴破。不过在动手改二进制前，我们得先瞄准一个点，到底改哪呢？我就试试<code>verifySerial:andName:</code>吧，汇编代码如下（我把失败的标签从<code>loc_xxx</code>改为<code>failure</code>）：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                     -[PieAppDelegate verifySerial:andName:]:
0000000100001342         push       rbp
0000000100001343         mov        rbp, rsp
0000000100001346         mov        qword [rbp+var_28], rbx
000000010000134a         mov        qword [rbp+var_20], r12
000000010000134e         mov        qword [rbp+var_18], r13
0000000100001352         mov        qword [rbp+var_10], r14
0000000100001356         mov        qword [rbp+var_8], r15
000000010000135a         sub        rsp, 0xd0
0000000100001361         mov        qword [rbp+var_60], rdi
0000000100001365         mov        r13, rdx
0000000100001368         mov        r14, rcx
000000010000136b         mov        rdi, qword [qword_100002768]
0000000100001372         mov        edx, 0x4
0000000100001377         lea        rsi, qword [0x1000022b8]
000000010000137e         call       qword [0x1000022b8]
0000000100001384         mov        r15, rax
0000000100001387         lea        rsi, qword [0x1000022c8]
000000010000138e         mov        rdi, r13
0000000100001391         call       qword [0x1000022c8]
0000000100001397         cmp        rax, 0x10
000000010000139b         jne        failure

00000001000013a1         mov        edx, 0x6
00000001000013a6         lea        rsi, qword [0x1000022d8]
00000001000013ad         mov        rdi, r13
00000001000013b0         call       qword [0x1000022d8]
00000001000013b6         mov        rdi, rax
00000001000013b9         mov        edx, 0x4
00000001000013be         lea        rsi, qword [0x1000022b8]
00000001000013c5         call       qword [0x1000022b8]
00000001000013cb         mov        rbx, rax
00000001000013ce         lea        rsi, qword [0x1000022c8]
00000001000013d5         mov        rdi, rax
00000001000013d8         call       qword [0x1000022c8]
00000001000013de         mov        r12, rax
00000001000013e1         lea        rsi, qword [0x1000022e8]
00000001000013e8         mov        rdi, rbx
00000001000013eb         call       qword [0x1000022e8]
00000001000013f1         mov        rdi, rax
00000001000013f4         xor        edx, edx
00000001000013f6         mov        rsi, r12
00000001000013f9         call       imp___symbol_stub1__MD5
00000001000013fe         mov        rdx, qword [objc_cls_ref_NSString]
0000000100001405         mov        qword [rbp+var_58], rdx
0000000100001409         movzx      r9d, byte [rax+2]
000000010000140e         movzx      r8d, byte [rax+1]
0000000100001413         movzx      ecx, byte [rax]
0000000100001416         movzx      edx, byte [rax+0xf]
000000010000141a         mov        dword [rsp+0xd0+var_70], edx
000000010000141e         movzx      edx, byte [rax+0xe]
0000000100001422         mov        dword [rsp+0xd0+var_78], edx
0000000100001426         movzx      edx, byte [rax+0xd]
000000010000142a         mov        dword [rsp+0xd0+var_80], edx
000000010000142e         movzx      edx, byte [rax+0xc]
0000000100001432         mov        dword [rsp+0xd0+var_88], edx
0000000100001436         movzx      edx, byte [rax+0xb]
000000010000143a         mov        dword [rsp+0xd0+var_90], edx
000000010000143e         movzx      edx, byte [rax+0xa]
0000000100001442         mov        dword [rsp+0xd0+var_98], edx
0000000100001446         movzx      edx, byte [rax+9]
000000010000144a         mov        dword [rsp+0xd0+var_A0], edx
000000010000144e         movzx      edx, byte [rax+8]
0000000100001452         mov        dword [rsp+0xd0+var_A8], edx
0000000100001456         movzx      edx, byte [rax+7]
000000010000145a         mov        dword [rsp+0xd0+var_B0], edx
000000010000145e         movzx      edx, byte [rax+6]
0000000100001462         mov        dword [rsp+0xd0+var_B8], edx
0000000100001466         movzx      edx, byte [rax+5]
000000010000146a         mov        dword [rsp+0xd0+var_C0], edx
000000010000146e         movzx      edx, byte [rax+4]
0000000100001472         mov        dword [rsp+0xd0+var_C8], edx
0000000100001476         movzx      eax, byte [rax+3]
000000010000147a         mov        dword [rsp+0xd0+var_D0], eax
000000010000147d         lea        rdx, qword [cfstring__02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X]
0000000100001484         lea        rsi, qword [0x1000022f8]
000000010000148b         mov        rdi, qword [rbp+var_58]
000000010000148f         xor        eax, eax
0000000100001491         call       qword [0x1000022f8]
0000000100001497         mov        rdi, rax
000000010000149a         mov        rdx, qword [qword_100002770]
00000001000014a1         lea        rsi, qword [0x100002308]
00000001000014a8         call       qword [0x100002308]
00000001000014ae         test       al, al
00000001000014b0         je         failure

00000001000014b6         mov        edx, 0xd
00000001000014bb         lea        rsi, qword [0x100002318]
00000001000014c2         mov        rdi, r13
00000001000014c5         call       qword [0x100002318]
00000001000014cb         cmp        ax, 0x46
00000001000014cf         jne        failure

00000001000014d5         mov        edx, 0x4
00000001000014da         lea        rsi, qword [0x1000022b8]
00000001000014e1         mov        rdi, r14
00000001000014e4         call       qword [0x1000022b8]
00000001000014ea         mov        rbx, rax
00000001000014ed         lea        rsi, qword [0x1000022c8]
00000001000014f4         mov        rdi, rax
00000001000014f7         call       qword [0x1000022c8]
00000001000014fd         mov        r12, rax
0000000100001500         lea        rsi, qword [0x1000022e8]
0000000100001507         mov        rdi, rbx
000000010000150a         call       qword [0x1000022e8]
0000000100001510         mov        rdi, rax
0000000100001513         xor        edx, edx
0000000100001515         mov        rsi, r12
0000000100001518         call       imp___symbol_stub1__MD5
000000010000151d         movzx      r9d, byte [rax+2]
0000000100001522         movzx      r8d, byte [rax+1]
0000000100001527         movzx      ecx, byte [rax]
000000010000152a         movzx      edx, byte [rax+7]
000000010000152e         mov        dword [rsp+0xd0+var_B0], edx
0000000100001532         movzx      edx, byte [rax+6]
0000000100001536         mov        dword [rsp+0xd0+var_B8], edx
000000010000153a         movzx      edx, byte [rax+5]
000000010000153e         mov        dword [rsp+0xd0+var_C0], edx
0000000100001542         movzx      edx, byte [rax+4]
0000000100001546         mov        dword [rsp+0xd0+var_C8], edx
000000010000154a         movzx      eax, byte [rax+3]
000000010000154e         mov        dword [rsp+0xd0+var_D0], eax
0000000100001551         lea        rdx, qword [cfstring__02X_02X_02X_02X_02X_02X_02X]
0000000100001558         lea        rsi, qword [0x1000022f8]
000000010000155f         mov        rdi, qword [rbp+var_58]
0000000100001563         xor        eax, eax
0000000100001565         call       qword [0x1000022f8]
000000010000156b         mov        rdi, rax
000000010000156e         mov        edx, 0x7
0000000100001573         lea        rsi, qword [0x1000022d8]
000000010000157a         call       qword [0x1000022d8]
0000000100001580         mov        rbx, rax
0000000100001583         mov        qword [rbp+var_38], 0x7
000000010000158b         mov        qword [rbp+var_40], 0x6
0000000100001593         mov        edx, 0x6
0000000100001598         mov        ecx, 0x7
000000010000159d         lea        rsi, qword [0x100002328]
00000001000015a4         mov        rdi, r13
00000001000015a7         call       qword [0x100002328]
00000001000015ad         mov        rdi, rax
00000001000015b0         mov        rdx, rbx
00000001000015b3         lea        rsi, qword [0x100002308]
00000001000015ba         call       qword [0x100002308]
00000001000015c0         test       al, al
00000001000015c2         je         failure

00000001000015c8         mov        qword [rbp+var_48], 0x2
00000001000015d0         mov        qword [rbp+var_50], 0xe
00000001000015d8         mov        edx, 0xe
00000001000015dd         mov        ecx, 0x2
00000001000015e2         lea        rsi, qword [0x100002328]
00000001000015e9         mov        rdi, r13
00000001000015ec         call       qword [0x100002328]
00000001000015f2         mov        rdi, rax
00000001000015f5         mov        edx, 0x4
00000001000015fa         lea        rsi, qword [0x1000022b8]
0000000100001601         call       qword [0x1000022b8]
0000000100001607         mov        rdi, rax
000000010000160a         mov        rdx, r15
000000010000160d         lea        rsi, qword [0x100002338]
0000000100001614         call       qword [0x100002338]
000000010000161a         test       al, al
000000010000161c         je         failure
                        ; 下面的一段是成功注册的代码
000000010000161e         mov        rdi, qword [objc_cls_ref_NSNotificationCenter]
0000000100001625         lea        rsi, qword [0x100002238]
000000010000162c         call       qword [0x100002238]
0000000100001632         mov        rdi, rax
0000000100001635         mov        rcx, qword [rbp+var_60]
0000000100001639         lea        rdx, qword [cfstring_Registered]
0000000100001640         lea        rsi, qword [0x100002348]
0000000100001647         mov        r11, qword [0x100002348]
000000010000164e         mov        rbx, qword [rbp+var_28]
0000000100001652         mov        r12, qword [rbp+var_20]
0000000100001656         mov        r13, qword [rbp+var_18]
000000010000165a         mov        r14, qword [rbp+var_10]
000000010000165e         mov        r15, qword [rbp+var_8]
0000000100001662         leave
0000000100001663         jmp        r11
                        ; endp

                     failure:
0000000100001666         mov        rbx, qword [rbp+var_28]
000000010000166a         mov        r12, qword [rbp+var_20]
000000010000166e         mov        r13, qword [rbp+var_18]
0000000100001672         mov        r14, qword [rbp+var_10]
0000000100001676         mov        r15, qword [rbp+var_8]
000000010000167a         leave
000000010000167b         ret
                        ; endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们发现这个函数有一个特点，从头开始往下，一直是<code>cmp a, b</code>然后<code>jne/je failure</code>，也就是说<strong>如果我们暴破，要把这些<code>jne</code>和<code>je</code>都<code>nop</code>掉。</strong>太麻烦了，但是，自己想想，就真的没有好方法吗？答案是：有的。</p>
<p>在这里我耍了一个小聪明：既然那么多失败的路径都指向<code>failure</code>，我何不把<code>failure</code>本身改一下呢？<code>Option+A</code>改为如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                     failure:
0000000100001666         jmp        0x10000161e
0000000100001668         nop
000000010000166f         nop
0000000100001670         nop
0000000100001679         nop
000000010000167b         nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我贴个图让你看得更明白：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/18/pie-bp-guide.png" alt="pie-bp-guide"></p>
<p>也就是说，“验证失败”的代码被我们暴破跳转到“验证成功”的代码。<strong>如果哪行指令跳转到“验证失败”的代码，我们就再让它跳转到成功代码。</strong>很巧妙吧！</p>
<p><code>Cmd+Shift+E</code>输出二进制，替换即可。</p>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>我们先来试试Hook一下这个函数，我先把<code>verifySerial:andName:</code>贴出来。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;* @class PieAppDelegate *&#x2F;
-(void)verifySerial:(void *)arg2 andName:(void *)arg3 &#123;
    var_28 &#x3D; rbx;
    var_20 &#x3D; r12;
    var_18 &#x3D; r13;
    var_10 &#x3D; r14;
    var_8 &#x3D; r15;
    var_60 &#x3D; self;
    r13 &#x3D; arg2;
    r14 &#x3D; arg3;
    r15 &#x3D; (@selector(dataUsingEncoding:))(*qword_100002768, &amp;@selector(dataUsingEncoding:), 0x4, arg3);
    if ((@selector(length))(r13, &amp;@selector(length)) &#x3D;&#x3D; 0x10) &#123;
            rax &#x3D; (@selector(substringToIndex:))(r13, &amp;@selector(substringToIndex:), 0x6);
            rax &#x3D; (@selector(dataUsingEncoding:))(rax, &amp;@selector(dataUsingEncoding:), 0x4);
            r12 &#x3D; (@selector(length))(rax, &amp;@selector(length));
            rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes));
            rax &#x3D; MD5(rax, r12, 0x0);
            if (((@selector(isEqualToString:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff, *(int8_t *)(rax + 0x8) &amp; 0xff, *(int8_t *)(rax + 0x9) &amp; 0xff, *(int8_t *)(rax + 0xa) &amp; 0xff, *(int8_t *)(rax + 0xb) &amp; 0xff, *(int8_t *)(rax + 0xc) &amp; 0xff), &amp;@selector(isEqualToString:), *qword_100002770) &#x3D;&#x3D; 0x0) &amp;&amp; ((@selector(characterAtIndex:))(r13, &amp;@selector(characterAtIndex:), 0xd) !&#x3D; 0x46)) &#123;
                    rax &#x3D; (@selector(dataUsingEncoding:))(r14, &amp;@selector(dataUsingEncoding:), 0x4);
                    r12 &#x3D; (@selector(length))(rax, &amp;@selector(length));
                    rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes));
                    rax &#x3D; MD5(rax, r12, 0x0);
                    if ((@selector(isEqualToString:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0x6, 0x7), &amp;@selector(isEqualToString:), (@selector(substringToIndex:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff), &amp;@selector(substringToIndex:), 0x7)) &#x3D;&#x3D; 0x0) &#123;
                            if ((@selector(isEqualToData:))((@selector(dataUsingEncoding:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0xe, 0x2), &amp;@selector(dataUsingEncoding:), 0x4), &amp;@selector(isEqualToData:), r15) &#x3D;&#x3D; 0x0) &#123;
                                    (@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);
                            &#125;
                    &#125;
            &#125;
    &#125;
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数体很长，关键在于它并没有返回一个特定的值，比如布尔或者字符。这个函数把验证和注册两个过程绑在一起。一个一个把跳转改成nop，太费时间。那还有什么办法呢？我看着这一层层if嵌套，突然萌生了一个想法：不用一层层改条件，只需要一个Hook，直接执行最里面的代码。</p>
<p>在这里我使用MonkeyDev框架，新建工程，将<code>Pie.app</code>拖入：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-proj-guide.png" alt="详细步骤"></p>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>按照Cydia Substrate的文档，我们需要在动态库加载入口作函数替换，需要用<code>MSHookMessageEx</code>。这里是官方文档的用法（我翻译的）：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">void MSHookMessageEx(Class _class, SEL message, IMP hook, IMP *old);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>_class</code></td>
<td>OC类，消息将在该类上被hook。这个类可以是一个元类，这样就可以hook住非实例或类消息。</td>
</tr>
<tr>
<td><code>message</code></td>
<td>被hook的OC选择器（sel）。这可以用 <code>@selector</code> ，或在运行时用 <code>sel_registerName</code>生成。</td>
</tr>
<tr>
<td><code>hook</code></td>
<td><code>message</code>的替代函数，IMP指针类型。(注意传入的时候一定是指针)</td>
</tr>
<tr>
<td><code>old</code></td>
<td>一个空的函数指针。这个空的函数指针在hook时会被原函数填充，这样你在写新函数的时候，就可以调用原函数体了。如果你不需要调用原函数，此处可以留成NULL。</td>
</tr>
</tbody></table>
<p>现在，我们编辑<code>PieTweak.m</code>，编辑<code>constructor</code>：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">static void __attribute__((constructor)) initialize(void) &#123;
    MSHookMessageEx(objc_getClass(&quot;PieAppDelegate&quot;), @selector(verifySerial:andName:), (IMP)&amp;new_PieAppDelegate_verifySerial, NULL);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中<code>new_PieAppDelegate_verifySerial</code>是我们要实现的。我们可以写一个<code>origin_PieAppDelegate_verifySerial</code>。由于我们不需要在hook里调用原函数，所以留空填<code>NULL</code>。</p>
<p>接下来就该写我们的替代函数体了，<code>new_PieAppDelegate_verifySerial</code>。<strong>我们首先得考虑一下参数列表</strong>，除了Hopper解析出的<code>serial</code>和<code>name</code>，<strong>还有两个固定参数：<code>self</code>和<code>_cmd</code>。</strong></p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">@class PieAppDelegate; &#x2F;&#x2F; 为了在参数中写self，在这里我们声明类

static void new_PieAppDelegate_verifySerial(
    PieAppDelegate* self, &#x2F;&#x2F; 两个固定参数
    SEL _cmd, 
    void *serial, &#x2F;&#x2F; 此处复制粘贴Hopper
    void *name
) &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>那么函数体呢？</strong>这得根据Hopper的伪代码进行还原。伪代码最内层有这么一句：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">(@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以推测出：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>把还原的语句放到<code>new_PieAppDelegate_verifySerial</code>里。</p>
<p>现在大家可能被我绕的有点晕，所有的代码纵观如下：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#import &quot;PieTweak.h&quot;
#import &quot;substrate.h&quot;

@class PieAppDelegate;

static void new_PieAppDelegate_verifySerial(PieAppDelegate* self, SEL _cmd, void *serial, void *name) &#123;
    [NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self]; &#x2F;&#x2F; 我们从伪代码还原的语句
&#125;

static void __attribute__((constructor)) initialize(void) &#123;
    MSHookMessageEx(objc_getClass(&quot;PieAppDelegate&quot;), @selector(verifySerial:andName:), (IMP)&amp;new_PieAppDelegate_verifySerial, NULL);
    &#x2F;&#x2F; 调用substrate进行hook
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Cmd+B</code>编译，MonkeyDev会自动给我们注入：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-hook-success.png" alt="pie-hook-success"></p>
<p><strong>不错吧！一打开就注册好了。</strong>我们只需要把<code>Pie.app</code>从<code>TargetApp</code>里面拖出去，就是我们的成品啦！</p>
<h1 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h1><p>如果不用hook暴破，那就是写注册机了。注册机使我们破解得更优雅，但是代码的分析更麻烦。这个CM不是有反调试吗，所以说只有靠我们看伪代码了。</p>
<p>这里希望提醒大家几点：</p>
<ul>
<li>看伪代码首先要<strong>利用Hopper功能</strong>，把arg2、arg3这样的无意义参数名更名，比如<code>serial</code>和<code>name</code>；</li>
<li>一定要善于进行<strong>代码还原</strong>。Hopper会把不知道的方法都翻译成<code>@selector</code>，语法非常的别扭。具体的还原方法hook中有所涉及，但是我会在文末单独成节；</li>
<li>在自己重写代码时，<strong>使用自己的变量</strong>，而不是<code>r12</code>、<code>r13</code>这样的无意义变量；</li>
<li>有时候Hopper会把代码逻辑解析得很麻烦，比如在这个例子中，它把MD5的<em>加密数据</em>和<em>转换成字符串的MD5</em>分别放在变量和if条件里，就会让你感觉摸不着头，所以说<strong>一定要有自主判断能力。</strong></li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们首先把验证函数的流程捣腾清楚：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">var_28 &#x3D; rbx; &#x2F;&#x2F; 定义一堆没用的，不过一定要清楚
var_20 &#x3D; r12;
var_18 &#x3D; r13;
var_10 &#x3D; r14;
var_8 &#x3D; r15;
var_60 &#x3D; self;
r13 &#x3D; arg2; &#x2F;&#x2F; serial序列号变量
r14 &#x3D; arg3; &#x2F;&#x2F; name名称变量
r15 &#x3D; (@selector(dataUsingEncoding:))(*qword_100002768, &amp;@selector(dataUsingEncoding:), 0x4, arg3); &#x2F;&#x2F; 把名称进行编码，4其实是NSStringEncoding的NSUTF8StringEncoding，是个常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一开头，定义了一堆没用的，不过要清楚r13和r14是<code>serial</code>和name。r15处把<code>name</code>编码，查开发者文档可知0x4其实是<code>NSStringEncoding</code>的NSUTF8StringEncoding，是个常量。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">if ((@selector(length))(r13, &amp;@selector(length)) &#x3D;&#x3D; 0x10) &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>判断serial的长度，如果是16位（0x10），通过。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">rax &#x3D; (@selector(substringToIndex:))(r13, &amp;@selector(substringToIndex:), 0x6); &#x2F;&#x2F; 取序列号前6位
rax &#x3D; (@selector(dataUsingEncoding:))(rax, &amp;@selector(dataUsingEncoding:), 0x4);
r12 &#x3D; (@selector(length))(rax, &amp;@selector(length)); &#x2F;&#x2F; 计算长度
rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes)); &#x2F;&#x2F; 计算字节
rax &#x3D; MD5(rax, r12, 0x0); &#x2F;&#x2F; 计算序列号前6位的MD5值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这5行代码先取序列号前6位，然后计算出了相关长度、字节，最后计算出序列号前6位的MD5。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">if (((@selector(isEqualToString:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff, *(int8_t *)(rax + 0x8) &amp; 0xff, *(int8_t *)(rax + 0x9) &amp; 0xff, *(int8_t *)(rax + 0xa) &amp; 0xff, *(int8_t *)(rax + 0xb) &amp; 0xff, *(int8_t *)(rax + 0xc) &amp; 0xff), &amp;@selector(isEqualToString:), *qword_100002770) &#x3D;&#x3D; 0x0) &amp;&amp; ((@selector(characterAtIndex:))(r13, &amp;@selector(characterAtIndex:), 0xd) !&#x3D; 0x46)) &#123; &#x2F;&#x2F; 这个if的条件要满足两部分：1. 序列号的前6位的MD5是66EAD6FE7CBE7987B7C4B1A1EED0E5A5；2. 序列号的第13位是ASCII 0x46，也就是字符F<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个条件很长，但是细心的你会发现中间有个逻辑运算<code>&amp;&amp;</code>，条件分为两部分：</p>
<ol>
<li>序列号的前6位的MD5是<code>66EAD6FE7CBE7987B7C4B1A1EED0E5A5</code>，通过某网站的反查得知是“KRACK-”，这是个序列号前缀；</li>
<li>序列号的第13位是ASCII 0x46，也就是字符F。</li>
</ol>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">rax &#x3D; (@selector(dataUsingEncoding:))(r14, &amp;@selector(dataUsingEncoding:), 0x4); &#x2F;&#x2F; 编码name
r12 &#x3D; (@selector(length))(rax, &amp;@selector(length)); &#x2F;&#x2F; 计算name长度
rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes)); &#x2F;&#x2F; 计算name字节
rax &#x3D; MD5(rax, r12, 0x0); &#x2F;&#x2F; 使用MD5加密name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个和刚才代码分析中第二个代码框中的5行结构是一模一样，计算name属性，然后加密name。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">if ((@selector(isEqualToString:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0x6, 0x7), &amp;@selector(isEqualToString:), (@selector(substringToIndex:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff), &amp;@selector(substringToIndex:), 0x7)) &#x3D;&#x3D; 0x0) &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>又是一长串条件，好像是在判断serial的某个子字符串（也就是某部分）跟name的md5值相等。</p>
<p>这里要说明一下<code>substringWithRange:</code>的参数，研究了半天发现，0x6表示子字符串开始，<strong>0x7表示包含开头往后数七位，是子字符串的长度</strong>，也就是说这个函数返回的是serial的6到12位（我这里指的是索引）。相当于这个if条件在将name的md5值与serial的6-12位对比。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">if ((@selector(isEqualToData:))((@selector(dataUsingEncoding:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0xe, 0x2), &amp;@selector(dataUsingEncoding:), 0x4), &amp;@selector(isEqualToData:), r15) &#x3D;&#x3D; 0x0) &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>又是一个if。现在我们一目了然，这是在把serial索引为14、15的子字符串编码后和r15对比。诶？r15不是name的utf8编码吗？不对啊？两位和一长串名称对比，肯定返回false。别着急，我们瞧瞧ASM：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                     -[PieAppDelegate verifySerial:andName:]:
0000000100001342         push       rbp
0000000100001343         mov        rbp, rsp
0000000100001346         mov        qword [rbp+var_28], rbx
000000010000134a         mov        qword [rbp+var_20], r12
000000010000134e         mov        qword [rbp+var_18], r13
0000000100001352         mov        qword [rbp+var_10], r14
0000000100001356         mov        qword [rbp+var_8], r15
000000010000135a         sub        rsp, 0xd0
0000000100001361         mov        qword [rbp+var_60], rdi
0000000100001365         mov        r13, rdx
0000000100001368         mov        r14, rcx
000000010000136b         mov        rdi, qword [qword_100002768]                ; qword_100002768
0000000100001372         mov        edx, 0x4
0000000100001377         lea        rsi, qword [0x1000022b8]                    ; &amp;@selector(dataUsingEncoding:)
000000010000137e         call       qword [0x1000022b8]                         ; @selector(dataUsingEncoding:)
0000000100001384         mov        r15, rax
0000000100001387         lea        rsi, qword [0x1000022c8]                    ; &amp;@selector(length)
000000010000138e         mov        rdi, r13
0000000100001391         call       qword [0x1000022c8]                         ; @selector(length)
0000000100001397         cmp        rax, 0x10
000000010000139b         jne        loc_100001666<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们发现，函数的开头，竟然有一个我们忽略了的<code>qword_100002768</code>！跳转一下，发现它指向一个“BC”的字符串：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">    qword_100002768:
0000000100002768 dq 0x0000000100002168 ; @&quot;BC&quot;, DATA XREF&#x3D;-[PieAppDelegate verifySerial:andName:]+41<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>那为什么说这个qword是r15呢？因为反汇编中，从rdi被赋值到被覆盖期间，只有rax传给了r15。我们推测BC就是serial索引为14、15的子字符串。</p>
<p>回到代码分析，最后一个if嵌套的就是成功的弹窗了。</p>
<h2 id="流程复现"><a href="#流程复现" class="headerlink" title="流程复现"></a>流程复现</h2><p>我们把上面的伪代码用Swift 5 100%重写一下，不作修改。先实现两个字符串扩展，MD5方法和<code>characterAtIndex</code>：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">extension String &#123;
    &#x2F;&#x2F; 获得字符串在索引处的字符
    func characterAtIndex(index: Int) -&gt; Character? &#123;
        var cur &#x3D; 0
        for char in self &#123;
            if cur &#x3D;&#x3D; index &#123;
                return char
            &#125;
            cur +&#x3D; 1
        &#125;
        return nil
    &#125;
    var md5: String &#123;
        let utf8 &#x3D; cString(using: .utf8)
        var digest &#x3D; [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))
        CC_MD5(utf8, CC_LONG(utf8!.count - 1), &amp;digest) &#x2F;&#x2F; 记得import CommonCrypto
        return digest.reduce(&quot;&quot;) &#123; $0 + String(format: &quot;%02X&quot;, $1) &#125;
    &#125;
    &#x2F;&#x2F; 这样我们就可以通过xxx.md5的方式加密了，非常便捷
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再写验证函数：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">func verifySerial(_ serial: String, name: String) &#123;
    let encodedName &#x3D; name.data(using: .utf8)
    if serial.count &#x3D;&#x3D; 16 &#123;
        let processedSerial &#x3D; String(serial.prefix(6))
        &#x2F;&#x2F; let processedSerialData &#x3D; NSData(data: processedSerial.data(using: .utf8)!)
        &#x2F;&#x2F; let snLength &#x3D; processedSerialData.count
        &#x2F;&#x2F; let snBytes &#x3D; processedSerialData.bytes &#x2F;&#x2F; 计算相关值
        &#x2F;&#x2F; let md5val &#x3D; MD5(snBytes, snLength, 0x0); &#x2F;&#x2F; MD5 encryption
        &#x2F;&#x2F; 有了我们的md5函数上面的计算都不需要了
        var md5str &#x3D; processedSerial.md5
        
        if processedSerial.md5.uppercased() &#x3D;&#x3D; &quot;66EAD6FE7CBE7987B7C4B1A1EED0E5A5&quot; &amp;&amp; serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; &#123;
            &#x2F;&#x2F; md5val &#x3D; [name dataUsingEncoding:NSUTF8StringEncoding];
            &#x2F;&#x2F; md5vallen &#x3D; [md5val length]; &#x2F;&#x2F; 计算相关值
            &#x2F;&#x2F; md5valbytes &#x3D; [md5valbytes bytes];
            &#x2F;&#x2F; md5OfMd5val &#x3D; MD5(md5valbytes, md5vallen, 0x0);
            &#x2F;&#x2F; 上面的全都不需要了
            
            &#x2F;&#x2F; 创建一些索引，方便我们截取字符串
            let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)
            let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)
            let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)
            let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)
            if name.md5.prefix(7) &#x3D;&#x3D; serial[index6...index12] &#123; &#x2F;&#x2F; prefix用来取前7位
                if serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; &#123;
                    &#x2F;&#x2F; Registered
                    &#x2F;&#x2F; (@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);
                    print(&quot;Registered! &quot;)
                &#125;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的if有点多，我们再以经典Swift风格写一手优雅的代码，让它返回一个值：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">func verifySerial(_ serial: String, name: String) -&gt; Bool &#123;
    guard serial.count &#x3D;&#x3D; 16 else &#123; return false &#125;
    
    let processedSerial &#x3D; String(serial.prefix(6))
    guard processedSerial &#x3D;&#x3D; &quot;KRACK-&quot; else &#123; return false &#125;
    guard serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; else &#123; return false &#125;
    
    let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)
    let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)
    let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)
    let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)
    
    guard serial[index6...index12] &#x3D;&#x3D; name.md5.prefix(7).uppercased() else &#123; return false &#125;
    guard serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; else &#123; return false &#125;
    
    return true
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>guard &lt;statement&gt; else &#123;&#125;</code>的作用是，确保<code>&lt;statement&gt;</code>为真，否则执行<code>else</code>代码块。</p>
</blockquote>
<h2 id="序列号生成"><a href="#序列号生成" class="headerlink" title="序列号生成"></a>序列号生成</h2><p>有了验证函数做基础，我们就知道什么样的SN能被<code>verifySerial</code>接受。格式是：<code>KRACK-&lt;用户名的md5值取前7位&gt;FBC</code>。写一个Keygen，超级简单。</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">func generateSerial(from name: String) -&gt; String &#123;
    let nameMD5 &#x3D; name.md5.prefix(7).uppercased()
    return &quot;KRACK-\(nameMD5)FBC&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>果然是破解容易分析难啊！</p>
<h2 id="完善注册机"><a href="#完善注册机" class="headerlink" title="完善注册机"></a>完善注册机</h2><p>完善注册机，把我们的Keygen做成命令行形式，有<code>-gv</code>两个功能，g是生成模式，v是验证模式。</p>
<p>全部代码<code>main.c</code>：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">import Foundation
import CommonCrypto

func verifySerial(_ serial: String, name: String) -&gt; Bool &#123;
    guard serial.count &#x3D;&#x3D; 16 else &#123; return false &#125;
    let processedSerial &#x3D; String(serial.prefix(6))
    guard processedSerial &#x3D;&#x3D; &quot;KRACK-&quot; else &#123; return false &#125;
    guard serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; else &#123; return false &#125;
    let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)
    let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)
    let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)
    let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)
    guard name.md5.prefix(7).uppercased() &#x3D;&#x3D; serial[index6...index12] else &#123; return false &#125;
    guard serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; else &#123; return false &#125;
    return true
&#125;

func generateSerial(from name: String) -&gt; String &#123;
    let nameMD5 &#x3D; name.md5.prefix(7).uppercased()
    return &quot;KRACK-\(nameMD5)FBC&quot;
&#125;

func askAndGenerate() &#123;
    print(&quot;Username:&quot;, terminator: &quot; &quot;)
    if let uname &#x3D; readLine() &#123;
        print(&quot;Serial: \(generateSerial(from: uname))&quot;)
    &#125;
    print(&quot;-----------------------&quot;)
    askAndGenerate()
&#125;

func askAndValidate() &#123;
    print(&quot;Username:&quot;, terminator: &quot; &quot;)
    if let uname &#x3D; readLine() &#123;
        print(&quot;Serial:&quot;, terminator: &quot; &quot;)
        if let sn &#x3D; readLine() &#123;
            let result &#x3D; verifySerial(sn, name: uname)
            print(result ? &quot;Serial is valid.&quot; : &quot;Serial is invalid.&quot;)
        &#125;
    &#125;
    print(&quot;-----------------------&quot;)
    askAndValidate()
&#125;

print(&quot;Keygen of Pie.app - by @TLHorse from www.52pojie.cn&quot;)

let argv &#x3D; ProcessInfo.processInfo.arguments
guard argv.count &#x3D;&#x3D; 2 else &#123;
    for i in argv &#123;print(i)&#125;
    print(&quot;PieKeygen: error: 2 arguments is needed&quot;)
    exit(1)
&#125;
switch argv[1] &#123;
case &quot;-g&quot;:
    print(&quot;--- Generation mode ---&quot;)
    askAndGenerate()
case &quot;-v&quot;:
    print(&quot;--- Validation mode ---&quot;)
    askAndValidate()
default:
    print(&quot;PieKeygen: error: illegal operand\nusage: PieKeygen [-gv]&quot;)
&#125;

extension String &#123;
    func characterAtIndex(index: Int) -&gt; Character? &#123;
        var cur &#x3D; 0
        for char in self &#123;
            if cur &#x3D;&#x3D; index &#123;
                return char
            &#125;
            cur +&#x3D; 1
        &#125;
        return nil
    &#125;
    var md5: String &#123;
        let utf8 &#x3D; cString(using: .utf8)
        var digest &#x3D; [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))
        CC_MD5(utf8, CC_LONG(utf8!.count - 1), &amp;digest)
        return digest.reduce(&quot;&quot;) &#123; $0 + String(format:&quot;%02X&quot;, $1) &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-kg-product.png" alt="pie-kg-product"></p>
<h1 id="到底如何还原代码"><a href="#到底如何还原代码" class="headerlink" title="到底如何还原代码"></a>到底如何还原代码</h1><p>如何把Hopper的伪代码尽可能还原成真实的OC？我在Hook中有所提及，但是在这里我细说一下我研究的方法。</p>
<p>比如拿</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">(@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>来说吧：</p>
<ol>
<li><p>首先，去掉所有<strong>单独成括号的选择器</strong>，特征是<code>(@selector(x​xx))</code>，只带@不带&amp;号，这些选择器没有地址不被调用：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>现在整条语句只剩下一个括号，里面有许多“项”，由逗号分隔。从开头一直往后，逐项翻译成父子关系，<strong>遇到方法名称时，将方法名称后面的所有项翻译成这个方法的参数</strong>，把它们按照OC语法拼在一起：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:var_60];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>最后，把伪代码中的变量通过上下文替换成真实值。在伪代码中<code>var_60 = self;</code>，所以进行替换。最终还原的代码：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其实就是把Hopper生成的替换成hook环境中真实的东西的过程。</p>
</li>
</ol>
<h1 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h1><p><strong>分析，Hook，KG一条龙，总算是完成了。</strong></p>
]]></content>
      <categories>
        <category>反编译</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>注册机</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>“鼹鼠夫妻”笑谈</title>
    <url>/posts/229054ec/</url>
    <content><![CDATA[<p>同学送我一对小鼹鼠——一夫、一妻。妻子体型肥硕，性格活泼，凡事总愿意起主导；丈夫身材娇小，性格稳重，儒雅斯文，不争不抢，全由妻子任意折腾。</p>
<p>她听利我的声音肯定最先睁眼，身子舒展开来，两只透光的耳朵坚起，满腔鸡血，上窜下跳，滑稽可爱。</p>
<p>任凭她百般折腾，他也懒得睁眼瞥她一下，急得她不得不用肥硕溜圆的屁股，把他硬生生挤进一个角落，用利落的瓜子撩他的鼻孔。更有甚为，干脆把他存在身下，枕着他瘦弱的身体享受阳光浴。他的眼睛犹如一颗星星，在黑暗的夹缝中闪烁着，说不上来是真心懒情，还是无力反抗。她累了，在他眼前留下一坨粪便，他也无动于衷。</p>
<p>我一真在将他们分离开与任由事态发展下去之间徘徊。我真觉得他们像一对老夫妻，活灵活现。</p>
<p>终于有一天，我把她拎出去了。</p>
<p>我将他放在个纸盒里晾着，叫她面壁思过，狠刹她的凶悍作风。接着，我暗喜丈夫能好好享受难得的清静与安逸。</p>
<p>她的锐气制没了，他的淡定与斯文也削没了。他一改往日的作派，看着他的妻子被隔离出去，抓耳挠腿，隔笼相望，看在眼里，急在心上。</p>
<p>原来一心想帮助他的我，不懂鼹鼠的幸福。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>历史联欢课</title>
    <url>/posts/47e50f09/</url>
    <content><![CDATA[<p>有李老师镇守的联欢会，欢不起来。台上演得呆板，台下看得死板。食品在同学们嘴里无声地被嚼着。</p>
<p>“接下来咱请一个9班的同学给表演个节目。”李老师突然打断了我们。</p>
<p>“据说是摸仿我讲课的。”他嘴角露出了不自在的一丝笑。台下忽然就燃了起来。</p>
<p>一个板着脸的九班小伙，歪着脖，不紧不慢，踱步进入敬室，左手托着一摞教研用具，上面不忘放上“小蜜蜂”。欢呼声与尖叫声在台下愈响愈烈。</p>
<p>他轻松地将U盘插上向板，手一样，连续关掉了几个弹窗，打开了幻灯片，就像真的李老师，操作娴熟，一气呵成。</p>
<p>“今天，我们讲《动荡的春秋时期》这一课，”他低声吼看，“这一课在于——”</p>
<p>“动——荡！”他忽然大声嚷起来，逗得全班哄堂大笑。有人按耐不住把口中的著片吐了出来，有人将吸食的牛奶从嘴里喷了出来，有人踩碎了自己的生物卷子却毫无察觉。</p>
<p>李老师低着头，掩饰不住心笑家从嘴角泄露出去。他打开手机，在主屏幕滑动，却什么也没干。</p>
<p>“壮小伙子，”他忽她指着一旁的滑子豪说，“就是你了！”</p>
<p>台下再次响起了尖叫声与喝叫声。谁也没想到这位“李老师”眼光这么好，一眼就相中了我们班的“重点陪养对象”。所有人将目光投向一处，半张着嘴，露出惊喜的笑容。</p>
<p>“春秋时期秦国是怎样尊王攘夷的？”“额…………是这样的…………”“算你过，坐下！”</p>
<p>孝老师摘下眼镜，用手抹了抹脸，朝台上瞥了一眼。</p>
<p>就这样，有李老师参与的联欢会，终于欢起来了。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>我曾养过一群鱼</title>
    <url>/posts/778935bb/</url>
    <content><![CDATA[<p>推开家门，将目光投到眼前落寞的小院子，树木孤单，花草调零，地砖断裂，不见池水，只有满地的灰尘与石沙；回忆起这里往昔的峥嵘，鸟语花香，池里碧波荡漾，鱼儿潜跃，不觉有种悲伤之感，心痛。</p>
<p>那估计是六年前的一个盛夏，我和爸爸从花鸟鱼虫市场提回来一袋子鱼。红的、黑的、金的，我把它们倒入门前的小院里，它们好像亮丽的缎带，在阳光的照射下，窜来窜去，闪耀着如金一般的光芒。在院子里玩耍时，可以拿一两根小草挑逗它们；冻笔作业懒写时，可以在天花板上看利它们的倒影，由此度过一两刻钟的光阴。</p>
<p>然而好日子不长，一天我学回家，突然看见一条鱼挺着白肚子滚在水面上，一动不动。我将它按下池底，它又漂起来。我着急了，起快去找妈妈。我在书房焦急地等待着指针的旋转。不一会儿，噩耗传来——它死了！</p>
<p>一只又一只鱼漂到水面，挺起了苍白的肚子。我们束手无策。爸爸在池里撒了一盒高锰酸钾，情况有所好转，但那时所剩的鱼寥寥无几，我们也只好从姥姥家匀了几条过来。</p>
<p>又是一年的寒冬腊月，我们忘记将鱼迁移到室内了。第一天它们还自由自在，第二天早上我出门，简直不敢相信自己的双眼——冰雕！池面如铜镜，反射着冬天的冰冷，而下面，一条一条的鱼，或仰，或平，或侧身，或正常，定格在水池中，深浅不一，仿佛飘逸的仙人，又好像挣扎于绝境。</p>
<p>全家人再一次束手无策。</p>
<p>傍晚时，我坐不住了，我拿铁铁凿开池面——真的这样做了，迫不及待地等着这些鱼儿的重生。我爸爸在旁边看着我，但他又有什么理由制止我呢？</p>
<p>第二天，这些鱼全部漂在了水面上。我为它们挖了鱼冢，下了葬。我怅然若失。我永无改正我过错的机会了！</p>
<p>自此，我家永不养鱼。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>街景一角</title>
    <url>/posts/f6454479/</url>
    <content><![CDATA[<p>宽阔的街道、热闹的街景，人行道旁是一排景气的商铺，然而她的小摊只占一角。</p>
<p>天空中压根就没有月亮，而是乌漆墨黑的一片；嘴边的空气寒冷的如刀锋割人，夹杂着一大把一大把呛鼻的灰。我每晚放学，上了人行道，闭着眼都能猜到，她准在一旁卖零食——一位开三轮车的老奶奶，三轮车就是她琳琅满目的货摊。什么三根葱，什么亲嘴烧辣条，什么可口可乐，什么软糖，尽在货摊中堆成一座座“小山丘”，应有尽有，分门别类，摆放却又稍有凌乱。一个普通的小钨丝灯高悬着，亮白亮白的，货摊上的纸壳子和塑料包装好像都发了光。</p>
<p>她却躲着那片亮堂堂的白光，在灯泡后的黑暗中静坐着。微弱的亮光打过来：削瘦无比的身子驮着背，微微前倾；古铜色的皮肤上，阴影遍布，呈现出千沟万壑。她沧桑的脸上毫无表情，既无欣喜，也无悲伤；既无期盼，也无失落。我不禁向下看，载着货物的三轮车，同她一样苍老，酷似一只疲惫不堪的骆驼：布满铁锈的钢板，随时要破裂散架；窄小的轮胎，随时要爆裂。</p>
<p>一个初中生，急匆匆奔跑着过来。他跑到三轮车尾，在食品堆里翻了翻，拿了几条“小样”软糖，与老奶奶交谈了几句，便付钱而去；又有两个同学在一片欢笑中，互相追逐着，经过老奶奶的车子，买两包辣条就扬长离开。一时之间顾客们都走光了，老奶奶只好寂寞地坐在那里，倚着车把托着腮，不时向四处张望。</p>
<p>走着走着，就走过了这一角。</p>
<p>老奶奶孤单寂寞的身影，让我愈发感到冬的寒冷。年逾古稀的她，本该儿孙绕膝，在家享受天伦之乐，然而她与冬做伴，孤守着小小的零食摊……</p>
<p>多么希望在这个严冬中，老奶奶所拥有的，不只是街道的一角，而是温暖幸福的晚年。</p>
]]></content>
      <categories>
        <category>作文</category>
      </categories>
      <tags>
        <tag>记叙文</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Typora的逆向工程</title>
    <url>/posts/f4ab0062/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学业负担逐渐加重，好久没有整逆向工程了。</p>
<p>正巧最近我用的Markdown编辑器发布了1.0版本，到官网看看，发现开始收费了，售价 $14.99 ，最多三台设备。可以先进行试用，试用期到了，就需要付费。抱着试试看的心态，今天就拿Typora Mac练练手。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>把Typora丢进Hopper里分析一波。对于这个简单轻量级的软件，我很容易就可以搜到关键词。拿subscription、trial、days、license这些敏感词试一试，就可以发现一些相关的OC类，例如<code>LicenseManager</code>和<code>LicenseWindowController</code>。我将一些之后需要逆向的函数加了黑。</p>
<img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/12/11/typora-search.png" alt="搜索关键词" style="zoom:50%;" />

<p>先打开<code> -[LicenseManager hasLicense]</code>，看上去是判断是否有许可证的函数。生成伪代码，很容易发现是个简单的逻辑判断流程，rax寄存器储存返回值。</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">&#x2F;* @class LicenseManager *&#x2F;
-(char)hasLicense &#123;
    rdi &#x3D; self-&gt;_hasLicense;
    if (rdi !&#x3D; 0x0) &#123;
            rax &#x3D; [rdi boolValue];
            rax &#x3D; rax !&#x3D; 0x0 ? 0x1 : 0x0;
    &#125;
    else &#123;
            rax &#x3D; 0x1;
    &#125;
    rax &#x3D; rax &amp; 0xff;
    return rax;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们直接在汇编中按下<kbd>Option+A</kbd>，输入<code>mov rax, 0x1; ret</code>进行暴破，如图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/12/11/typora-bp.png" alt="暴破"></p>
<p>接下来，用调试器运行。很讽刺的一件事是，试用期提醒的弹窗直接消失了。我把系统时间往后调，软件仍然可以正常运行，这不是伪破解。所以，这就破解完了……</p>
<p>但是，还有一件事。我发现虽然暴破的软件可以正常使用，但是菜单栏上有个“查看许可证”按钮。点开它，软件就会检测出，剩余试用天数已经归零，此时弹出的窗口只有激活和退出两个按钮。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/12/11/typora-licensebt.png" alt="“查看许可证”按钮"></p>
<p>为了防止误触这个键，就得把对话框去掉。我不想再tweak试用天数了，更懒得写注册机，所以我准备让它弹出另一个对话框，显示软件已破解。</p>
<h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p>既要暴破软件，还要加对话框，我就用了动态库注入破解。我用的是<code>MonkeyDev</code>框架，也就是<code>substrate</code>。先新建<code>MonkeyAppMac</code>工程，命名<code>TyporaTweak</code>，然后将Typora拖进<code>TargetApp</code>，最后打开<code>TyporaTweak.m</code>文件。</p>
<p>先写两个替代函数：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#include &lt;Cocoa&#x2F;Cocoa.h&gt; &#x2F;&#x2F; 记得引入Cocoa

@class LicenseManager; &#x2F;&#x2F; 定义累&#x3D;类

&#x2F;&#x2F; hook是否有许可证
static char new_hasLicense(LicenseManager* self, SEL _cmd) &#123;
    return 1;
&#125;

&#x2F;&#x2F; hook许可证弹窗
static void new_showLicense(LicenseManager* self, SEL _cmd, char arg2)&#123;
 	  &#x2F;&#x2F; 新建一个警告弹窗
    NSString *message &#x3D; @&quot;您正在使用Typora破解版&quot;;
    NSAlert *alert &#x3D; [NSAlert new];
    [alert addButtonWithTitle:@&quot;知道了&quot;];
    [alert setMessageText:message];
    [alert setAlertStyle:NSAlertStyleCritical];
    [alert runModal];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在动态库加载入口hook（一些基本的语法，可在官网上搜索，不再解释）：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">static void __attribute__((constructor)) initialize(void) &#123;
    MSHookMessageEx(objc_getClass(&quot;LicenseManager&quot;), @selector(hasLicense), (IMP)&amp;new_hasLicense, NULL);
    MSHookMessageEx(objc_getClass(&quot;LicenseManager&quot;), @selector(showLicense:), (IMP)&amp;new_showLicense, NULL);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>所有的代码看起来像这样：</p>
<pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">#import &quot;TyporaTweak.h&quot;
#import &quot;substrate.h&quot;
#include &lt;Cocoa&#x2F;Cocoa.h&gt;

@class LicenseManager;

static char new_hasLicense(LicenseManager* self, SEL _cmd) &#123;
    return 1;
&#125;

static void new_showLicense(LicenseManager* self, SEL _cmd, char arg2)&#123;
    NSString *message &#x3D; @&quot;您正在使用Typora破解版&quot;;
    NSAlert *alert &#x3D; [NSAlert new];
    [alert addButtonWithTitle:@&quot;知道了&quot;];
    [alert setMessageText:message];
    [alert setAlertStyle:NSAlertStyleCritical];
    [alert runModal];
&#125;

static void __attribute__((constructor)) initialize(void) &#123;
    MSHookMessageEx(objc_getClass(&quot;LicenseManager&quot;), @selector(hasLicense), (IMP)&amp;new_hasLicense, NULL);
    MSHookMessageEx(objc_getClass(&quot;LicenseManager&quot;), @selector(showLicense:), (IMP)&amp;new_showLicense, NULL);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行一下，大功告成！</p>
<p><img src="https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/12/11/typora-product.png" alt="typora破解后"></p>
<h1 id="动态库注入"><a href="#动态库注入" class="headerlink" title="动态库注入"></a>动态库注入</h1><p>拿到了<code>libTyporaTweak.lib</code>，就可以对二进制注入了。</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">.&#x2F;insert_dylib &lt;动态库路径&gt; &lt;Mach-O&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但MonkeyDev已经帮我们完成了这一步。将Typora.app从TargetApp文件夹里拖出，即是我们的成品。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Typora就这么被逆向完了。不得不说，它在反破解方面还有待提高。没有反调试、没有加密加壳，什么都没有。这是值得开发者维护的地方。但就软件本身而言，它的确是个良心的Markdown编辑器，值得我们去购买支持。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
</search>
