{"title":"使用动态库注入优雅破解 CrossOver","uid":"f1e3b848a74381b642345951ae64d11f","slug":"使用动态库注入优雅破解 CrossOver","date":"2020-04-13T13:23:41.000Z","updated":"2021-10-07T00:48:59.288Z","comments":true,"path":"api/articles/使用动态库注入优雅破解 CrossOver.json","keywords":null,"cover":[],"content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上次我写过一篇叫做<a href=\"https://www.52pojie.cn/thread-1126808-1-1.html\">Hopper 之 CrossOver 19 破解</a>的文章，那么今天，我再写一篇 CrossOver 19 的破文。上一篇文章里，我用了“直接修改二进制文件”的方法来破解应用，而这次，我则通过动态库注入的方法来破解 CrossOver 19——这是一个巧妙、新奇的方法，说白了就是 hook，你会喜欢上它的。我还要感谢<a href=\"https://www.52pojie.cn/home.php?mod=space&uid=476930\">@云在天</a>大神在我的<a href=\"https://www.52pojie.cn/thread-1132170-1-1.html\">CleanMyMac X 破解贴</a>里的指导，要不是她，可能我到现在还不知道什么是动态库注入。</p>\n<p>前言的最后，我再说一下来意。我只是想教大家“破解方法”，而不是给大家“破解软件”。就拿例子说吧，我现在用的 Hopper Disassembler 可是正版的。因此，如果你喜欢 CrossOver 19，请购买正版。</p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>从<a href=\"https://www.crossoverchina.com/\">CrossOver 官网</a>上下载最新版的 CrossOver 19 。</li>\n<li><a href=\"https://www.hopperapp.com/\">Hopper Disassembler v4</a> 一枚。</li>\n<li>与上篇文章不同的是，我们需要 Xcode（我的版本是11）。 </li>\n</ul>\n<h1 id=\"分析软件\"><a href=\"#分析软件\" class=\"headerlink\" title=\"分析软件\"></a>分析软件</h1><h2 id=\"分析-UI\"><a href=\"#分析-UI\" class=\"headerlink\" title=\"分析 UI\"></a>分析 UI</h2><p>首先打开<code>CrossOver</code>，简单的看了一下，分析出几个信息：</p>\n<ul>\n<li><p>打开软件后弹出了一个要钱弹窗，弹窗里提示了试用剩余天数，并提示你购买软件或者进行使用；</p>\n</li>\n<li><p>要钱弹窗中有两个需要关注的按钮，一个是 <code>现在试用</code>，另一个是 <code>使用购买信息解锁</code> ;</p>\n</li>\n<li><p>按下 <code>现在试用</code> 按钮，可以直接跳转到App里，开始14天试用；</p>\n</li>\n<li><p>开始试用App后，在<code>CrossOver</code>里仍然可以进行App激活操作。</p>\n</li>\n<li><p>CrossOver 没有附加反调试工具。</p>\n<p>于是，我们就有如下的破解思路：</p>\n</li>\n</ul>\n<ol>\n<li>Patch 剩余天数；</li>\n<li>Patch 使用购买信息解锁的验证流程。</li>\n</ol>\n<p>本文中只讲述第一种方法。</p>\n<h2 id=\"使用-Hopper-分析\"><a href=\"#使用-Hopper-分析\" class=\"headerlink\" title=\"使用 Hopper 分析\"></a>使用 Hopper 分析</h2><p>拖进 Hopper，先分析一波，看看有什么函数。本来想搜索UI中的字符串，字符串搜索无果后，根据“剩余天数”的英文“left”，搜索关键词：</p>\n<p><img src=\"https://i.loli.net/2020/03/27/DhqpY65tncdk3fO.png\" alt=\"搜索left\"></p>\n<p>我们发现，第一个函数<code>-[CXApplication daysLeft]</code>，于是打开伪代码发现，这个函数返回的是一个<code>int</code>，极有可能是剩余的天数。我们可以尝试 Patch 这里，使得该函数永远返回十六进制<code>0x8ef8</code>（等同于 36600 天）。</p>\n<p>按照上一篇文章的破解方法，我们只需要：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov rax, 0x8ef8\nret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>然后试用天数就永远是 36600 天了。但是别忘了，我们今天是要讲如何使用动态库注入来 hook 函数的，接下来，咱们就开始 hook。</p>\n<h1 id=\"构建动态库\"><a href=\"#构建动态库\" class=\"headerlink\" title=\"构建动态库\"></a>构建动态库</h1><h2 id=\"动态库注入原理\"><a href=\"#动态库注入原理\" class=\"headerlink\" title=\"动态库注入原理\"></a>动态库注入原理</h2><p>在<code>macOS</code>下的应用程序，绝大多数都会用<code>Objective-C</code>或<code>Swift</code>进行编译（<code>Python</code>这类的先不谈）。</p>\n<p>如果程序使用了<code>Objective-C</code>编译，我们可以仗着<code>Objective-C</code>的动态消息传送机制与<code>runtime</code>，在程序运行时进行函数的调换。</p>\n<p>然而我们 crakers 都面对的是已经编译好的程序，所以我们要把函数调换的过程写到一个动态库中，然后再用动态库注入工具（<code>insert_dylib</code>之类的）注入到原来的二进制文件中。</p>\n<h2 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h2><p>首先，<a href=\"xcode://\">打开 Xcode</a>（按一下这里你会神奇地发现 Xcode 打开了），新建项目，选择<code>macOS</code> &gt; <code>Library</code>，新建动态库项目，如图：</p>\n<p><img src=\"https://i.loli.net/2020/03/30/bsBnRwa75o4zJu8.png\" alt=\"选择类型\"></p>\n<p>动态库的名称可以随便起，此处叫做<code>CrossOverPatch</code>，<code>Framework</code>选择<code>Cocoa</code>，<code>Type</code>选择<code>Dyamic</code>（动态）。随便找个地方保存项目即可。</p>\n<p>现在你会得到一个动态库项目。</p>\n<h2 id=\"编写动态库\"><a href=\"#编写动态库\" class=\"headerlink\" title=\"编写动态库\"></a>编写动态库</h2><p>首先打开工程文件里的<code>CrossOverPatch.m</code>文件，输入：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">#import &quot;CrossOverPatch.h&quot;\n#import &lt;objc&#x2F;runtime.h&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>我们用两个<code>#import</code>语句，将<code>CrossOverPatch.h</code>文件与<code>objc/runtime.h</code>库引入。<code>CrossOverPatch.h</code>文件（头文件），是每个<code>.m</code>文件里必须引用的。而<code>objc/runtime.h</code>库就是大名鼎鼎的运行时类库。</p>\n<p>之后我们在下面声明一个实现<code>@implementation</code></p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">@implementation CrossOverPatch\n\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>接下来，我们在实现里定义一个 hook 方法：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">- (int)daysLeftHook &#123;\n    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    return 36600;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>我们在下面的步骤中要用这个方法来替换原函数<code>daysLeft</code>，实现 hook。</strong>这里需要注意一点，我们定义的这个函数的返回值（<code>int</code>）和参数列表（无）<strong>需要与原函数相同</strong>。<code>NSLog</code>则是打印语句，方便我们后期检测程序。最后的<code>return</code>语句，让函数返回了36600这个值。你当然也可以把36600写作0x8ef8。</p>\n<p>我们在实现里添加一个<code>+ (void) load</code>方法，如下：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">+ (void)load &#123;\n    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    Method origMethod &#x3D; class_getInstanceMethod(NSClassFromString(@&quot;CXApplication&quot;), NSSelectorFromString(@&quot;daysLeft&quot;));\n    Method newMethod &#x3D; class_getInstanceMethod([CrossOverPatch class], @selector(orphansArray:));\n    method_exchangeImplementations(origMethod, newMethod);\n    NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们一行一行地讲解代码：</p>\n<ol>\n<li>函数<code>load</code>定义。<code>load</code>函数会在动态库<strong>被加载时</strong>触发；</li>\n<li>打印日志；</li>\n<li>同上；</li>\n<li>定义变量<code>origMethod</code>，它的类型是<code>Method</code>，它的值是<strong>原程序的</strong><code>daysLeft</code>方法。<ol>\n<li><code>class_getInstanceMethod::</code>函数可以获取一个类（第一个参数）的一个实例方法（第二个参数）；</li>\n<li><code>NSSelectorFromString:</code>可以通过一个字符串（第一个参数）来获取一个类；</li>\n<li><code>NSSelectorFromString</code>可以通过一个字符串（第一个参数）获取一个<code>Selector</code>；</li>\n</ol>\n</li>\n<li>定义变量<code>newMethod</code>，类型是<code>Method</code>，它的值是<strong>我们刚才自定义的<code>daysLeftHook</code>方法</strong>，我们要用这个方法来替换第4行的<code>daysLeft</code>方法。</li>\n<li>将第四行和第五行定义的新、旧两个函数通过<code>method_exchangeImplementations::</code>交换。这样的话，原程序的<code>daysLeft</code>就成了我们自定义的<code>daysLeftHook</code>，而我们自定义的<code>daysLeftHook</code>就成了原程序的<code>daysLeft</code>，也就意味着成功 hook 了。</li>\n<li>打印日志。</li>\n</ol>\n<p><code>CrossOverPatch.m</code>写完了。别忘了打开<code>CrossOverPatch.h</code>文件，声明函数：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">@interface CrossOverPatch : NSObject\n+(void)load;\n@end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>按下<code>Cmd</code> + <code>B</code>编译一下，最终得到动态库文件：<code>libCrossOverPatch.dylib</code>！</p>\n<h1 id=\"注入动态库\"><a href=\"#注入动态库\" class=\"headerlink\" title=\"注入动态库\"></a>注入动态库</h1><p>离破解只差一步——注入。方法有许多：运行<code>bash</code>脚本、修改<code>info.plist</code>……不过我更倾向于使用<code>insert_dylib</code>工具注入。点击<a href=\"xcode://clone?repo=https%3A%2F%2Fgithub.com%2FTyilo%2Finsert_dylib\">这个链接</a>即可将<code>insert_dylib</code>项目克隆到<code>Xcode</code>，编译得到<code>insert_dylib</code>可执行文件。</p>\n<ol>\n<li>把<code>insert_dylib</code>、<code>CrossOverPatch.dylib</code>和 CrossOver 19 应用程序的<strong>原来的二进制文件</strong>的<strong>绝对</strong>路径记录下来。</li>\n<li>打开终端，输入命令： <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cd [insert_dylib的路径]\n$ .&#x2F;insert_dylib [dylib的路径] [原来的二进制文件的路径]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n回车后，如果出现<code>LC_CODE_SIGNATURE load command found. Remove it? [y/n]</code>，那么就按下<code>y</code>，回车。</li>\n</ol>\n<p>如果出现<code>Added LC_LOAD_DYLIB to /Applications/CrossOver.app/Contents/MacOS/CrossOver_patched</code>，代表注入成功。</p>\n<p>打开访达，进入<code>/Applications/CrossOver.app/Contents/MacOS/</code>位置，你还会发现有两个文件：<code>CrossOver</code>和<code>CrossOver_patched</code>。其中<code>CrossOver_patched</code>就是<strong>已经被我们注入的</strong>文件。将原来的<code>CrossOver</code>二进制删除或更改名称，将<code>CrossOver_patched</code>更名为<code>CrossOver</code>。</p>\n<h1 id=\"改头换面\"><a href=\"#改头换面\" class=\"headerlink\" title=\"改头换面\"></a>改头换面</h1><p>通过下图找到电子权利信息：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-creditspath.png\" alt=\"电子权利信息路径\"></p>\n<p>找到后，用文本编辑打开，在文件开头加上一句类似下面的话：</p>\n<blockquote>\n<p>这个版本的CrossOver已经由xxx破解。你可以放心使用。注意，请勿广泛传播……</p>\n</blockquote>\n<h1 id=\"验证破解\"><a href=\"#验证破解\" class=\"headerlink\" title=\"验证破解\"></a>验证破解</h1><p>双击<code>CrossOver</code>二进制文件，即可打开应用程序。可以看见试用天数已经破解：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-36600.png\" alt=\"剩余天数破解成功\"></p>\n<p>电子权利信息也被修改：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/3/27/hop-co-credits.png\" alt=\"留下足迹\" style=\"zoom:50%;\" />\n\n<p>与此同时，你的电脑应该会弹出终端窗口：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; START DYLIB INJECT &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; GETTING METHOD &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD PATCHING &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; METHOD SWIZZLED &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>","text":"前言上次我写过一篇叫做Hopper 之 CrossOver 19 破解的文章，那么今天，我再写一篇 CrossOver 19 的破文。上一篇文章里，我用了“直接修改二进制文件”的方法来破解应用，而这次，我则通过动态库注入的方法来破解 CrossOver 19——这是一个巧妙、新奇...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"},{"name":"Hook","slug":"Hook","count":2,"path":"api/tags/Hook.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87\"><span class=\"toc-text\">准备</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">分析软件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-UI\"><span class=\"toc-text\">分析 UI</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Hopper-%E5%88%86%E6%9E%90\"><span class=\"toc-text\">使用 Hopper 分析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93\"><span class=\"toc-text\">构建动态库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%BA%93%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">动态库注入原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">新建项目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E5%8A%A8%E6%80%81%E5%BA%93\"><span class=\"toc-text\">编写动态库</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%85%A5%E5%8A%A8%E6%80%81%E5%BA%93\"><span class=\"toc-text\">注入动态库</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%94%B9%E5%A4%B4%E6%8D%A2%E9%9D%A2\"><span class=\"toc-text\">改头换面</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">验证破解</span></a></li></ol>","author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"执行一个优美的并行程序","uid":"75b57553f8bf0755102a1265e2955d26","slug":"执行一个优美的并行程序","date":"2020-04-30T02:49:36.000Z","updated":"2020-05-06T09:53:19.000Z","comments":true,"path":"api/articles/执行一个优美的并行程序.json","keywords":null,"cover":[],"text":"场景我最近用Python的print，通过打印一帧帧的进度条，实现了一个进度条样式，顺便跟大家分享一下代码： import time AT_PROGRESS_BAR &#x3D; [ &quot;( )&quot;, &quot;(@ )&quot;, &quot;(@@ )&q...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"Python","slug":"Python","count":5,"path":"api/tags/Python.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}},"next_post":{"title":"教你过关吾爱破解游戏《圈小猫》","uid":"4e44912726150161c7f0d572def57fc3","slug":"教你过关吾爱破解游戏《圈小猫》","date":"2020-03-29T08:40:17.000Z","updated":"2021-10-07T00:48:59.289Z","comments":true,"path":"api/articles/教你过关吾爱破解游戏《圈小猫》.json","keywords":null,"cover":[],"text":"前言我刚结识吾爱破解网站，就认识了网站的隐藏游戏《圈小猫》。我把《圈小猫》这个游戏吹爆——这个游戏确实好玩，但这是只有像我一样聪明的人才能玩得起的游戏。 因此，这篇文章将会教你如何篡改这个游戏，实现任何人，局局都能赢（如果说逆向这个游戏，未免有些太夸张了）。如果，你以前玩游戏的时...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"HTML5","slug":"HTML5","count":1,"path":"api/tags/HTML5.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}}}