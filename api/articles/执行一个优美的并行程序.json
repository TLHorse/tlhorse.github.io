{"title":"执行一个优美的并行程序","uid":"75b57553f8bf0755102a1265e2955d26","slug":"执行一个优美的并行程序","date":"2020-04-30T02:49:36.000Z","updated":"2020-05-06T09:53:19.000Z","comments":true,"path":"api/articles/执行一个优美的并行程序.json","keywords":null,"cover":[],"content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>我最近用<code>Python</code>的<code>print</code>，通过打印一帧帧的进度条，实现了一个进度条样式，顺便跟大家分享一下代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\n\nAT_PROGRESS_BAR &#x3D; [\n    &quot;(                    )&quot;, \n    &quot;(@                   )&quot;, \n    &quot;(@@                  )&quot;, \n    &quot;(@@@                 )&quot;, \n    &quot;(@@@@                )&quot;, \n    &quot;(@@@@@               )&quot;, \n    &quot;(@@@@@@              )&quot;, \n    &quot;(@@@@@@@             )&quot;, \n    &quot;(@@@@@@@@            )&quot;, \n    &quot;(@@@@@@@@@           )&quot;,\n    &quot;(@@@@@@@@@@          )&quot;,\n    &quot;(@@@@@@@@@@@         )&quot;,\n    &quot;(@@@@@@@@@@@@        )&quot;,\n    &quot;( @@@@@@@@@@@@       )&quot;,\n    &quot;(  @@@@@@@@@@@@      )&quot;,\n    &quot;(   @@@@@@@@@@@@     )&quot;,\n    &quot;(    @@@@@@@@@@@@    )&quot;,\n    &quot;(     @@@@@@@@@@@@   )&quot;,\n    &quot;(      @@@@@@@@@@@@  )&quot;,\n    &quot;(       @@@@@@@@@@@@ )&quot;,\n    &quot;(        @@@@@@@@@@@@)&quot;,\n    &quot;(         @@@@@@@@@@@)&quot;,\n    &quot;(          @@@@@@@@@@)&quot;,\n    &quot;(           @@@@@@@@@)&quot;,\n    &quot;(            @@@@@@@@)&quot;,\n    &quot;(             @@@@@@@)&quot;,\n    &quot;(              @@@@@@)&quot;,\n    &quot;(               @@@@@)&quot;,\n    &quot;(                @@@@)&quot;,\n    &quot;(                 @@@)&quot;,\n    &quot;(                  @@)&quot;,\n    &quot;(                   @)&quot;,\n    &quot;(                    )&quot;,\n]\ndef print_progress_bar():\n    while True:\n        for i in AT_PROGRESS_BAR:\n            print(i, end&#x3D;&quot;&quot;)\n            time.sleep(0.1)\n            print(&#39;\\r&#39; * len(i), end&#x3D;&quot;&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行效果如下：<br><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-loading.gif\" alt=\"进度条\"><br>然而，我现在有一个函数，叫做<code>long_function()</code>，用来模拟一个执行时间很长的函数：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def long_function():\n    for i in range(20):\n        # 每隔一秒就 print 一下，以示函数正在执行。\n        time.sleep(1)\n        print(&quot;函数正在执行！&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我想让<code>long_function()</code>执行的时候，让<code>print_progress_bar()</code>也一块伴随执行。但是如果我们直接使用如下代码：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    long_function()\n    print_progress_bar()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>两个函数是不会同时执行的。因此，我们就需要使用<code>multiprocessing</code>模块，使用并行程序<a href=\"https://docs.python.org/zh-cn/3.8/library/multiprocessing.html\">^1</a>执行。</p>\n<h1 id=\"需求一：2进程并行执行\"><a href=\"#需求一：2进程并行执行\" class=\"headerlink\" title=\"需求一：2进程并行执行\"></a>需求一：2进程并行执行</h1><p>代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\nfrom multiprocessing import Process\n\nAT_PROGRESS_BAR &#x3D; [\n    &quot;(                    )&quot;, \n    &quot;(@                   )&quot;, \n    &quot;(@@                  )&quot;, \n    &quot;(@@@                 )&quot;, \n    &quot;(@@@@                )&quot;, \n    &quot;(@@@@@               )&quot;, \n    &quot;(@@@@@@              )&quot;, \n    &quot;(@@@@@@@             )&quot;, \n    &quot;(@@@@@@@@            )&quot;, \n    &quot;(@@@@@@@@@           )&quot;,\n    &quot;(@@@@@@@@@@          )&quot;,\n    &quot;(@@@@@@@@@@@         )&quot;,\n    &quot;(@@@@@@@@@@@@        )&quot;,\n    &quot;( @@@@@@@@@@@@       )&quot;,\n    &quot;(  @@@@@@@@@@@@      )&quot;,\n    &quot;(   @@@@@@@@@@@@     )&quot;,\n    &quot;(    @@@@@@@@@@@@    )&quot;,\n    &quot;(     @@@@@@@@@@@@   )&quot;,\n    &quot;(      @@@@@@@@@@@@  )&quot;,\n    &quot;(       @@@@@@@@@@@@ )&quot;,\n    &quot;(        @@@@@@@@@@@@)&quot;,\n    &quot;(         @@@@@@@@@@@)&quot;,\n    &quot;(          @@@@@@@@@@)&quot;,\n    &quot;(           @@@@@@@@@)&quot;,\n    &quot;(            @@@@@@@@)&quot;,\n    &quot;(             @@@@@@@)&quot;,\n    &quot;(              @@@@@@)&quot;,\n    &quot;(               @@@@@)&quot;,\n    &quot;(                @@@@)&quot;,\n    &quot;(                 @@@)&quot;,\n    &quot;(                  @@)&quot;,\n    &quot;(                   @)&quot;,\n    &quot;(                    )&quot;,\n]\n\ndef print_progress_bar():\n    while True:\n        for i in AT_PROGRESS_BAR:\n            print(i, end&#x3D;&quot;&quot;)\n            time.sleep(0.1)\n            print(&#39;\\r&#39; * len(i), end&#x3D;&quot;&quot;)\n            \ndef long_function():\n    for i in range(20):\n        # 每隔一秒就 print 一下，以示函数正在执行。\n        time.sleep(1)\n        print(&quot;函数正在执行！&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    p &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())\n    p.start()\n    long_function()\n    p.join()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在上面的代码中，我们首先在<code>__main__</code>（主程序）里面新建一个<code>Process</code>实例；其次，用<code>start()</code>启动这个程序；第三，运行父程序<code>long_function()</code>，最后再用<code>join()</code>函数等待到程序终止。</p>\n<p>效果（因为两个<code>print</code>语句冲突，所以可能打印的效果不太好，但是是正常的）：<br><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async.gif\" alt=\"效果-需求一\"></p>\n<h1 id=\"需求二：2-进程并行\"><a href=\"#需求二：2-进程并行\" class=\"headerlink\" title=\"需求二：2+进程并行\"></a>需求二：2+进程并行</h1><p>对于2+进程的并行程序来说，我们使用进程池（<code>Pool</code>）来实现会更方便一些。代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\nfrom multiprocessing import Process, Pool # 引入 Pool\n\nAT_PROGRESS_BAR &#x3D; [...] # 为了观看方便，把这个数组省略了\n\ndef print_progress_bar():\n    while True:\n        for i in AT_PROGRESS_BAR:\n            print(i, end&#x3D;&quot;&quot;)\n            time.sleep(0.1)\n            print(&#39;\\r&#39; * len(i), end&#x3D;&quot;&quot;)\n            \ndef long_function():\n    for i in range(20):\n        # 每隔一秒就 print 一下，以示函数正在执行。\n        time.sleep(1)\n        print(&quot;函数正在执行！&quot;)\n\n# 我在这里新增了第三个函数：bfunc，作为第三个进程。\ndef bfunc():\n    for i in range(30):\n        time.sleep(0.5)\n        print(&quot;bfunc&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    pool &#x3D; Pool(2) # 新建一个含有两个进程的进程池\n    pool.apply_async(print_progress_bar, args&#x3D;()) # 添加 print_progress_bar 进程\n    pool.apply_async(bfunc, args&#x3D;()) # 添加 bfunc 进程\n    long_function() # 执行主进程\n    p.close() # 进程池不再接受新进程\n    p.start() # 启动进程池\n    p.join() # 进程池等待结束<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>三个进程并行的运行效果（<code>print</code>语句还是有些冲突，不过运行正常）：<br><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/4/30/py-async-2.gif\" alt=\"效果-需求一\"></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>如果你把<code>pool</code>里添加上4+个进程的话，程序的并行可能失败。这取决于你的电脑有几个 CPU（就是几核），可以通过如下<code>os.cpu_count()</code>命令查询：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python 3.8.2 (v3.8.2:7b3ab5921f, Feb 24 2020, 17:52:18) \n[Clang 6.0 (clang-600.0.57)] on darwin\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; \n&gt;&gt;&gt; os.cpu_count()\n4\n&gt;&gt;&gt; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"需求三：两进程并行中，其中一个进程停止，另外一个进程也停止\"><a href=\"#需求三：两进程并行中，其中一个进程停止，另外一个进程也停止\" class=\"headerlink\" title=\"需求三：两进程并行中，其中一个进程停止，另外一个进程也停止\"></a>需求三：两进程并行中，其中一个进程停止，另外一个进程也停止</h1><p>一开始我使用<code>Pool</code>进行并行，并且尝试捕捉<code>SIGCHLD</code>信号，来解决标题中的问题，但是这样好像行不太同。实际上我们可以使用两个<code>Process</code>实现，代码如下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import time\nfrom multiprocessing import Process\n\nAT_PROGRESS_BAR &#x3D; [...] # 为了读者方便，省略数组内容\n\ndef print_progress_bar():\n    while True:\n        for i in AT_PROGRESS_BAR:\n            print(i, end&#x3D;&quot;&quot;)\n            time.sleep(0.1)\n            print(&#39;\\r&#39; * len(i), end&#x3D;&quot;&quot;)\n            \ndef long_function():\n    for i in range(20):\n        # 每隔一秒就 print 一下，以示函数正在执行。\n        time.sleep(1)\n        print(&quot;函数正在执行！&quot;)\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    p &#x3D; Process(target&#x3D;long_function, args&#x3D;())\n    p.start()\n    p2 &#x3D; Process(target&#x3D;print_progress_bar, args&#x3D;())\n    p2.start()\n    p.join()\n    p2.terminate()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在上面的代码中，我们希望<code>long_function()</code>执行结束后，停止<code>print_progress_bar()</code>进程。</p>\n<p>代码中：首先，我创建了<code>p</code>和<code>p2</code>两个<code>Process</code>，分别代表<code>long_function</code>和<code>print_progress_bar</code>，再分别<code>start()</code>进程；其次，我通过<code>p.join()</code>等待<code>p</code>进程结束，却不等待<code>p2</code>结束；最后，我巧妙地在<code>p</code>结束（即<code>long_function()</code>结束后）后，通过<code>terminate()</code>停止<code>p2</code>进程。</p>\n<p>这种方法的好处是，我们不用等待或传递任何信号，而只是通过<strong>代码的从上到下依次执行规律</strong>，解决标题中的问题。</p>\n<h1 id=\"END\"><a href=\"#END\" class=\"headerlink\" title=\"END\"></a>END</h1>","text":"场景我最近用Python的print，通过打印一帧帧的进度条，实现了一个进度条样式，顺便跟大家分享一下代码： import time AT_PROGRESS_BAR &#x3D; [ &quot;( )&quot;, &quot;(@ )&quot;, &quot;(@@ )&q...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"Python","slug":"Python","count":5,"path":"api/tags/Python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">场景</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%E4%B8%80%EF%BC%9A2%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">需求一：2进程并行执行</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%E4%BA%8C%EF%BC%9A2-%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">需求二：2+进程并行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9C%80%E6%B1%82%E4%B8%89%EF%BC%9A%E4%B8%A4%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E4%B8%AD%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%8C%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B9%9F%E5%81%9C%E6%AD%A2\"><span class=\"toc-text\">需求三：两进程并行中，其中一个进程停止，另外一个进程也停止</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#END\"><span class=\"toc-text\">END</span></a></li></ol>","author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PocketSphinx实现语音识别","uid":"55f018d1c31917539ae96f64efe0fa77","slug":"PocketSphinx实现语音识别","date":"2020-05-06T09:06:56.000Z","updated":"2021-12-12T02:56:09.905Z","comments":true,"path":"api/articles/PocketSphinx实现语音识别.json","keywords":null,"cover":[],"text":"前言我最近一直在搞一个名叫 A.N.N.A. 的 Python 语音机器人项目（Anna 是什么单词的缩写我就不说了，自己猜去），需要用的强大的语音识别技术。翻看全网教程，没有一篇说的通的，要么就是教会如何购买百度AI会员，要么就是教如何翻墙使用谷歌语音…… 我最近发现Pocke...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"Python","slug":"Python","count":5,"path":"api/tags/Python.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}},"next_post":{"title":"使用动态库注入优雅破解 CrossOver","uid":"f1e3b848a74381b642345951ae64d11f","slug":"使用动态库注入优雅破解 CrossOver","date":"2020-04-13T13:23:41.000Z","updated":"2021-10-07T00:48:59.288Z","comments":true,"path":"api/articles/使用动态库注入优雅破解 CrossOver.json","keywords":null,"cover":[],"text":"前言上次我写过一篇叫做Hopper 之 CrossOver 19 破解的文章，那么今天，我再写一篇 CrossOver 19 的破文。上一篇文章里，我用了“直接修改二进制文件”的方法来破解应用，而这次，我则通过动态库注入的方法来破解 CrossOver 19——这是一个巧妙、新奇...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"},{"name":"Hook","slug":"Hook","count":2,"path":"api/tags/Hook.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}}}