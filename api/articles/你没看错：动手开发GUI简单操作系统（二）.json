{"title":"你没看错：动手开发GUI简单操作系统（二）","uid":"3efcf09e47cda1211cfb680b33e8483e","slug":"你没看错：动手开发GUI简单操作系统（二）","date":"2021-02-10T10:36:42.000Z","updated":"2021-02-11T10:39:24.785Z","comments":true,"path":"api/articles/你没看错：动手开发GUI简单操作系统（二）.json","keywords":null,"cover":[],"content":"<h1 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h1><ol>\n<li>编写GDT</li>\n<li>切换到32位保护模式（32-bit protected mode，又叫PM）</li>\n</ol>\n<blockquote>\n<p>我突然发现写到第二篇文章就难以启齿了，因为切PM、加载内核这些东西几乎是环环相扣的，有一点差错都不行。</p>\n<p>另外劝大家一定要学好英文，怎么着也得七八千词汇量吧。</p>\n</blockquote>\n<h1 id=\"编写GDT\"><a href=\"#编写GDT\" class=\"headerlink\" title=\"编写GDT\"></a>编写GDT</h1><p>GDT是最难理解的部分，却不可避免，不好意思，我这次又整了一大段理论写在这里。我觉得下面说的还算比较全吧，如果我一下引入那么多名词，我都难以下笔。但是，必须看，如果实在读不进去，看<strong>加粗字体</strong>：</p>\n<h2 id=\"认识全局描述符表\"><a href=\"#认识全局描述符表\" class=\"headerlink\" title=\"认识全局描述符表\"></a>认识全局描述符表</h2><blockquote>\n<p>为了行文方便，下文使用缩写。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">中文名称</th>\n<th>英文名称</th>\n<th>缩写</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">全局描述符表</td>\n<td>Global Descriptor Table</td>\n<td>GDT</td>\n</tr>\n<tr>\n<td align=\"center\">保护模式</td>\n<td>Protected Mode</td>\n<td>PM</td>\n</tr>\n<tr>\n<td align=\"center\">真实模式</td>\n<td>Real Mode</td>\n<td>RM</td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>GDT在PM下，是一个重要的必不可少的数据结构。</p>\n<p>为什么要有GDT？我们首先考虑一下在RM（就是切PM之前）下的编程模型：在RM下，我们对一个内存地址的访问是通过<code>Segment:Offset</code>的方式来进行的，其中Segment是一个段的基地址，一个Segment的最大长度是64KB，这是16位系统所能表示的最大长度。而Offset则是相对于此段基地址的偏移量。<strong>基地址+偏移就是一个内存绝对地址。</strong></p>\n<p>由此，我们可以看出，一个段具备两个因素：基地址和段的最大长度。而对一个内存地址的访问，则是需要指出两点：</p>\n<ol>\n<li>使用的是哪个段；</li>\n<li>相对于这个段基地址的偏移：这个偏移应该小于此段的最大长度。</li>\n</ol>\n<p>当然对于16位系统，最大长度不用指定，默认为最大长度64KB，16位的便宜也永远不可能大于最大长度。而我们在实际编程的时候，使用16位段寄存器CS，DS，SS来指定段，CPU将段寄存器中的数值向左偏移4位，放到20位的地址线上就成为20位的基地址。</p>\n<p>到了PM，内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的。也就是说，PM的内存管理模式事实上是：纯段模式和段页式。进一步说，段模式是必不可少的，而页模式则是可选的——如果使用页模式，则是段页式；否则这是纯段模式。</p>\n<p>既然是这样，我们就先不去考虑页模式。对于段模式来讲，访问一个内存地址仍然使用Segment:Offset的方式，这是很自然的。由于PM运行在32位系统上，那么Segment的两个因素：基地址和最大长度也都是32位的。IA-32允许将一个段的基地址设为32位所能表示的任何值（最大长度则可以被设为32位所能表示的2<sup>12</sup>的整数倍的任何值），而不像RM下，一个段的基地址只能是16的倍数（因为其低4位是通过左移运算得来的，只能为0，从而达到使用16位段寄存器表示20位基地址的目的），而一个段的最大长度只能为固定值64KB。</p>\n<p><strong>另外PM顾名思义，就是为段访问提供了保护机制</strong>，也就说一个段的描述符需要规定对自身的访问权限（Access）。所以在PM下，对一个段的描述则包括3方面因素：Base Address（基地址）、Limit（最大长度）、Access（访问权限），它们加在一起被放在一个64位长的数据结构中，被称为段描述符。这种情况下，如果我们直接通过一个64位段描述符来引用一个段的时候，就必须使用一个64位长的段寄存器装入这个段描述符。Intel为了保持向后兼容，但将段寄存器仍然规定为16位（尽管每个段寄存器事实上有一个64位长的不可见部分，但对于编程人员来说段寄存器就是16位的），那么很明显，我们无法通过16位长度的段寄存器来直接引用64位的段描述符。怎么办？<strong>解决的方法就是把这些长度为64位的段描述符放入一个数组中，而将段寄存器中的值作为下标索引来间接引用（事实上，是将段寄存器中的高13位的内容作为索引）。</strong></p>\n<p><strong>——这个全局的数组就是GDT。</strong>事实上，在GDT中存放的不仅仅是段描述符，还有其它描述符，它们都是64-bit长，我们随后再讨论。GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，C<strong>PU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器<code>gdtr</code>用来存放GDT的入口地址</strong>。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDT是PM所必须的数据结构，也是唯一的——不应该，也不可能有多个GDT。</p>\n<p>另外，正像它的名字Global Descriptor Table所揭示的，它是全局可见的，对任何一个任务而言都是这样。除了GDT之外，IA-32还允许程序员构建与GDT类似的数据结构，它们被称作LDT，但与GDT不同的是，<strong>LDT在系统中可以存在多个，并且从LDT的名字可以得知，LDT不是全局可见的，它们只对引用它们的任务可见，每个任务最多可以拥有一个LDT。</strong></p>\n<p><strong>另外，每一个LDT自身作为一个段存在，它们的段描述符被放在GDT中。</strong>IA-32为LDT的入口地址也提供了一个寄存器LDTR，因为在任何时刻只能有一个任务在运行，所以<strong>LDT寄存器全局也只需要有一个</strong>。如果一个任务拥有自身的LDT，那么当它需要引用自身的LDT时，它需要通过LLDT将其LDT的段描述符装入此寄存器。</p>\n<p>LLDT指令与LGDT指令不同的是，LGDT指令的操作数是一个32位的内存地址，这个内存地址处存放的是一个32位GDT的入口地址，以及16位的GDT最大长度。而LLDT指令的操作数是一个16位的选择子，这个选择子主要内容是：<strong>被装入的LDT的段描述符在GDT中的索引值</strong>——这一点和刚才所讨论的通过段寄存器访问段的情况是一样的。</p>\n<p>现在你知道为什么要有GDT了吧……</p>\n<h2 id=\"GDT结构\"><a href=\"#GDT结构\" class=\"headerlink\" title=\"GDT结构\"></a>GDT结构</h2><p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-table.png\" alt=\"gdt结构\"></p>\n<p>这是GDT的结构。其中Flags和Access Byte部分又分为如下表格：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/gdt-struct-detail.png\" alt=\"gdt详细\"></p>\n<h2 id=\"编写GDT-1\"><a href=\"#编写GDT-1\" class=\"headerlink\" title=\"编写GDT\"></a>编写GDT</h2><p>我们先讲讲上面两个图每一项都代表什么，并且应该设置什么值。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">图中标签</th>\n<th>中文</th>\n<th>英文</th>\n<th>值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Pr</td>\n<td>展示</td>\n<td>present</td>\n<td>1</td>\n<td>段在内存中被展示</td>\n</tr>\n<tr>\n<td align=\"left\">Privl</td>\n<td>访问权限</td>\n<td>privilege</td>\n<td>0</td>\n<td>俗话说的ring级别。ring0 = 最高权限（内核）；ring3 = 最低权限（用户App）</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td>描述符类型</td>\n<td>descriptor type</td>\n<td>1</td>\n<td>设为1，表示是CS/DS</td>\n</tr>\n<tr>\n<td align=\"left\">Ex</td>\n<td>是否为可执行</td>\n<td>Executable</td>\n<td>1</td>\n<td>1表示可执行，说明是代码；0表示不可执行，说明是数据</td>\n</tr>\n<tr>\n<td align=\"left\">DC</td>\n<td>指示/遵循</td>\n<td>Direction/Conforming</td>\n<td>0</td>\n<td>代码段中，0：代码只能被Privl权限执行，1：代码可以被≤Privil权限执行。数据段中，0：段从下到上，1：段从上到下。</td>\n</tr>\n<tr>\n<td align=\"left\">RW</td>\n<td>读写性</td>\n<td>Readable/Writable</td>\n<td>1</td>\n<td>对于代码段：1是可读（可以获取常量），0是可执行，不可写；对于数据段：1是可写，2是可读，不可执行</td>\n</tr>\n<tr>\n<td align=\"left\">Ac</td>\n<td>已访问段</td>\n<td>Accessed</td>\n<td>0</td>\n<td>设为0。当CPU访问段，access会设成1，由CPU控制</td>\n</tr>\n<tr>\n<td align=\"left\">Gr</td>\n<td>粒度</td>\n<td>Granularity</td>\n<td>1</td>\n<td>如果是1，我们的limit会扩大四倍</td>\n</tr>\n<tr>\n<td align=\"left\">Sz</td>\n<td>大小</td>\n<td>Size</td>\n<td>1</td>\n<td>1代表使用32位PM，0是使用16位PM</td>\n</tr>\n<tr>\n<td align=\"left\">0（第一个）</td>\n<td>64位代码段</td>\n<td>64-bit CS</td>\n<td>0</td>\n<td>32位处理器我们不用，0</td>\n</tr>\n<tr>\n<td align=\"left\">0（第二个）</td>\n<td>系统可使用</td>\n<td>AVailabLe for use by system software （AVL）</td>\n<td>0</td>\n<td>调试用，0</td>\n</tr>\n</tbody></table>\n<p>我们根据需要的值写一个GDT。GDT有不止一种写法（也有许多比这高级的），我这种写法是定义了一个数据体，简单明了，但是可能不易于后期维护，项目里新建<code>gdt.asm</code>：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">gdt_start: ; 在这里写一个标签，待会用来计算大小\n\ngdt_null:  ; 这个叫做空段，是Intel预留的\n    dd 0   ; DD &#x3D; double word  （此处也可以把两个dd合并为一个dq）\n    dd 0   ;    &#x3D; 4 byte\n\ngdt_code: \n    dw 0xFFFF    ; Limit            0-15 bits\n    dw 0         ; Base address     0-15\n    db 0         ; 同上              16-23\n    db 10011010B ; 按照图二Access Byte从右至左（0-7）的顺序填写。注意Privl因为值可以是0-3，所以说占两字节，填两个0\n    db 11001111B ; 按图二flags从右至左填写。我们再看图一，flags右边还有limits最后4位，不满8位编译不通过，所以把limits合并在flags右面，0xF&#x3D;0b1111\n    db 0         ; Base             24-31\n\ngdt_data:        ; 同上\n    dw 0xFFFF\n    dw 0\n    db 0  \n    db 10010010B ; 不同的是这里把Ex改成0，因为这里是数据段\n    db 11001111B\n    db 0\n\ngdt_end:         ; gdt结束标签，\n\n; GDT\ngdt_descriptor:\n    dw gdt_end - gdt_start - 1 ; 大小&#x3D;结束-开始-1（真实大小永远-1）\n    dd gdt_start               ; 开始地址\n\n; 常量\nCODE_SEG equ gdt_code - gdt_start ; CS\nDATA_SEG equ gdt_data - gdt_start ; DS<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>GDT大功告成！<strong>如果你没有编译成功，出了问题，请留言跟帖或者私信，我一定会回复！</strong></p>\n<h1 id=\"在32位保护模式下打印\"><a href=\"#在32位保护模式下打印\" class=\"headerlink\" title=\"在32位保护模式下打印\"></a>在32位保护模式下打印</h1><p>我们现在写一个文件<code>32bit-print</code>，用来在32位保护模式下打印，不过只用来测试，到时候加载了内核切了GUI就可以删了。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">[bits 32]\n\nVIDEO_MEMORY equ 0xB8000 ; 这是VGA开始的地方\nWHITE_ON_BLACK equ 0x0F  ; 是一个颜色代码，黑背景，白色字符\n\nprint_string_pm:\n    pusha\n    mov edx, VIDEO_MEMORY\n\nprint_string_pm_loop:\n    mov al, [ebx]          ; [ebx]是字符串参数\n    mov ah, WHITE_ON_BLACK ; ah颜色参数\n\n    cmp al, 0 ; 是不是已经到末尾？\n    je print_string_pm_done ; 结束\n\n    ; 如果不是\n    mov [edx], ax ; 在Vram中保存字符\n    add ebx, 1 ; 下一个字符\n    add edx, 2 ; 下一个Vram字符位置，+2\n\n    jmp print_string_pm_loop ; 递归\n\nprint_string_pm_done:\n    popa\n    ret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"切换到32位保护模式\"><a href=\"#切换到32位保护模式\" class=\"headerlink\" title=\"切换到32位保护模式\"></a>切换到32位保护模式</h1><p>简单说一下为什么会有所谓保护模式：仔细想一想就能知道，如果这个OS给用户用就是开玩笑，就好像用户和操作系统一块在计算机里玩，而不是用户在操作系统里玩，它没有安全性可言，可以随便访问内存，更别提什么ring0、ring3的了，所以说切PM是为了让OS得到保护。</p>\n<p>新建代码<code>switch_pm.asm</code>，很简单。主要目标是认识并使用这个控制寄存器cr0：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">[bits 16] ; 代表在16位模式下。中括号可以去掉\nswitch_to_pm:\n    cli                   ; 1. 一定要关掉CPU中断！让CPU专心干一件事\n    lgdt [gdt_descriptor] ; 2. 还记得lgdt命令吗？加载我们的gdt_descriptor标签\n    mov eax, cr0          ; 把cr0暂存到eax\n    or eax, 0x1           ; 3. cr0设置为1，切到32位PM\n    mov cr0, eax\n    jmp CODE_SEG:init_pm  ; 4. 远跳转，跳到代码段（下面）\n\n[bits 32] ; 32位！\ninit_pm:\n    mov ax, DATA_SEG ; 5. 更新段寄存器\n    mov ds, ax\n    mov ss, ax\n    mov es, ax  ; 把每个都刷一遍\n    mov fs, ax\n    mov gs, ax\n\n    mov ebp, 0x90000 ; 6. 基址指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部，把它放到0x90000，待会加载内核\n    mov esp, ebp\n\n    call BEGIN_PM ; 跳到bootsect<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>cr0</code>全称叫做Control Register 0，这个控制寄存器专门用来在RM和PM之间切换。</p>\n<p>我们编辑一下<code>bootsect.asm</code>，使用上面的“函数”：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">[org 0x7C00]\n    mov bp, 0x9000\n    mov sp, bp\n\n    mov bx, MSG_REAL_MODE\n    call print ; 在实模式下打印\n\n    call switch_to_pm ; 切PM\n    ; 这里不管加什么代码都不会被执行\n\n%include &quot;print.asm&quot;\n%include &quot;gdt.asm&quot;\n%include &quot;32bit-print.asm&quot;\n%include &quot;switch_pm.asm&quot;\n\n[bits 32] ; 32位\nBEGIN_PM: ; 切换后跳转到这里\n    mov ebx, MSG_PROT_MODE ; 打印\n    call print_string_pm ; 注意！！！这个信息会被打印到整个屏幕的最左上角，覆盖BIOS的打印\n    jmp $ ; 挂起\n\nMSG_REAL_MODE db &quot;Started in 16-bit real mode&quot;, 0\nMSG_PROT_MODE db &quot;Loaded 32-bit protected mode&quot;, 0\n\ntimes 510-($-$$) db 0\ndw 0xAA55<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编译运行两步走：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/32pm-load-success.png\" alt=\"32pm-load-success\"></p>\n<h1 id=\"加载并执行空内核\"><a href=\"#加载并执行空内核\" class=\"headerlink\" title=\"加载并执行空内核\"></a>加载并执行空内核</h1><p>切32位PM是为加载内核准备的，我就一块整了吧，不然切PM毫无用处。</p>\n<p>首先我们得认识到，汇编作为底层语言的代价是功能太少，不方便我们编程。内核编程需要用到C。但是一个操作系统项目里，怎么能容得下两种语言编译呢？你别着急，我们的做法是将启动扇区和内核部分分开，启动扇区编译成一个bin，内核编译成一个bin，编译的过程中我们把ld命令做一些调整，使数据便宜到0x1000，之后把两个bin用cat合并。</p>\n<h2 id=\"内核编写\"><a href=\"#内核编写\" class=\"headerlink\" title=\"内核编写\"></a>内核编写</h2><p>所以说咱们先开始写内核吧，新建<code>kernel.c</code>：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void main() &#123;\n    char *video_memory &#x3D; (char*) 0xb8000;\n    *video_memory &#x3D; &#39;V&#39;;\n    char *video_memory1 &#x3D; (char*) 0xb8002;\n    *video_memory1 &#x3D; &#39;e&#39;;\n    char *video_memory2 &#x3D; (char*) 0xb8004;\n    *video_memory2 &#x3D; &#39;n&#39;;\n    char *video_memory3 &#x3D; (char*) 0xb8006;\n    *video_memory3 &#x3D; &#39;u&#39;;\n    char *video_memory4 &#x3D; (char*) 0xb8008;\n    *video_memory4 &#x3D; &#39;s&#39;;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>它的作用就是到VGA的地址打印<code>Venus</code>。</p>\n<h2 id=\"汇编编写\"><a href=\"#汇编编写\" class=\"headerlink\" title=\"汇编编写\"></a>汇编编写</h2><p>同级新建<code>kernel_entry.asm</code>，仅有四行代码：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">[bits 32]\n[extern main] ; 像C一样，对外部函数得先声明。这个main就是kernel.c里面那个\ncall main     ; 执行\njmp $<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>是时候到<code>bootsect.asm</code>加载了：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">[org 0x7c00]\nKERNEL_OFFSET equ 0x1000 ; 定义常量，这个常量是内核的位置\n\n    mov [BOOT_DRIVE], dl ; BIOS会自动把磁盘编号设置到dl。我们在下面间一个常量，先存起来，因为dl可能会被覆盖\n    mov bp, 0x9000\n    mov sp, bp\n\n    mov bx, MSG_REAL_MODE ; 实模式打印\n    call print\n    call print_nl\n\n    call load_kernel  ; 加载内核\n    call switch_to_pm ; 切PM\n\n%include &quot;print.asm&quot;\n%include &quot;print_hex.asm&quot;\n%include &quot;disk.asm&quot;\n%include &quot;gdt.asm&quot;\n%include &quot;print.asm&quot;\n%include &quot;switch_pm.asm&quot;\n\n[bits 16]\nload_kernel:\n    mov bx, MSG_LOAD_KERNEL\n    call print\n    call print_nl\n\n    mov bx, KERNEL_OFFSET ; 读取到内核偏移地址\n    mov dh, 2\n    mov dl, [BOOT_DRIVE]\n    call disk_load\n    ret\n\n[bits 32]\nBEGIN_PM:\n    mov ebx, MSG_PROT_MODE\n    call print_string_pm\n    call KERNEL_OFFSET ; 执行内核代码\n    jmp $\n\n\nBOOT_DRIVE db 0\nMSG_REAL_MODE db &quot;Started in 16-bit Real Mode&quot;, 0\nMSG_PROT_MODE db &quot;Landed in 32-bit Protected Mode&quot;, 0\nMSG_LOAD_KERNEL db &quot;Loading kernel into memory&quot;, 0\n\ntimes 510 - ($-$$) db 0\ndw 0xAA55<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/11/kern-exec.png\" alt=\"kern-exec\"></p>\n<p>今天就到这里，<strong>以后更新可能会慢点</strong>，太累了，我还要干别的呢。我发现不少坛友貌似有点功利性质，说什么期待后续如果可以再下手，哈哈，我理解你们，毕竟项目要么就不做，要么就做成。我的个人理念是不做就不做，做就做大。</p>\n","text":"学习目标 编写GDT 切换到32位保护模式（32-bit protected mode，又叫PM） 我突然发现写到第二篇文章就难以启齿了，因为切PM、加载内核这些东西几乎是环环相扣的，有一点差错都不行。 另外劝大家一定要学好英文，怎么着也得七八千词汇量吧。 编写GDTGDT是最难...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"《你没听错：动手开发GUI简单操作系统》系列","slug":"《你没听错：动手开发GUI简单操作系统》系列","count":2,"path":"api/tags/《你没听错：动手开发GUI简单操作系统》系列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">学习目标</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99GDT\"><span class=\"toc-text\">编写GDT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A4%E8%AF%86%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8\"><span class=\"toc-text\">认识全局描述符表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GDT%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">GDT结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99GDT-1\"><span class=\"toc-text\">编写GDT</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9C%A832%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%93%E5%8D%B0\"><span class=\"toc-text\">在32位保护模式下打印</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%87%E6%8D%A2%E5%88%B032%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">切换到32位保护模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%A9%BA%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">加载并执行空内核</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E7%BC%96%E5%86%99\"><span class=\"toc-text\">内核编写</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99\"><span class=\"toc-text\">汇编编写</span></a></li></ol></li></ol>","author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"手把手教你玩转CrackMe破解五步走","uid":"f8f00c53f910c5373cf9a118fe864ac9","slug":"手把手教你玩转CrackMe破解五步走","date":"2021-02-17T06:44:56.000Z","updated":"2022-03-21T05:21:24.372Z","comments":true,"path":"api/articles/手把手教你玩转CrackMe破解五步走.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-view.png","text":" www.52pojie.cn 作者：@TLHorse 原创作品，吾爱破解首发 前言本文所破解的CrackMe出自国外MSJ论坛的竞赛题目，原题估计找不着了，所以我共享在如下链载： 链接：https://share.weiyun.com/hGwzo5p4 密码：5828dk 这个...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"},{"name":"注册机","slug":"注册机","count":1,"path":"api/tags/注册机.json"},{"name":"Swift","slug":"Swift","count":1,"path":"api/tags/Swift.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}},"next_post":{"title":"你没看错：动手开发GUI简单操作系统（一）","uid":"3a5c91716103437f37cc384f7b5075da","slug":"你没看错：动手开发GUI简单操作系统（一）","date":"2021-02-09T14:26:38.000Z","updated":"2021-02-11T10:43:36.184Z","comments":true,"path":"api/articles/你没看错：动手开发GUI简单操作系统（一）.json","keywords":null,"cover":[],"text":"前言今天我终于想好发布这篇文章，以前自己一直在摸索开发，保证100%原创。这个操作系统异常简单，没有Windows的高级，没有OS X的华丽，更没有Linux的强大——也别指望了，对于个人来说根本没多少生产力，只能用来学习知识，自己整着玩。但是，OS开发的资料太少了，“你没看错”...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"《你没听错：动手开发GUI简单操作系统》系列","slug":"《你没听错：动手开发GUI简单操作系统》系列","count":2,"path":"api/tags/《你没听错：动手开发GUI简单操作系统》系列.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}}}