{"title":"手把手教你玩转CrackMe破解五步走","uid":"f8f00c53f910c5373cf9a118fe864ac9","slug":"手把手教你玩转CrackMe破解五步走","date":"2021-02-17T06:44:56.000Z","updated":"2022-03-21T05:21:24.372Z","comments":true,"path":"api/articles/手把手教你玩转CrackMe破解五步走.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-view.png","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"http://www.52pojie.cn/\">www.52pojie.cn</a></p>\n<p>作者：@TLHorse</p>\n<p>原创作品，吾爱破解首发</p></blockquote>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本文所破解的CrackMe出自国外MSJ论坛的竞赛题目，原题估计找不着了，所以我共享在如下链载：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>链接：<a href=\"https://share.weiyun.com/hGwzo5p4\">https://share.weiyun.com/hGwzo5p4</a></p>\n<p>密码：5828dk</p></blockquote>\n<p>这个app我已经打开并逆向过，确认没有病毒，如果你还不放心可以拉到虚拟机里。<strong>为了避免违规，我逆向去除了app里的MSJ链接（点击<code>Help me!</code>不会跳转）。</strong>我看也没有多少人破解，macOS CM也挺少的，就拿来分析一下。</p>\n<p>题目中的五部走包括：</p>\n<ul>\n<li>分析</li>\n<li>暴力破解</li>\n<li>Hook</li>\n<li>代码还原</li>\n<li>写注册机</li>\n</ul>\n<p><strong>macOS下的逆向很少被人提及，似乎很冷门，我今天分析这个CrackMe，涵盖这四部分，希望对用macOS的朋友有帮助。</strong></p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-view.png\" alt=\"pie-view\"></p>\n<p>打开看一下主页面，这个CM和别的不太相同的是，它没有“确认”“验证”之类的按钮。随便输入几组值都都没有反应。 <strong>我们猜测这个CM会在表单变动时重复刷新验证</strong>，在符号表里搜索到的<code>serialFieldDidChange</code>验证了我们的想法：</p>\n<pre class=\"line-numbers language-objective-c\" data-language=\"objective-c\"><code class=\"language-objective-c\">&#x2F;* @class PieAppDelegate *&#x2F;\n-(void)serialFieldDidChange &#123;\n    &#x2F;&#x2F; init UserDefaults，Apple开发的都知道这是数据持久化\n    r15 &#x3D; (@selector(standardUserDefaults))(@class(NSUserDefaults), &amp;@selector(standardUserDefaults));\n    &#x2F;&#x2F; 设置UserDefaults\n    (@selector(setObject:forKey:))(r15, &amp;@selector(setObject:forKey:), (@selector(stringValue))(self-&gt;nameField, &amp;@selector(stringValue)), @&quot;name&quot;);\n    (@selector(setObject:forKey:))(r15, &amp;@selector(setObject:forKey:), (@selector(stringValue))(self-&gt;serialField, &amp;@selector(stringValue)), @&quot;serial&quot;);\n    &#x2F;&#x2F; 验证\n    (@selector(verifySerial:andName:))(self, &amp;@selector(verifySerial:andName:), (@selector(stringValue))(self-&gt;serialField, &amp;@selector(stringValue)), (@selector(stringValue))(self-&gt;nameField, &amp;@selector(stringValue)));\n    return;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们可以轻松发现，<code>verifySerial:andName:</code>就是验证用户名密码的关键函数。这个CM有反调试，我就拿<code>frida-trace</code>进行跟踪，<strong>发现每输入一个字符，就会将此函数调用一次</strong>，更印证了我们的猜测。</p>\n<h1 id=\"暴力破解\"><a href=\"#暴力破解\" class=\"headerlink\" title=\"暴力破解\"></a>暴力破解</h1><p>话不多说，先考虑暴破。不过在动手改二进制前，我们得先瞄准一个点，到底改哪呢？我就试试<code>verifySerial:andName:</code>吧，汇编代码如下（我把失败的标签从<code>loc_xxx</code>改为<code>failure</code>）：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">                     -[PieAppDelegate verifySerial:andName:]:\n0000000100001342         push       rbp\n0000000100001343         mov        rbp, rsp\n0000000100001346         mov        qword [rbp+var_28], rbx\n000000010000134a         mov        qword [rbp+var_20], r12\n000000010000134e         mov        qword [rbp+var_18], r13\n0000000100001352         mov        qword [rbp+var_10], r14\n0000000100001356         mov        qword [rbp+var_8], r15\n000000010000135a         sub        rsp, 0xd0\n0000000100001361         mov        qword [rbp+var_60], rdi\n0000000100001365         mov        r13, rdx\n0000000100001368         mov        r14, rcx\n000000010000136b         mov        rdi, qword [qword_100002768]\n0000000100001372         mov        edx, 0x4\n0000000100001377         lea        rsi, qword [0x1000022b8]\n000000010000137e         call       qword [0x1000022b8]\n0000000100001384         mov        r15, rax\n0000000100001387         lea        rsi, qword [0x1000022c8]\n000000010000138e         mov        rdi, r13\n0000000100001391         call       qword [0x1000022c8]\n0000000100001397         cmp        rax, 0x10\n000000010000139b         jne        failure\n\n00000001000013a1         mov        edx, 0x6\n00000001000013a6         lea        rsi, qword [0x1000022d8]\n00000001000013ad         mov        rdi, r13\n00000001000013b0         call       qword [0x1000022d8]\n00000001000013b6         mov        rdi, rax\n00000001000013b9         mov        edx, 0x4\n00000001000013be         lea        rsi, qword [0x1000022b8]\n00000001000013c5         call       qword [0x1000022b8]\n00000001000013cb         mov        rbx, rax\n00000001000013ce         lea        rsi, qword [0x1000022c8]\n00000001000013d5         mov        rdi, rax\n00000001000013d8         call       qword [0x1000022c8]\n00000001000013de         mov        r12, rax\n00000001000013e1         lea        rsi, qword [0x1000022e8]\n00000001000013e8         mov        rdi, rbx\n00000001000013eb         call       qword [0x1000022e8]\n00000001000013f1         mov        rdi, rax\n00000001000013f4         xor        edx, edx\n00000001000013f6         mov        rsi, r12\n00000001000013f9         call       imp___symbol_stub1__MD5\n00000001000013fe         mov        rdx, qword [objc_cls_ref_NSString]\n0000000100001405         mov        qword [rbp+var_58], rdx\n0000000100001409         movzx      r9d, byte [rax+2]\n000000010000140e         movzx      r8d, byte [rax+1]\n0000000100001413         movzx      ecx, byte [rax]\n0000000100001416         movzx      edx, byte [rax+0xf]\n000000010000141a         mov        dword [rsp+0xd0+var_70], edx\n000000010000141e         movzx      edx, byte [rax+0xe]\n0000000100001422         mov        dword [rsp+0xd0+var_78], edx\n0000000100001426         movzx      edx, byte [rax+0xd]\n000000010000142a         mov        dword [rsp+0xd0+var_80], edx\n000000010000142e         movzx      edx, byte [rax+0xc]\n0000000100001432         mov        dword [rsp+0xd0+var_88], edx\n0000000100001436         movzx      edx, byte [rax+0xb]\n000000010000143a         mov        dword [rsp+0xd0+var_90], edx\n000000010000143e         movzx      edx, byte [rax+0xa]\n0000000100001442         mov        dword [rsp+0xd0+var_98], edx\n0000000100001446         movzx      edx, byte [rax+9]\n000000010000144a         mov        dword [rsp+0xd0+var_A0], edx\n000000010000144e         movzx      edx, byte [rax+8]\n0000000100001452         mov        dword [rsp+0xd0+var_A8], edx\n0000000100001456         movzx      edx, byte [rax+7]\n000000010000145a         mov        dword [rsp+0xd0+var_B0], edx\n000000010000145e         movzx      edx, byte [rax+6]\n0000000100001462         mov        dword [rsp+0xd0+var_B8], edx\n0000000100001466         movzx      edx, byte [rax+5]\n000000010000146a         mov        dword [rsp+0xd0+var_C0], edx\n000000010000146e         movzx      edx, byte [rax+4]\n0000000100001472         mov        dword [rsp+0xd0+var_C8], edx\n0000000100001476         movzx      eax, byte [rax+3]\n000000010000147a         mov        dword [rsp+0xd0+var_D0], eax\n000000010000147d         lea        rdx, qword [cfstring__02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X_02X]\n0000000100001484         lea        rsi, qword [0x1000022f8]\n000000010000148b         mov        rdi, qword [rbp+var_58]\n000000010000148f         xor        eax, eax\n0000000100001491         call       qword [0x1000022f8]\n0000000100001497         mov        rdi, rax\n000000010000149a         mov        rdx, qword [qword_100002770]\n00000001000014a1         lea        rsi, qword [0x100002308]\n00000001000014a8         call       qword [0x100002308]\n00000001000014ae         test       al, al\n00000001000014b0         je         failure\n\n00000001000014b6         mov        edx, 0xd\n00000001000014bb         lea        rsi, qword [0x100002318]\n00000001000014c2         mov        rdi, r13\n00000001000014c5         call       qword [0x100002318]\n00000001000014cb         cmp        ax, 0x46\n00000001000014cf         jne        failure\n\n00000001000014d5         mov        edx, 0x4\n00000001000014da         lea        rsi, qword [0x1000022b8]\n00000001000014e1         mov        rdi, r14\n00000001000014e4         call       qword [0x1000022b8]\n00000001000014ea         mov        rbx, rax\n00000001000014ed         lea        rsi, qword [0x1000022c8]\n00000001000014f4         mov        rdi, rax\n00000001000014f7         call       qword [0x1000022c8]\n00000001000014fd         mov        r12, rax\n0000000100001500         lea        rsi, qword [0x1000022e8]\n0000000100001507         mov        rdi, rbx\n000000010000150a         call       qword [0x1000022e8]\n0000000100001510         mov        rdi, rax\n0000000100001513         xor        edx, edx\n0000000100001515         mov        rsi, r12\n0000000100001518         call       imp___symbol_stub1__MD5\n000000010000151d         movzx      r9d, byte [rax+2]\n0000000100001522         movzx      r8d, byte [rax+1]\n0000000100001527         movzx      ecx, byte [rax]\n000000010000152a         movzx      edx, byte [rax+7]\n000000010000152e         mov        dword [rsp+0xd0+var_B0], edx\n0000000100001532         movzx      edx, byte [rax+6]\n0000000100001536         mov        dword [rsp+0xd0+var_B8], edx\n000000010000153a         movzx      edx, byte [rax+5]\n000000010000153e         mov        dword [rsp+0xd0+var_C0], edx\n0000000100001542         movzx      edx, byte [rax+4]\n0000000100001546         mov        dword [rsp+0xd0+var_C8], edx\n000000010000154a         movzx      eax, byte [rax+3]\n000000010000154e         mov        dword [rsp+0xd0+var_D0], eax\n0000000100001551         lea        rdx, qword [cfstring__02X_02X_02X_02X_02X_02X_02X]\n0000000100001558         lea        rsi, qword [0x1000022f8]\n000000010000155f         mov        rdi, qword [rbp+var_58]\n0000000100001563         xor        eax, eax\n0000000100001565         call       qword [0x1000022f8]\n000000010000156b         mov        rdi, rax\n000000010000156e         mov        edx, 0x7\n0000000100001573         lea        rsi, qword [0x1000022d8]\n000000010000157a         call       qword [0x1000022d8]\n0000000100001580         mov        rbx, rax\n0000000100001583         mov        qword [rbp+var_38], 0x7\n000000010000158b         mov        qword [rbp+var_40], 0x6\n0000000100001593         mov        edx, 0x6\n0000000100001598         mov        ecx, 0x7\n000000010000159d         lea        rsi, qword [0x100002328]\n00000001000015a4         mov        rdi, r13\n00000001000015a7         call       qword [0x100002328]\n00000001000015ad         mov        rdi, rax\n00000001000015b0         mov        rdx, rbx\n00000001000015b3         lea        rsi, qword [0x100002308]\n00000001000015ba         call       qword [0x100002308]\n00000001000015c0         test       al, al\n00000001000015c2         je         failure\n\n00000001000015c8         mov        qword [rbp+var_48], 0x2\n00000001000015d0         mov        qword [rbp+var_50], 0xe\n00000001000015d8         mov        edx, 0xe\n00000001000015dd         mov        ecx, 0x2\n00000001000015e2         lea        rsi, qword [0x100002328]\n00000001000015e9         mov        rdi, r13\n00000001000015ec         call       qword [0x100002328]\n00000001000015f2         mov        rdi, rax\n00000001000015f5         mov        edx, 0x4\n00000001000015fa         lea        rsi, qword [0x1000022b8]\n0000000100001601         call       qword [0x1000022b8]\n0000000100001607         mov        rdi, rax\n000000010000160a         mov        rdx, r15\n000000010000160d         lea        rsi, qword [0x100002338]\n0000000100001614         call       qword [0x100002338]\n000000010000161a         test       al, al\n000000010000161c         je         failure\n                        ; 下面的一段是成功注册的代码\n000000010000161e         mov        rdi, qword [objc_cls_ref_NSNotificationCenter]\n0000000100001625         lea        rsi, qword [0x100002238]\n000000010000162c         call       qword [0x100002238]\n0000000100001632         mov        rdi, rax\n0000000100001635         mov        rcx, qword [rbp+var_60]\n0000000100001639         lea        rdx, qword [cfstring_Registered]\n0000000100001640         lea        rsi, qword [0x100002348]\n0000000100001647         mov        r11, qword [0x100002348]\n000000010000164e         mov        rbx, qword [rbp+var_28]\n0000000100001652         mov        r12, qword [rbp+var_20]\n0000000100001656         mov        r13, qword [rbp+var_18]\n000000010000165a         mov        r14, qword [rbp+var_10]\n000000010000165e         mov        r15, qword [rbp+var_8]\n0000000100001662         leave\n0000000100001663         jmp        r11\n                        ; endp\n\n                     failure:\n0000000100001666         mov        rbx, qword [rbp+var_28]\n000000010000166a         mov        r12, qword [rbp+var_20]\n000000010000166e         mov        r13, qword [rbp+var_18]\n0000000100001672         mov        r14, qword [rbp+var_10]\n0000000100001676         mov        r15, qword [rbp+var_8]\n000000010000167a         leave\n000000010000167b         ret\n                        ; endp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们发现这个函数有一个特点，从头开始往下，一直是<code>cmp a, b</code>然后<code>jne/je failure</code>，也就是说<strong>如果我们暴破，要把这些<code>jne</code>和<code>je</code>都<code>nop</code>掉。</strong>太麻烦了，但是，自己想想，就真的没有好方法吗？答案是：有的。</p>\n<p>在这里我耍了一个小聪明：既然那么多失败的路径都指向<code>failure</code>，我何不把<code>failure</code>本身改一下呢？<code>Option+A</code>改为如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">                     failure:\n0000000100001666         jmp        0x10000161e\n0000000100001668         nop\n000000010000166f         nop\n0000000100001670         nop\n0000000100001679         nop\n000000010000167b         nop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我贴个图让你看得更明白：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/18/pie-bp-guide.png\" alt=\"pie-bp-guide\"></p>\n<p>也就是说，“验证失败”的代码被我们暴破跳转到“验证成功”的代码。<strong>如果哪行指令跳转到“验证失败”的代码，我们就再让它跳转到成功代码。</strong>很巧妙吧！</p>\n<p><code>Cmd+Shift+E</code>输出二进制，替换即可。</p>\n<h1 id=\"Hook\"><a href=\"#Hook\" class=\"headerlink\" title=\"Hook\"></a>Hook</h1><h2 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>我们先来试试Hook一下这个函数，我先把<code>verifySerial:andName:</code>贴出来。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">&#x2F;* @class PieAppDelegate *&#x2F;\n-(void)verifySerial:(void *)arg2 andName:(void *)arg3 &#123;\n    var_28 &#x3D; rbx;\n    var_20 &#x3D; r12;\n    var_18 &#x3D; r13;\n    var_10 &#x3D; r14;\n    var_8 &#x3D; r15;\n    var_60 &#x3D; self;\n    r13 &#x3D; arg2;\n    r14 &#x3D; arg3;\n    r15 &#x3D; (@selector(dataUsingEncoding:))(*qword_100002768, &amp;@selector(dataUsingEncoding:), 0x4, arg3);\n    if ((@selector(length))(r13, &amp;@selector(length)) &#x3D;&#x3D; 0x10) &#123;\n            rax &#x3D; (@selector(substringToIndex:))(r13, &amp;@selector(substringToIndex:), 0x6);\n            rax &#x3D; (@selector(dataUsingEncoding:))(rax, &amp;@selector(dataUsingEncoding:), 0x4);\n            r12 &#x3D; (@selector(length))(rax, &amp;@selector(length));\n            rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes));\n            rax &#x3D; MD5(rax, r12, 0x0);\n            if (((@selector(isEqualToString:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff, *(int8_t *)(rax + 0x8) &amp; 0xff, *(int8_t *)(rax + 0x9) &amp; 0xff, *(int8_t *)(rax + 0xa) &amp; 0xff, *(int8_t *)(rax + 0xb) &amp; 0xff, *(int8_t *)(rax + 0xc) &amp; 0xff), &amp;@selector(isEqualToString:), *qword_100002770) &#x3D;&#x3D; 0x0) &amp;&amp; ((@selector(characterAtIndex:))(r13, &amp;@selector(characterAtIndex:), 0xd) !&#x3D; 0x46)) &#123;\n                    rax &#x3D; (@selector(dataUsingEncoding:))(r14, &amp;@selector(dataUsingEncoding:), 0x4);\n                    r12 &#x3D; (@selector(length))(rax, &amp;@selector(length));\n                    rax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes));\n                    rax &#x3D; MD5(rax, r12, 0x0);\n                    if ((@selector(isEqualToString:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0x6, 0x7), &amp;@selector(isEqualToString:), (@selector(substringToIndex:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff), &amp;@selector(substringToIndex:), 0x7)) &#x3D;&#x3D; 0x0) &#123;\n                            if ((@selector(isEqualToData:))((@selector(dataUsingEncoding:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0xe, 0x2), &amp;@selector(dataUsingEncoding:), 0x4), &amp;@selector(isEqualToData:), r15) &#x3D;&#x3D; 0x0) &#123;\n                                    (@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);\n                            &#125;\n                    &#125;\n            &#125;\n    &#125;\n    return;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>函数体很长，关键在于它并没有返回一个特定的值，比如布尔或者字符。这个函数把验证和注册两个过程绑在一起。一个一个把跳转改成nop，太费时间。那还有什么办法呢？我看着这一层层if嵌套，突然萌生了一个想法：不用一层层改条件，只需要一个Hook，直接执行最里面的代码。</p>\n<p>在这里我使用MonkeyDev框架，新建工程，将<code>Pie.app</code>拖入：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-proj-guide.png\" alt=\"详细步骤\"></p>\n<h2 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h2><p>按照Cydia Substrate的文档，我们需要在动态库加载入口作函数替换，需要用<code>MSHookMessageEx</code>。这里是官方文档的用法（我翻译的）：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">void MSHookMessageEx(Class _class, SEL message, IMP hook, IMP *old);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_class</code></td>\n<td>OC类，消息将在该类上被hook。这个类可以是一个元类，这样就可以hook住非实例或类消息。</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>被hook的OC选择器（sel）。这可以用 <code>@selector</code> ，或在运行时用 <code>sel_registerName</code>生成。</td>\n</tr>\n<tr>\n<td><code>hook</code></td>\n<td><code>message</code>的替代函数，IMP指针类型。(注意传入的时候一定是指针)</td>\n</tr>\n<tr>\n<td><code>old</code></td>\n<td>一个空的函数指针。这个空的函数指针在hook时会被原函数填充，这样你在写新函数的时候，就可以调用原函数体了。如果你不需要调用原函数，此处可以留成NULL。</td>\n</tr>\n</tbody></table>\n<p>现在，我们编辑<code>PieTweak.m</code>，编辑<code>constructor</code>：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">static void __attribute__((constructor)) initialize(void) &#123;\n    MSHookMessageEx(objc_getClass(&quot;PieAppDelegate&quot;), @selector(verifySerial:andName:), (IMP)&amp;new_PieAppDelegate_verifySerial, NULL);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其中<code>new_PieAppDelegate_verifySerial</code>是我们要实现的。我们可以写一个<code>origin_PieAppDelegate_verifySerial</code>。由于我们不需要在hook里调用原函数，所以留空填<code>NULL</code>。</p>\n<p>接下来就该写我们的替代函数体了，<code>new_PieAppDelegate_verifySerial</code>。<strong>我们首先得考虑一下参数列表</strong>，除了Hopper解析出的<code>serial</code>和<code>name</code>，<strong>还有两个固定参数：<code>self</code>和<code>_cmd</code>。</strong></p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">@class PieAppDelegate; &#x2F;&#x2F; 为了在参数中写self，在这里我们声明类\n\nstatic void new_PieAppDelegate_verifySerial(\n    PieAppDelegate* self, &#x2F;&#x2F; 两个固定参数\n    SEL _cmd, \n    void *serial, &#x2F;&#x2F; 此处复制粘贴Hopper\n    void *name\n) &#123;\n    &#x2F;&#x2F; ...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>那么函数体呢？</strong>这得根据Hopper的伪代码进行还原。伪代码最内层有这么一句：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">(@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>我们可以推测出：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>把还原的语句放到<code>new_PieAppDelegate_verifySerial</code>里。</p>\n<p>现在大家可能被我绕的有点晕，所有的代码纵观如下：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">#import &quot;PieTweak.h&quot;\n#import &quot;substrate.h&quot;\n\n@class PieAppDelegate;\n\nstatic void new_PieAppDelegate_verifySerial(PieAppDelegate* self, SEL _cmd, void *serial, void *name) &#123;\n    [NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self]; &#x2F;&#x2F; 我们从伪代码还原的语句\n&#125;\n\nstatic void __attribute__((constructor)) initialize(void) &#123;\n    MSHookMessageEx(objc_getClass(&quot;PieAppDelegate&quot;), @selector(verifySerial:andName:), (IMP)&amp;new_PieAppDelegate_verifySerial, NULL);\n    &#x2F;&#x2F; 调用substrate进行hook\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>Cmd+B</code>编译，MonkeyDev会自动给我们注入：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-hook-success.png\" alt=\"pie-hook-success\"></p>\n<p><strong>不错吧！一打开就注册好了。</strong>我们只需要把<code>Pie.app</code>从<code>TargetApp</code>里面拖出去，就是我们的成品啦！</p>\n<h1 id=\"注册机编写\"><a href=\"#注册机编写\" class=\"headerlink\" title=\"注册机编写\"></a>注册机编写</h1><p>如果不用hook暴破，那就是写注册机了。注册机使我们破解得更优雅，但是代码的分析更麻烦。这个CM不是有反调试吗，所以说只有靠我们看伪代码了。</p>\n<p>这里希望提醒大家几点：</p>\n<ul>\n<li>看伪代码首先要<strong>利用Hopper功能</strong>，把arg2、arg3这样的无意义参数名更名，比如<code>serial</code>和<code>name</code>；</li>\n<li>一定要善于进行<strong>代码还原</strong>。Hopper会把不知道的方法都翻译成<code>@selector</code>，语法非常的别扭。具体的还原方法hook中有所涉及，但是我会在文末单独成节；</li>\n<li>在自己重写代码时，<strong>使用自己的变量</strong>，而不是<code>r12</code>、<code>r13</code>这样的无意义变量；</li>\n<li>有时候Hopper会把代码逻辑解析得很麻烦，比如在这个例子中，它把MD5的<em>加密数据</em>和<em>转换成字符串的MD5</em>分别放在变量和if条件里，就会让你感觉摸不着头，所以说<strong>一定要有自主判断能力。</strong></li>\n</ul>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><p>我们首先把验证函数的流程捣腾清楚：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">var_28 &#x3D; rbx; &#x2F;&#x2F; 定义一堆没用的，不过一定要清楚\nvar_20 &#x3D; r12;\nvar_18 &#x3D; r13;\nvar_10 &#x3D; r14;\nvar_8 &#x3D; r15;\nvar_60 &#x3D; self;\nr13 &#x3D; arg2; &#x2F;&#x2F; serial序列号变量\nr14 &#x3D; arg3; &#x2F;&#x2F; name名称变量\nr15 &#x3D; (@selector(dataUsingEncoding:))(*qword_100002768, &amp;@selector(dataUsingEncoding:), 0x4, arg3); &#x2F;&#x2F; 把名称进行编码，4其实是NSStringEncoding的NSUTF8StringEncoding，是个常量<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一开头，定义了一堆没用的，不过要清楚r13和r14是<code>serial</code>和name。r15处把<code>name</code>编码，查开发者文档可知0x4其实是<code>NSStringEncoding</code>的NSUTF8StringEncoding，是个常量。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">if ((@selector(length))(r13, &amp;@selector(length)) &#x3D;&#x3D; 0x10) &#123;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>判断serial的长度，如果是16位（0x10），通过。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">rax &#x3D; (@selector(substringToIndex:))(r13, &amp;@selector(substringToIndex:), 0x6); &#x2F;&#x2F; 取序列号前6位\nrax &#x3D; (@selector(dataUsingEncoding:))(rax, &amp;@selector(dataUsingEncoding:), 0x4);\nr12 &#x3D; (@selector(length))(rax, &amp;@selector(length)); &#x2F;&#x2F; 计算长度\nrax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes)); &#x2F;&#x2F; 计算字节\nrax &#x3D; MD5(rax, r12, 0x0); &#x2F;&#x2F; 计算序列号前6位的MD5值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这5行代码先取序列号前6位，然后计算出了相关长度、字节，最后计算出序列号前6位的MD5。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">if (((@selector(isEqualToString:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff, *(int8_t *)(rax + 0x8) &amp; 0xff, *(int8_t *)(rax + 0x9) &amp; 0xff, *(int8_t *)(rax + 0xa) &amp; 0xff, *(int8_t *)(rax + 0xb) &amp; 0xff, *(int8_t *)(rax + 0xc) &amp; 0xff), &amp;@selector(isEqualToString:), *qword_100002770) &#x3D;&#x3D; 0x0) &amp;&amp; ((@selector(characterAtIndex:))(r13, &amp;@selector(characterAtIndex:), 0xd) !&#x3D; 0x46)) &#123; &#x2F;&#x2F; 这个if的条件要满足两部分：1. 序列号的前6位的MD5是66EAD6FE7CBE7987B7C4B1A1EED0E5A5；2. 序列号的第13位是ASCII 0x46，也就是字符F<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个条件很长，但是细心的你会发现中间有个逻辑运算<code>&amp;&amp;</code>，条件分为两部分：</p>\n<ol>\n<li>序列号的前6位的MD5是<code>66EAD6FE7CBE7987B7C4B1A1EED0E5A5</code>，通过某网站的反查得知是“KRACK-”，这是个序列号前缀；</li>\n<li>序列号的第13位是ASCII 0x46，也就是字符F。</li>\n</ol>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">rax &#x3D; (@selector(dataUsingEncoding:))(r14, &amp;@selector(dataUsingEncoding:), 0x4); &#x2F;&#x2F; 编码name\nr12 &#x3D; (@selector(length))(rax, &amp;@selector(length)); &#x2F;&#x2F; 计算name长度\nrax &#x3D; (@selector(bytes))(rax, &amp;@selector(bytes)); &#x2F;&#x2F; 计算name字节\nrax &#x3D; MD5(rax, r12, 0x0); &#x2F;&#x2F; 使用MD5加密name<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个和刚才代码分析中第二个代码框中的5行结构是一模一样，计算name属性，然后加密name。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">if ((@selector(isEqualToString:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0x6, 0x7), &amp;@selector(isEqualToString:), (@selector(substringToIndex:))((@selector(stringWithFormat:))(@class(NSString), &amp;@selector(stringWithFormat:), @&quot;%02X%02X%02X%02X%02X%02X%02X&quot;, *(int8_t *)rax &amp; 0xff, *(int8_t *)(rax + 0x1) &amp; 0xff, *(int8_t *)(rax + 0x2) &amp; 0xff, *(int8_t *)(rax + 0x3) &amp; 0xff, *(int8_t *)(rax + 0x4) &amp; 0xff, *(int8_t *)(rax + 0x5) &amp; 0xff, *(int8_t *)(rax + 0x6) &amp; 0xff, *(int8_t *)(rax + 0x7) &amp; 0xff), &amp;@selector(substringToIndex:), 0x7)) &#x3D;&#x3D; 0x0) &#123;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>又是一长串条件，好像是在判断serial的某个子字符串（也就是某部分）跟name的md5值相等。</p>\n<p>这里要说明一下<code>substringWithRange:</code>的参数，研究了半天发现，0x6表示子字符串开始，<strong>0x7表示包含开头往后数七位，是子字符串的长度</strong>，也就是说这个函数返回的是serial的6到12位（我这里指的是索引）。相当于这个if条件在将name的md5值与serial的6-12位对比。</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">if ((@selector(isEqualToData:))((@selector(dataUsingEncoding:))((@selector(substringWithRange:))(r13, &amp;@selector(substringWithRange:), 0xe, 0x2), &amp;@selector(dataUsingEncoding:), 0x4), &amp;@selector(isEqualToData:), r15) &#x3D;&#x3D; 0x0) &#123;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>又是一个if。现在我们一目了然，这是在把serial索引为14、15的子字符串编码后和r15对比。诶？r15不是name的utf8编码吗？不对啊？两位和一长串名称对比，肯定返回false。别着急，我们瞧瞧ASM：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">                     -[PieAppDelegate verifySerial:andName:]:\n0000000100001342         push       rbp\n0000000100001343         mov        rbp, rsp\n0000000100001346         mov        qword [rbp+var_28], rbx\n000000010000134a         mov        qword [rbp+var_20], r12\n000000010000134e         mov        qword [rbp+var_18], r13\n0000000100001352         mov        qword [rbp+var_10], r14\n0000000100001356         mov        qword [rbp+var_8], r15\n000000010000135a         sub        rsp, 0xd0\n0000000100001361         mov        qword [rbp+var_60], rdi\n0000000100001365         mov        r13, rdx\n0000000100001368         mov        r14, rcx\n000000010000136b         mov        rdi, qword [qword_100002768]                ; qword_100002768\n0000000100001372         mov        edx, 0x4\n0000000100001377         lea        rsi, qword [0x1000022b8]                    ; &amp;@selector(dataUsingEncoding:)\n000000010000137e         call       qword [0x1000022b8]                         ; @selector(dataUsingEncoding:)\n0000000100001384         mov        r15, rax\n0000000100001387         lea        rsi, qword [0x1000022c8]                    ; &amp;@selector(length)\n000000010000138e         mov        rdi, r13\n0000000100001391         call       qword [0x1000022c8]                         ; @selector(length)\n0000000100001397         cmp        rax, 0x10\n000000010000139b         jne        loc_100001666<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们发现，函数的开头，竟然有一个我们忽略了的<code>qword_100002768</code>！跳转一下，发现它指向一个“BC”的字符串：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">    qword_100002768:\n0000000100002768 dq 0x0000000100002168 ; @&quot;BC&quot;, DATA XREF&#x3D;-[PieAppDelegate verifySerial:andName:]+41<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>那为什么说这个qword是r15呢？因为反汇编中，从rdi被赋值到被覆盖期间，只有rax传给了r15。我们推测BC就是serial索引为14、15的子字符串。</p>\n<p>回到代码分析，最后一个if嵌套的就是成功的弹窗了。</p>\n<h2 id=\"流程复现\"><a href=\"#流程复现\" class=\"headerlink\" title=\"流程复现\"></a>流程复现</h2><p>我们把上面的伪代码用Swift 5 100%重写一下，不作修改。先实现两个字符串扩展，MD5方法和<code>characterAtIndex</code>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">extension String &#123;\n    &#x2F;&#x2F; 获得字符串在索引处的字符\n    func characterAtIndex(index: Int) -&gt; Character? &#123;\n        var cur &#x3D; 0\n        for char in self &#123;\n            if cur &#x3D;&#x3D; index &#123;\n                return char\n            &#125;\n            cur +&#x3D; 1\n        &#125;\n        return nil\n    &#125;\n    var md5: String &#123;\n        let utf8 &#x3D; cString(using: .utf8)\n        var digest &#x3D; [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(utf8, CC_LONG(utf8!.count - 1), &amp;digest) &#x2F;&#x2F; 记得import CommonCrypto\n        return digest.reduce(&quot;&quot;) &#123; $0 + String(format: &quot;%02X&quot;, $1) &#125;\n    &#125;\n    &#x2F;&#x2F; 这样我们就可以通过xxx.md5的方式加密了，非常便捷\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再写验证函数：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func verifySerial(_ serial: String, name: String) &#123;\n    let encodedName &#x3D; name.data(using: .utf8)\n    if serial.count &#x3D;&#x3D; 16 &#123;\n        let processedSerial &#x3D; String(serial.prefix(6))\n        &#x2F;&#x2F; let processedSerialData &#x3D; NSData(data: processedSerial.data(using: .utf8)!)\n        &#x2F;&#x2F; let snLength &#x3D; processedSerialData.count\n        &#x2F;&#x2F; let snBytes &#x3D; processedSerialData.bytes &#x2F;&#x2F; 计算相关值\n        &#x2F;&#x2F; let md5val &#x3D; MD5(snBytes, snLength, 0x0); &#x2F;&#x2F; MD5 encryption\n        &#x2F;&#x2F; 有了我们的md5函数上面的计算都不需要了\n        var md5str &#x3D; processedSerial.md5\n        \n        if processedSerial.md5.uppercased() &#x3D;&#x3D; &quot;66EAD6FE7CBE7987B7C4B1A1EED0E5A5&quot; &amp;&amp; serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; &#123;\n            &#x2F;&#x2F; md5val &#x3D; [name dataUsingEncoding:NSUTF8StringEncoding];\n            &#x2F;&#x2F; md5vallen &#x3D; [md5val length]; &#x2F;&#x2F; 计算相关值\n            &#x2F;&#x2F; md5valbytes &#x3D; [md5valbytes bytes];\n            &#x2F;&#x2F; md5OfMd5val &#x3D; MD5(md5valbytes, md5vallen, 0x0);\n            &#x2F;&#x2F; 上面的全都不需要了\n            \n            &#x2F;&#x2F; 创建一些索引，方便我们截取字符串\n            let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)\n            let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)\n            let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)\n            let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)\n            if name.md5.prefix(7) &#x3D;&#x3D; serial[index6...index12] &#123; &#x2F;&#x2F; prefix用来取前7位\n                if serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; &#123;\n                    &#x2F;&#x2F; Registered\n                    &#x2F;&#x2F; (@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);\n                    print(&quot;Registered! &quot;)\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的if有点多，我们再以经典Swift风格写一手优雅的代码，让它返回一个值：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func verifySerial(_ serial: String, name: String) -&gt; Bool &#123;\n    guard serial.count &#x3D;&#x3D; 16 else &#123; return false &#125;\n    \n    let processedSerial &#x3D; String(serial.prefix(6))\n    guard processedSerial &#x3D;&#x3D; &quot;KRACK-&quot; else &#123; return false &#125;\n    guard serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; else &#123; return false &#125;\n    \n    let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)\n    let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)\n    let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)\n    let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)\n    \n    guard serial[index6...index12] &#x3D;&#x3D; name.md5.prefix(7).uppercased() else &#123; return false &#125;\n    guard serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; else &#123; return false &#125;\n    \n    return true\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>guard &lt;statement&gt; else &#123;&#125;</code>的作用是，确保<code>&lt;statement&gt;</code>为真，否则执行<code>else</code>代码块。</p></blockquote>\n<h2 id=\"序列号生成\"><a href=\"#序列号生成\" class=\"headerlink\" title=\"序列号生成\"></a>序列号生成</h2><p>有了验证函数做基础，我们就知道什么样的SN能被<code>verifySerial</code>接受。格式是：<code>KRACK-&lt;用户名的md5值取前7位&gt;FBC</code>。写一个Keygen，超级简单。</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">func generateSerial(from name: String) -&gt; String &#123;\n    let nameMD5 &#x3D; name.md5.prefix(7).uppercased()\n    return &quot;KRACK-\\(nameMD5)FBC&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>果然是破解容易分析难啊！</p>\n<h2 id=\"完善注册机\"><a href=\"#完善注册机\" class=\"headerlink\" title=\"完善注册机\"></a>完善注册机</h2><p>完善注册机，把我们的Keygen做成命令行形式，有<code>-gv</code>两个功能，g是生成模式，v是验证模式。</p>\n<p>全部代码<code>main.c</code>：</p>\n<pre class=\"line-numbers language-swift\" data-language=\"swift\"><code class=\"language-swift\">import Foundation\nimport CommonCrypto\n\nfunc verifySerial(_ serial: String, name: String) -&gt; Bool &#123;\n    guard serial.count &#x3D;&#x3D; 16 else &#123; return false &#125;\n    let processedSerial &#x3D; String(serial.prefix(6))\n    guard processedSerial &#x3D;&#x3D; &quot;KRACK-&quot; else &#123; return false &#125;\n    guard serial.characterAtIndex(index: 13) &#x3D;&#x3D; &quot;F&quot; else &#123; return false &#125;\n    let index6 &#x3D; serial.index(serial.startIndex, offsetBy: 6)\n    let index12 &#x3D; serial.index(serial.startIndex, offsetBy: 12)\n    let index14 &#x3D; serial.index(serial.startIndex, offsetBy: 14)\n    let index15 &#x3D; serial.index(serial.startIndex, offsetBy: 15)\n    guard name.md5.prefix(7).uppercased() &#x3D;&#x3D; serial[index6...index12] else &#123; return false &#125;\n    guard serial[index14...index15] &#x3D;&#x3D; &quot;BC&quot; else &#123; return false &#125;\n    return true\n&#125;\n\nfunc generateSerial(from name: String) -&gt; String &#123;\n    let nameMD5 &#x3D; name.md5.prefix(7).uppercased()\n    return &quot;KRACK-\\(nameMD5)FBC&quot;\n&#125;\n\nfunc askAndGenerate() &#123;\n    print(&quot;Username:&quot;, terminator: &quot; &quot;)\n    if let uname &#x3D; readLine() &#123;\n        print(&quot;Serial: \\(generateSerial(from: uname))&quot;)\n    &#125;\n    print(&quot;-----------------------&quot;)\n    askAndGenerate()\n&#125;\n\nfunc askAndValidate() &#123;\n    print(&quot;Username:&quot;, terminator: &quot; &quot;)\n    if let uname &#x3D; readLine() &#123;\n        print(&quot;Serial:&quot;, terminator: &quot; &quot;)\n        if let sn &#x3D; readLine() &#123;\n            let result &#x3D; verifySerial(sn, name: uname)\n            print(result ? &quot;Serial is valid.&quot; : &quot;Serial is invalid.&quot;)\n        &#125;\n    &#125;\n    print(&quot;-----------------------&quot;)\n    askAndValidate()\n&#125;\n\nprint(&quot;Keygen of Pie.app - by @TLHorse from www.52pojie.cn&quot;)\n\nlet argv &#x3D; ProcessInfo.processInfo.arguments\nguard argv.count &#x3D;&#x3D; 2 else &#123;\n    for i in argv &#123;print(i)&#125;\n    print(&quot;PieKeygen: error: 2 arguments is needed&quot;)\n    exit(1)\n&#125;\nswitch argv[1] &#123;\ncase &quot;-g&quot;:\n    print(&quot;--- Generation mode ---&quot;)\n    askAndGenerate()\ncase &quot;-v&quot;:\n    print(&quot;--- Validation mode ---&quot;)\n    askAndValidate()\ndefault:\n    print(&quot;PieKeygen: error: illegal operand\\nusage: PieKeygen [-gv]&quot;)\n&#125;\n\nextension String &#123;\n    func characterAtIndex(index: Int) -&gt; Character? &#123;\n        var cur &#x3D; 0\n        for char in self &#123;\n            if cur &#x3D;&#x3D; index &#123;\n                return char\n            &#125;\n            cur +&#x3D; 1\n        &#125;\n        return nil\n    &#125;\n    var md5: String &#123;\n        let utf8 &#x3D; cString(using: .utf8)\n        var digest &#x3D; [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(utf8, CC_LONG(utf8!.count - 1), &amp;digest)\n        return digest.reduce(&quot;&quot;) &#123; $0 + String(format:&quot;%02X&quot;, $1) &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2021/02/17/pie-kg-product.png\" alt=\"pie-kg-product\"></p>\n<h1 id=\"到底如何还原代码\"><a href=\"#到底如何还原代码\" class=\"headerlink\" title=\"到底如何还原代码\"></a>到底如何还原代码</h1><p>如何把Hopper的伪代码尽可能还原成真实的OC？我在Hook中有所提及，但是在这里我细说一下我研究的方法。</p>\n<p>比如拿</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">(@selector(postNotificationName:object:))((@selector(defaultCenter))(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>来说吧：</p>\n<ol>\n<li><p>首先，去掉所有<strong>单独成括号的选择器</strong>，特征是<code>(@selector(x​xx))</code>，只带@不带&amp;号，这些选择器没有地址不被调用：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">(@class(NSNotificationCenter), &amp;@selector(defaultCenter)), &amp;@selector(postNotificationName:object:), @&quot;Registered&quot;, var_60);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>现在整条语句只剩下一个括号，里面有许多“项”，由逗号分隔。从开头一直往后，逐项翻译成父子关系，<strong>遇到方法名称时，将方法名称后面的所有项翻译成这个方法的参数</strong>，把它们按照OC语法拼在一起：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:var_60];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>最后，把伪代码中的变量通过上下文替换成真实值。在伪代码中<code>var_60 = self;</code>，所以进行替换。最终还原的代码：</p>\n<pre class=\"line-numbers language-objc\" data-language=\"objc\"><code class=\"language-objc\">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;Registered&quot; object:self];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n</li>\n</ol>\n<p>其实就是把Hopper生成的替换成hook环境中真实的东西的过程。</p>\n<h1 id=\"THE-END\"><a href=\"#THE-END\" class=\"headerlink\" title=\"THE END\"></a>THE END</h1><p><strong>分析，Hook，KG一条龙，总算是完成了。</strong></p>\n","text":" www.52pojie.cn 作者：@TLHorse 原创作品，吾爱破解首发 前言本文所破解的CrackMe出自国外MSJ论坛的竞赛题目，原题估计找不着了，所以我共享在如下链载： 链接：https://share.weiyun.com/hGwzo5p4 密码：5828dk 这个...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"},{"name":"注册机","slug":"注册机","count":1,"path":"api/tags/注册机.json"},{"name":"Swift","slug":"Swift","count":1,"path":"api/tags/Swift.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">暴力破解</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hook\"><span class=\"toc-text\">Hook</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-1\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99\"><span class=\"toc-text\">代码编写</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E6%9C%BA%E7%BC%96%E5%86%99\"><span class=\"toc-text\">注册机编写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">代码分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E5%A4%8D%E7%8E%B0\"><span class=\"toc-text\">流程复现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90\"><span class=\"toc-text\">序列号生成</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%96%84%E6%B3%A8%E5%86%8C%E6%9C%BA\"><span class=\"toc-text\">完善注册机</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E8%BF%98%E5%8E%9F%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">到底如何还原代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#THE-END\"><span class=\"toc-text\">THE END</span></a></li></ol>","author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"你好，小雀儿们","uid":"76702a43cc3c40c528a6652000346268","slug":"你好，小雀儿们","date":"2021-03-06T03:10:48.000Z","updated":"2022-03-20T08:02:46.364Z","comments":true,"path":"api/articles/你好，小雀儿们.json","keywords":null,"cover":null,"text":"我亲爱的小雀儿们： &emsp;&emsp;你好！你们还好吗？ &emsp;&emsp;实在抱歉，我把你们孤零零丢在这个院子里，已经有一周了。我仍然有许多事要做，不能天天看望你们。我多么希望你们允许我爬上高大的柿子树，抚摸你们光滑的羽毛，并给你们一个热情的拥抱啊！ &emsp;&...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"随笔","slug":"随笔","count":33,"path":"api/categories/随笔.json"}],"tags":[{"name":"书信","slug":"书信","count":1,"path":"api/tags/书信.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}},"next_post":{"title":"你没看错：动手开发GUI简单操作系统（二）","uid":"3efcf09e47cda1211cfb680b33e8483e","slug":"你没看错：动手开发GUI简单操作系统（二）","date":"2021-02-10T10:36:42.000Z","updated":"2021-02-11T10:39:24.785Z","comments":true,"path":"api/articles/你没看错：动手开发GUI简单操作系统（二）.json","keywords":null,"cover":[],"text":"学习目标 编写GDT 切换到32位保护模式（32-bit protected mode，又叫PM） 我突然发现写到第二篇文章就难以启齿了，因为切PM、加载内核这些东西几乎是环环相扣的，有一点差错都不行。 另外劝大家一定要学好英文，怎么着也得七八千词汇量吧。 编写GDTGDT是最难...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"《你没听错：动手开发GUI简单操作系统》系列","slug":"《你没听错：动手开发GUI简单操作系统》系列","count":2,"path":"api/tags/《你没听错：动手开发GUI简单操作系统》系列.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}}}