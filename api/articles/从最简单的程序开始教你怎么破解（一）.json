{"title":"从最简单的程序开始教你怎么破解（一）","uid":"c5704ebec0bcac2a9b12cc350a1932a4","slug":"从最简单的程序开始教你怎么破解（一）","date":"2020-01-30T01:16:00.000Z","updated":"2021-10-07T00:48:59.288Z","comments":true,"path":"api/articles/从最简单的程序开始教你怎么破解（一）.json","keywords":null,"cover":[],"content":"<p>28号我发了一篇关于破解迅雷的文章，如果你看到了，你就会先被那上千的字数吓住。但是破解（反编译）真的有那么难吗？作为一个不太“菜”的“菜鸟”，我想告诉你，其实破解一个软件只是找到思路后，改改二进制的逻辑罢了。但是真的又有这么简单吗？也不是。</p>\n<p>如果你刚接触反编译、破解软件，那就从自己开发的最简单的小程序开始破解。今天这篇文章所讲的，是关于如何在MacOS Catalina系统里，使用Hopper Disassembler破解二进制文件。希望我可以通过这篇文章能帮到你。</p>\n<h1 id=\"入手程序\"><a href=\"#入手程序\" class=\"headerlink\" title=\"入手程序\"></a>入手程序</h1><p>我们想要破解，可以先从最简单的程序开始——<code>Crackmes</code>。<code>Crackme</code>都是一些公开给别人尝试破解的小程序，制作<code>Crackme</code>的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位<code>Cracker</code>，想挑战一下其它<code>Cracker</code>的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。<code>CrackMe</code>简称<code>CM</code>。有不少论坛的<code>CM</code>大赛就是指这个。我用<code>Swift</code>语言做了几个简单的<code>Crackme</code>，来教你们怎么破解。先看看第一个CM：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed/2020/1/29/hop-cm1-thumb.png\" alt=\"CM #1\"></p>\n<p>我的这个程序首先会用中文打印出说明书和破解要求，然后要求你输入一个固定的序列号，才能激活，如果错误，会提示让你再输入一遍，直到输入正确为止。而你的工作，就是把程序改成输入任意序列号都能激活。</p>\n<h1 id=\"分析程序\"><a href=\"#分析程序\" class=\"headerlink\" title=\"分析程序\"></a>分析程序</h1><p>将这个二进制拖入 Hopper （关于 Hopper 的使用，《破解迅雷》那篇文章有所涉及，不过有时间我可以专门出一篇文章讲 Hopper 的使用，这里不再阐述）分析。分析完成后， Hopper 应该会跳转到<code>_main</code>函数。类似下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-mainfunc.png\" alt=\"main函数\"></p>\n<p>有人说，不对啊，<code>Swift</code>语言没有<code>main</code>主函数这一说啊，为什么会有它呢？因为，<code>Swift</code>中，写法里没有主函数，但是<code>Swift</code>代码是从上往下依次执行的，因袭编译器在编译中，自然会解析到一种进程，但它不能称作主函数，只能用<strong>主进程</strong>这样的词<strong>形容</strong>。因此，所有代码都会出现在这里。</p>\n<p>面对这么多复杂的汇编指令怎么办？自然是要瞧一瞧伪代码：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">int _main(int arg0, int arg1) &#123;\n    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1);\n    rsi &#x3D; *type metadata for Any;\n    *Crackme__1.serial : Swift.String &#x3D; rax;\n    *qword_100002050 &#x3D; 0x1;\n    var_20 &#x3D; Swift._allocateUninitializedArray(0x1, rsi + 0x8);\n    rax &#x3D; Swift.String.init(\\xE8\\xAF\\xB4\\xE6\\x98\\x8E\\xEF\\xBC\\x9A\\xE6\\xAD\\xA4\\xE7\\xA8\\x8B\\xE5\\xBA\\x8F\\xE8\\xA6\\x81\\xE6\\xB1\\x82\\xE4\\xBD\\xA0\\xE8\\xBE\\x93\\xE5\\x85\\xA5\\xE4\\xB8\\x80\\xE4\\xB8\\xAA\\xE5\\x9B\\xBA\\xE5\\xAE\\x9A\\xE7\\x9A\\x84\\xE5\\xBA\\x8F\\xE5\\x88\\x97\\xE5\\x8F\\xB7\\xEF\\xBC\\x8C\\xE6\\x89\\x8D\\xE8\\x83\\xBD\\xE6\\xBF\\x80\\xE6\\xB4\\xBB\\xE3\\x80\\x82\\n\\xE8\\xA6\\x81\\xE6\\xB1\\x82\\xEF\\xBC\\x9A\\xE6\\x8A\\x8A\\xE7\\xA8\\x8B\\xE5\\xBA\\x8F\\xE6\\x94\\xB9\\xE6\\x88\\x90\\xE8\\xBE\\x93\\xE5\\x85\\xA5\\xE4\\xBB\\xBB\\xE6\\x84\\x8F\\xE5\\xBA\\x8F\\xE5\\x88\\x97\\xE5\\x8F\\xB7\\xE9\\x83\\xBD\\xE8\\x83\\xBD\\xE6\\xBF\\x80\\xE6\\xB4\\xBB\\xE3\\x80\\x82\\n, 0x89, 0x0, 0x0);\n    *(int64_t *)0x19 &#x3D; *type metadata for Swift.String;\n    *(int64_t *)0x1 &#x3D; rax;\n    *(int64_t *)0x9 &#x3D; 0x0;\n    var_28 &#x3D; default argument 1 of Swift.print();\n    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0);\n    swift_bridgeObjectRelease(0x0);\n    swift_bridgeObjectRelease(0x0);\n    swift_bridgeObjectRelease(var_20);\n    Crackme__1.verify(var_20, var_28);\n    return 0x0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>虽然我不太懂OC，也不太懂这代码说的是什么，但是至少知道了如下几点（看代码注释）：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">int _main(int arg0, int arg1) &#123; &#x2F;&#x2F; main函数\n    rax &#x3D; Swift.String.init(82mal9-29anyw-9msfz6, 0x14, 0x1); &#x2F;&#x2F; Swift的字符串初始化。从字符串看，很可能是注册码：82mal9-29anyw-9msfz6\n    ...\n    rax &#x3D; Swift.String.init(\\xE8\\xAF\\xB4\\xE6\\x98\\x8E\\xEF\\xBC\\x9A\\xE6\\xAD\\xA4\\xE7\\xA8\\x8B\\xE5\\xBA\\x8F\\xE8\\xA6\\x81\\xE6\\xB1\\x82\\xE4\\xBD\\xA0\\xE8\\xBE\\x93\\xE5\\x85\\xA5\\xE4\\xB8\\x80\\xE4\\xB8\\xAA\\xE5\\x9B\\xBA\\xE5\\xAE\\x9A\\xE7\\x9A\\x84\\xE5\\xBA\\x8F\\xE5\\x88\\x97\\xE5\\x8F\\xB7\\xEF\\xBC\\x8C\\xE6\\x89\\x8D\\xE8\\x83\\xBD\\xE6\\xBF\\x80\\xE6\\xB4\\xBB\\xE3\\x80\\x82\\n\\xE8\\xA6\\x81\\xE6\\xB1\\x82\\xEF\\xBC\\x9A\\xE6\\x8A\\x8A\\xE7\\xA8\\x8B\\xE5\\xBA\\x8F\\xE6\\x94\\xB9\\xE6\\x88\\x90\\xE8\\xBE\\x93\\xE5\\x85\\xA5\\xE4\\xBB\\xBB\\xE6\\x84\\x8F\\xE5\\xBA\\x8F\\xE5\\x88\\x97\\xE5\\x8F\\xB7\\xE9\\x83\\xBD\\xE8\\x83\\xBD\\xE6\\xBF\\x80\\xE6\\xB4\\xBB\\xE3\\x80\\x82\\n, 0x89, 0x0, 0x0); &#x2F;&#x2F; 这一大长串的东西也是字符串初始化，应该是中文，可能是“说明”和“要求”的字符串\n    ...\n    var_28 &#x3D; default argument 1 of Swift.print();  &#x2F;&#x2F; 打印了那一长串中文\n    Swift.print(var_20, var_28, 0x0, default argument 2 of Swift.print(), 0x0); &#x2F;&#x2F; 打印了那一长串中文\n    ...\n    Crackme__1.verify(var_20, var_28); &#x2F;&#x2F; 调用了一个叫verify的函数\n    return 0x0; &#x2F;&#x2F; 程序结束\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最吸引人的是<code>verify()</code>函数，它有两个参数：<code>var_20</code>和<code>var_28</code>。这个函数把这两个参数做比较，最后打印出结果。因为函数后面没有打印结果的操作，所以这个打印结果的操作应该在函数里。</p>\n<p>双击这个函数，就能查看。这个函数不短（其实源代码很短），我们来看关键点：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">int _$s10Crackme__16verifyyyF(int arg0, int arg1) &#123;\n    ... &#x2F;&#x2F; 定义了一些东西，还打印了说明和要求\n    if ((var_89 &amp; 0x1) &#x3D;&#x3D; 0x0) &#123; \n        &#x2F;&#x2F; 判断语句\n    &#125;\n    else &#123; \n        &#x2F;&#x2F; 判断语句\n    &#125;\n    rax &#x3D; outlined consume of Swift.String?(var_70, 0x1);\n    return rax; &#x2F;&#x2F; 执行一些结束用的代码\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们只要让程序执行正确的语句就行了。但是怎么判断条件语句中<code>if</code>是正确的，还是<code>else</code>是正确的呢？经过仔细观察，我们看见了<code>if</code>中有一个代码：</p>\n<pre class=\"line-numbers language-objectivec\" data-language=\"objectivec\"><code class=\"language-objectivec\">Crackme__1.verify(var_D0, rsi);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>按照程序的思路，用户输错了，程序会提示你错误，然后再次调用函数，让用户重新输入序列号。函数中会嵌套一个同样的函数，不难看出这是<strong>递归</strong>，按照思路走，递归一般会使用在用户序列号错误的情况，因此：<code>if</code>中是用户输错的情况，<code>else</code>是输对的情况。只要让程序执行<code>else</code>代码块即可。</p>\n<h1 id=\"修改程序\"><a href=\"#修改程序\" class=\"headerlink\" title=\"修改程序\"></a>修改程序</h1><p>随便在<code>else</code>中选一段代码，切回<code>CFG Mode</code>，可以看到，这段代码在<code>loc_100000ba2</code>里，因此<code>loc_100000ba2</code>是正确代码。沿着上面的箭头找，就会发现上面的主程序是<code>_$s10Crackme__16verifyyyF</code>函数，只需把函数下的<code>jne</code>做一个硬性跳转，换成<code>jmp</code>：</p>\n<pre class=\"line-numbers language-nasm\" data-language=\"nasm\"><code class=\"language-nasm\">jmp loc_100000ba2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-jmp.jpg\" alt=\"换成jmp\"></p>\n<p>之后按回车。</p>\n<h1 id=\"修改完成\"><a href=\"#修改完成\" class=\"headerlink\" title=\"修改完成\"></a>修改完成</h1><p>回车后，你的 Hopper 可能会出现这个诡异的画面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm1-cfgbug.png\" alt=\"CFG bug\"></p>\n<p>不用怕，这只是 Hopper 的 CFG bug。之所以它显示这个画面，是因为你在CFG模式下，然而你的光标自动跳转到了白色区域的代码，这段代码已经不存在了（被<code>ret</code>了）。因此随便点击 Hopper 的任意位置（白色区域代码外），就可以回到 CFG 了。接下来，让我们在纵观一下 CFG：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/2020/1/29/hop-cm2-cfg.png\" alt=\"纵观 CFG\" style=\"zoom:50%;\" />\n\n<p>怎么样？刚才的两个分支变成了一个分支了。运行一下程序，无论输入什么，都可以成功激活。这么鼓捣下来，还是挺有趣的。</p>\n<blockquote>\n<p>再次声明：<strong>无论任何人使用文章中的技术破解任何软件造成的后果，请自行承担</strong>。  </p>\n</blockquote>\n","text":"28号我发了一篇关于破解迅雷的文章，如果你看到了，你就会先被那上千的字数吓住。但是破解（反编译）真的有那么难吗？作为一个不太“菜”的“菜鸟”，我想告诉你，其实破解一个软件只是找到思路后，改改二进制的逻辑罢了。但是真的又有这么简单吗？也不是。 如果你刚接触反编译、破解软件，那就从自...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%A5%E6%89%8B%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">入手程序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">分析程序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">修改程序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E5%AE%8C%E6%88%90\"><span class=\"toc-text\">修改完成</span></a></li></ol>","author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"“木兰”辞","uid":"005508bb15f7d36e915d26ba39edc9cc","slug":"“木兰”辞","date":"2020-03-09T01:16:00.000Z","updated":"2022-03-20T08:02:46.400Z","comments":true,"path":"api/articles/“木兰”辞.json","keywords":null,"cover":null,"text":" 针对此前刘雷团队对外宣布“自主研发的‘木兰’编程语言体系“，中科院计算技术研究所1月24日在官网发布相关调查与处理意见，称刘雷在宣传活动中存在虚假陈述行为，同时在对外宣传活动中存在对单位的欺瞒行为。对刘雷的处理包括取消五年内专业技术岗位晋升的申请资格、全所通报批评、岗位等级降低...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"随笔","slug":"随笔","count":33,"path":"api/categories/随笔.json"}],"tags":[{"name":"诗歌","slug":"诗歌","count":1,"path":"api/tags/诗歌.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}},"next_post":{"title":"从最简单的程序开始教你怎么破解（二）","uid":"fe0844f28d620c750572bf26776fbb40","slug":"从最简单的程序开始教你怎么破解（二）","date":"2020-01-30T01:16:00.000Z","updated":"2021-10-07T00:48:59.288Z","comments":true,"path":"api/articles/从最简单的程序开始教你怎么破解（二）.json","keywords":null,"cover":[],"text":"今天，我们还讲Hopper反编译，不过用的还是昨天的CM。我今天准备告诉大家，怎样替换程序里的字符串，这样就可以为所欲为了。 目标：把程序修改成，只有使用自己规定的注册码，才能激活成功。 开始分析首先，程序拖入 Hopper 解析。完成后，在左边的搜索视图中选择Str，查看程序里...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"计算机","slug":"计算机","count":24,"path":"api/categories/计算机.json"}],"tags":[{"name":"反编译","slug":"反编译","count":16,"path":"api/tags/反编译.json"}],"author":{"name":"TLHorse","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/TLHorse/TLBlogBed@master/blog_img/avatar.jpg","link":"/","description":"","socials":{"github":"https://github.com/TLHorse","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_45415111","juejin":"","customs":{}}}}}